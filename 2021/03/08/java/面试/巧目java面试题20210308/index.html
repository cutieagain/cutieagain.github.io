<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="巧目java面试题目20210308, 欧葵小站">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>巧目java面试题目20210308 | 欧葵小站</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">欧葵小站</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">欧葵小站</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/cutieagain" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/cutieagain" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">巧目java面试题目20210308</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                面试
                            </a>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95/java/" class="post-category">
                                java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-08
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-03-22
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    48.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    170 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>参考网址：</p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402971648033">廖雪峰java</a></p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><ul>
<li>hashmap1.7跟1.8？优化点？红黑树化为什么是8？退化为什么？</li>
<li>dp怎么玩？回溯怎么玩？递归怎么玩？stack能解决啥问题？fifo能解决啥问题？dfs怎么玩？bfs怎么玩？</li>
<li>双亲委派模型。JDBC和双亲委派模型关系</li>
<li>TCP四次挥手，TIME_WAIT发生在哪一方 TIME_WAIT过多如何处理</li>
<li>HashMap底层结构 put操作讲一下,HashMap、HashMap如何保证线程安全、ConcurrentHashMap</li>
<li>从ConcurrentHashMap一路问到锁&amp;锁优化-&gt;LongAdder-&gt;伪共享-&gt;缓存行填充-&gt;cas等诸多技术细节；</li>
<li>观察者模式与中介者模式有什么区别？</li>
<li>手写一个基于懒汉式的双重检测的单例。</li>
<li>HashMap相关?为什么要引入红黑树？ 如何在红黑树中插入一个节点。 链表是如何转换为红黑树的？</li>
<li>对ConcurrentHashMap的理解，⽐如在什么地⽅会涉及到线程安全问题以及ConcurrentHashMap是如何解决的？</li>
<li>Http请求的完全过程</li>
<li>HashMap扩容的触发条件是什么</li>
<li>HashMap的实现原理，什么是hash碰撞，怎样解决hash碰撞？</li>
<li>mysql的sql本身没问题的情况下，没走索引原因</li>
<li>mysql快照是怎么实现的</li>
<li>mysql分页有什么优化</li>
<li>讲一下Http，HTTP安全不？HTTPS如何解决的？HTTP的数字证书如何认证？TCP与UDP区别？TCP为什么要四次？ 为什么TIME_WAIT 等待的时间是 2MSL？已经主动关闭连接了为什么还要保持资源一段时间呢？ TIME_WAIT 过多有什么危害？如果已经建⽴了连接，但是客户端突然出现故障了怎么办？保活机制说一下？</li>
<li>说一下undolog， redolog MySQL如何保证redo log和binlog的数据是一致的，如果一个sql执行很慢，你能分析一下原因吗？ 为什么数据库会选错了索引</li>
<li>对乐观锁和悲观锁的理解；</li>
<li>hashMap什么情况下会出现循环链表？concurrentHashMap写的时候用什么锁？</li>
<li>定义Integer x=20 Integer y=200 在内存里是个什么过程？ volite关键字的原理？它能保证原子性吗？AtomicInteger底层怎么实现的？</li>
<li>threadLocal关键字有用过吗？如果没有重写initialValue方法就直接get会怎样？</li>
<li>1.java的基本数据类型与包装类； 2、final修饰变量类方法； 3、String为什么是不可变的，以及new String(“abc”)创建了几个对象； 4、String、StringBuffer、以及StringBuilder的区别； 5、static修饰变量，方法，代码块； 6、重写跟重载的区别； 7、接口跟抽象类； 8、反射、继承、枚举、异常等知识点； 9、为什么要重写hashcode和equals方法，以及hashcode相同equals是否相同</li>
<li>集合相关 1、ArrayList的底层实现、扩容过程、add过程、Fail-Fast机制； 2、ArrayList与Linkedlist、Vectot的区别； 3、如何获得一个线程安全的List； 4、CopyOnWriteArrayList是如何实现线程安全的； 5、Linkedlist的底层实现，以及如何使用LinkedList实现一个LRU； 6、TreeSet、HashSet、LinkedHashSet的底层实现以及之间的区别； 7、PriorityQueue、LinkedBlockingQueue、ArrayBlockingQueue的实现以及区别； 8、HashMap的底层实现，扩容过程，达到阈值一定会扩容吗、put过程、树化过程，如何确定负载因子、以及为什么线程不安全和1.8做了哪些优化； 9、HashMap与HashTable的区别，如何获得一个线程安全的Map； 10、ConcurrentHashMap为什么是线程安全的，以及1.8做了哪些优化； 11、LinkedHashMap的底层实现，以及如何实现LRU； 12、TreeMap的底层实现； 13、迭代器的实现；</li>
<li><ol>
<li>面向对象的特点有哪些？ 2. 列举几个java常用的package及其作用 3. 接口和抽象类有什么联系和区别 4. 重载和重写有什么区别 5. java有哪些基本数据类型？ 6. Java支持的数据类型有哪些？什么是自动拆装箱？ 7. int 和 Integer 有什么区别 8. 数组有没有length()方法？String有没有length()方法？ 9. Java中符号&gt;&gt;和&gt;&gt;&gt;有什么区别？ 10. Java类的实例化顺序 11. 什么是值传递和引用传递 （1）值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. （2）引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 12. String能被继承吗？为什么？ 13. String和StringBuilder、StringBuffer的区别？</li>
</ol>
</li>
<li>深拷贝和浅拷贝。</li>
<li>Integer a1 = new Integer(2); Integer a2 = new Integer(2); a1.equals(a2)的结果？？</li>
<li>为什么在重写equals方法的时候要重写hashcode的方法？</li>
<li>HTTP 1.0 和 HTTP 2.0 的区别 HTTP 2.0 做了哪些优化</li>
<li>JDK中偏向锁、自旋锁、轻量级锁、重量级锁的区别？ JDK锁自旋的自旋阈值了解吗？如何调整自旋次数？</li>
<li>如果相等hash对象太多，那么怎么解决迭代的影响？</li>
<li>服务器CPU数量及线程池数量的关系？</li>
<li>一亿条记录，内存中肯定放不下，要怎么找出其中最大的十条？</li>
<li>为什么要用读写锁而不用synchronized这种同步锁？</li>
<li>事务隔离性的理解，为什么会有脏读，可重复读，提交读等。</li>
<li>了解哪些设计模式，6个设计原则分别是什么？每种设计原则体现的设计模式是哪个？</li>
<li>如何实现session共享？用Redis该如何实现？</li>
<li>常见的stackoverflowexception,outofmemoryexception是怎么回事；</li>
<li>top和jstack命令用过没，jstack命令的nid是什么意思，怎么查看java某个进程的线程？</li>
<li>ABA怎么发生的，怎么解决ABA问题</li>
<li>Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？</li>
<li>什么是死锁？ 2.死锁产生的条件？ 3.怎样避免死锁？</li>
<li>TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么 .TIME_WAIT和CLOSE_WAIT的区别 .说说你知道的几种HTTP响应码</li>
</ul>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>链表，常见的面试题有写一个链表中删除一个节点的算法、单链表倒转、两个链表找相交的部分，这个一般必须得完全无误的情况下写出来；</li>
<li>给出两个链表的头结点，找出这两个链表的交点。</li>
<li>java 中数组和链表的区别，各自优势 如何设计拥有高效的随机读取能力的的链表（跳表） 设计跳表，跳表插入开销，跳表随机读取过程</li>
<li>给你一个单向链表，给这个链表做K反转，例如 k=3 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 反转后为： 3 -&gt; 2 -&gt; 1 -&gt; 6 -&gt; 5 -&gt; 4 链表长度保证为K的倍数</li>
<li>给定一个链表，返回链表开始入环的第一个节点</li>
<li>n个降序的链表返回前K个大的节点构成的链表</li>
<li>链表合并：给出n个有序的链表，将他们合并为一个有序链表。</li>
<li>有k个有序单链表，怎么合并成一个有序单链表？</li>
<li>链表逆序，不能用修改指针的方法，用递归如何实现。</li>
<li>反转单链表</li>
<li>知道双向链表怎么翻转吗</li>
<li>有两个数字非常大已经超出了long型的范围，现在以链表的方式存储其中链表头表示最高位，例如1-&gt;2-&gt;3-&gt;4表示1234，请设计一个算法求出两数之和；</li>
<li>反转数字，不能把数字变成字符串</li>
<li>链表找环的入口</li>
<li>单链表的逆序</li>
<li>两个链表合并，最长公共子串问题</li>
<li>单链表逆序，快排，数组中找两个数和等于目标值</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>在M个大小的数组中找到第K大的数（最大堆）</li>
<li>我现在有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，•[2,1,4,3]。。。。你这个算法的时间复杂度是多少</li>
<li>数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数 •先说下你的思路 •下一个奇数？怎么找？ •有思路么？ •你这样时间复杂度有点高，如果要求O(N)要怎么做</li>
<li>手写算法，两个有序数组的合并。</li>
<li>十万行二维数组，每行长度为10，每个数组降序，找出最大的15个数。先跟面试官说了思路，然后又在白纸上写了出来</li>
<li>对一个数组进行绝对值排序的算法；</li>
<li>非降序数组，打印某个值最后出现的位置</li>
<li>找出数组中超过半数的那个数字（摩尔投票）</li>
<li>一个数组反转，o(logn)复杂度用什么排序算法；</li>
<li>一个 100长度数组, 里面是 固定的随机数, 要求列出重复的数字的最优算法.；</li>
<li>给定两个数组，每个数组中都有重复的数字。不用类库函数，对这两个数组排序。</li>
<li>给定一个数组，求该数组所有的自子数组 去掉一个字符串中的所有空格</li>
<li>给定一个数组，元素的大小0~25，有重复元素。按出现频次的高低输出所有的数字</li>
<li>给定一个乱序数组，求数组内最大连续的数；</li>
<li>无序数组找第k大的数</li>
<li>给一个数组，和k，求数组中的哪两个数之和为k，除了双层for循环和字典的方式还能用什么方式实现；</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>写二分查找算法</li>
<li>有主字符串A，子字符串B，在A中查找B</li>
<li>手撕一个有序数组的二分查找算法</li>
<li>请说出二分查找的实现思路及时空复杂度。</li>
<li>用二分法查找一个长度为18的，排好的线性表，当查找不成功时，最多需要比较多少次</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>快排怎么实现的，快速排序（包括算法步骤、平均算法复杂度、最好和最坏的情形）</li>
<li>5亿整数的大文件，怎么排？</li>
<li>两个1G排好序的文件，按序合并</li>
<li>手写归并排序。 两个有序数组合并。</li>
<li>常见的排序算法有哪些？各种排序算法的平均时间复杂度和最坏情况下的时间复杂度？</li>
<li>写出你熟悉的排序算法，并说明其优缺点</li>
<li>给了长度为N的有重复元素的数组，要求输出第10大的数。</li>
<li>手写一下快速排序吧，我看你参加过ACM，所以用非递归实现一下。</li>
<li>快排听过吗？他是怎么实现的？</li>
<li>如果是单链表的快速排序，你怎么做？</li>
<li>快排时间空间复杂度，最好最坏的情况，优化方案？</li>
<li>手写了冒泡排序</li>
<li>手写递归排序等</li>
<li>两个排序好的数组，构思算法把一个按序插入另一个数组</li>
<li>手工实现一个快速排序算法</li>
<li>列举数据的几个排序算法</li>
<li>快速排序？快速排序是稳定的么？ 如何实现一个快速排序的稳定性？</li>
<li>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</li>
<li>快排会吗？知道原理吗？</li>
<li>排序算法，介绍一下快速排序，快速排序时间复杂度，是不是稳定排序，介绍几种你所知道的稳定排序算法</li>
<li>10亿个数选最大的K个，用什么方法，复杂度多少</li>
<li>说一下冒泡排序的原理</li>
<li>请对3个有序数组进行归并排序</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>AVL树和B树的概念、细节，比如会问mysql数据库的索引的实现原理，基本上就等于问你B树了。</li>
<li>红黑树，这个基本上必问的一个数据结构，包括红黑树的概念、平均算法复杂度、最好最坏情况下的算法复杂度、左右旋转、颜色变换。</li>
<li>找出二叉树中任意两个节点的最低公共根节点, 如果树是BST呢. 深度优先搜索+二分查找树性质</li>
<li>B+树如何分裂？</li>
<li>二叉树前中后遍历 二叉树层次遍历 二叉树深度优先遍历(递归、非递归) 二叉树广度优先遍历(递归、非递归) 和为n的二叉树路径 二叉树深度 二叉树是否对称 链表反转</li>
<li>红黑树有啥特性?</li>
<li>二叉树层序遍历输出，每一层输出数组（手写算法）。</li>
<li>JDK1.8采用的红黑树特性，以及采用红黑树的理由而不采用AVL和B树的原因？</li>
<li>一个二叉搜索树，找出某两个节点的公共祖先。</li>
<li>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 例如，输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li>
<li>平衡二叉树的基本概念 简单介绍一下b+树</li>
<li>多叉树的生成 给定一个数组【[a,b]、[c,b]、[e,a]、[h,a]、[k,h]】，数组前一个代表子节点、后一个代表父节点，生成一颗多叉树，返回根节点</li>
<li>按照Z字形分层遍历二叉树，要求bug free，并且构造二叉树进行测试</li>
<li>二叉树的右视图。</li>
<li>写一个二叉树的深度遍历</li>
<li>二叉树翻转</li>
<li>二叉树的s型遍历，层序遍历的变种，简单，不过要写测试用例，等于还要写一个数组转二叉树的函数</li>
<li>一颗非平衡二叉树，如何最快的方式找到距离最远的两个叶子节点。</li>
<li>给一个二叉树和一个目标值，找到和等于这个值的所有路径</li>
<li>B和B+树，B+树的搜索次数、为什么不用二叉树。</li>
<li>红黑树最差旋转几次</li>
<li>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。 最近公共祖先是两个节点的公共的祖先节点且具有最大深度。 假设给出的两个节点都在树中存在。</li>
<li>层次遍历二叉树，返回一个二维数组，每行表示一层</li>
<li>不用迭代方法计算树的高度；</li>
<li>假设一棵二叉树的后序遍历序列为DFGGEBHICA,中序遍历序列为：DBFEGAHCI,则前序遍历序列为？</li>
<li>多叉树的第n层 层次遍历 2.递归太深会怎样？答栈溢出。为什么会栈溢出？python函数中的临时变量存在哪？那很深的时候，用循环会怎样呢？为什么不会栈溢出？</li>
<li>给定一个二叉树，依次打印出每一行</li>
<li>前序遍历 中序遍历 后序遍历 知道那些可以恢复二叉树，只知道前序和后序可以吗？</li>
<li>有N个节点的满二叉树的高度</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>哈希表，对哈希表的细节要求很高，比如哈希表的冲突检测、哈希函数常用实现、算法复杂度；比如百度二面就让我写一个哈希表插入元素算法，元素类型是任意类型。</li>
<li>找出两个有序数组中的重复项，分析时间和空间复杂度，然后就是不断优化优化优化。。 要是数组长度非常大会出现什么情况？</li>
<li>俩线程分别持续打印奇数和偶数，实现俩线程的交替打印（从小到大）</li>
<li>给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: s = “3[a]2[bc]”, 返回 “aaabcbc”. s = “3[a2[c]]”, 返回 “accaccacc”. s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.</li>
<li>leetcode213 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 输入: [1,2,3,1] 输出: 4 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。</li>
<li>有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒</li>
<li>看你简历提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？</li>
<li>根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</li>
<li>一个二维数组，每一列的数字从左往右增大，每一行从上往下增大，求一个指定的数字在这个数组中的位置</li>
<li>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li>
<li>股票买卖的一道题 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li>
<li>给你一个 n * m 的二维整数数组，数字都是大于等于0，现在要你对数组做一种操作，对于所有0，将0所在的行和列全部变为0。要求使用尽量少的空间和时间。</li>
<li>给你一个整数数组，数组中的元素定义一种距离 d[i] 为将数组排序后，该元素移动的距离，现在给你一个K数组，即数组中所有元素的距离d &lt;= k，对这个K数组排序，希望尽量小的时间复杂度。</li>
<li>输入一个不含相同整数的整数集合，输出所有子集 输入：[1,2,3] 输出：[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]] 有三十瓶水，十个桶，每个桶能放0-10瓶水，有多少种方案</li>
<li>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = “abcdefg”, k = 2 输出: “bacdfeg” 要求: （1）该字符串只包含小写的英文字母。 （ 2）给定字符串的长度和 k 在 [1, 10000]范围内。</li>
<li>翻转字符串，反转句子等。</li>
<li>判断一串字符串里括号的最大有效长度。用动态规划实现</li>
<li>给一个字符串，找出连续相同的字符，如果有两个以上相同的，取ASCII码小的。</li>
<li>给一个字符串，删除最大连续相同的字符串并返回</li>
<li>有一组未排序的整形数组，你设计一个算法，对数组的元素两两配对，然后输出最大的绝对值差和最小的绝对值差的”对数”</li>
<li>m*n二维数组整体有序，查找value</li>
<li>返回一个数字数组的排序值，比如数据[6,2,5,0]的返回是[4,2,3,1]；</li>
<li>一个正数数组，长度为N，且数组元素&lt;N，统计每个正数出现的次数，要求时间复杂度O(n)，空间复杂度O(1)；</li>
<li>实现一个fibonacci函数，输入数字n，输出fibonacci数列的第n项数字，并给该函数加入缓存功能。</li>
<li>100G文本找某个单词出现的频率</li>
<li>是否连接红黑树 •</li>
<li>是否了解数据结构的“堆”</li>
<li>斐波拉契数列非递归实现</li>
<li>算法n的阶乘末尾0的个数</li>
<li>我一个文件,有45亿个阿拉伯数字,如何进行去重啊?如何找出最大的那个数啊?</li>
<li>写一个fibnaccio的相关例子</li>
<li>输入两个字符串str1 str2和整数n，要求两个数以n进制相加，然后输出字符串str3</li>
<li>就是二位数组如何进行螺旋输出 然后第二道的算法题是如何从25匹马中通过赛马的形式找到最快的3匹，每次最多只能5匹马参赛，问最少需要赛几次？答案是7次，我思路对了，不过我把次数给弄错了，多了2次没必要的比赛。</li>
<li>6个元素1.2.3.4.5.6的顺序进栈，请问下列哪个不是合法的出栈序列？ a:345261 b:436521 c:245316 d:124653 e:543612</li>
<li>图的最短路径问题</li>
<li>算法题（爬楼梯，问一个人爬楼梯，每次只能爬一个台阶或两个台阶，问有N个台阶，总共能有多少种爬法）；</li>
<li>实现一个random(m,n)方法，返回m到n的随机数</li>
<li>64只球队找到最强的，找前二强的，前k强的</li>
<li>就是m*n的矩形从左上面到右下面的路径有多少条</li>
<li>求N内的所有素数</li>
<li>判断字符串是否是一个数字</li>
<li>当一个文本文件中有200万行数据，如何在在每一行的尾部追加一个字符；</li>
<li>求一个字符串中最长不重复子串的长度</li>
<li>三个有符号的整型（long）数a, b, c，怎么判断a+b &gt; c?实现并且设计测试用例（在main函数中调用，打印结果） （考虑同号越界问题）</li>
<li>给一个字符串和一个k，要求找到不超过k个不同字符的最长子串的长度</li>
<li>10进制转16进制（紧张了，有点费时间，啧啧啧）</li>
<li>f(0)=0;f(1)=1; f(n)=f(n-1)+f(n-2) 求f（n）</li>
<li>有主字符串A，子字符串B，在A中查找B</li>
</ul>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="多线程类的使用"><a href="#多线程类的使用" class="headerlink" title="多线程类的使用"></a>多线程类的使用</h2><ul>
<li>java线程同步有哪些方法、各自的优缺点</li>
<li>synchronized 和ReentrantLock区别，可重入锁是什么？</li>
<li>threadlocal有什么用</li>
<li>Java中创建线程有几种方式？分别是？ 当主线程执行结束后，子线程还会继续执行下去吗？</li>
<li>JUC中有哪些常用的集合？（项目中用到的）</li>
<li>CopyOnWriteArrayList的实现原理？主要应用什么场景下？优缺点分别是？</li>
<li>HashMap不是线程安全的，在高并发环境中做插入会出现什么情况？为什么？</li>
<li>jdk1.8以前ConcurrentHashMap是如何实现线程安全的？jdk1.8以后呢？（1.8synchronized加CAS，并引入了红黑树）</li>
<li>当调用ConcurrentHashMap的size方法时，有元素并发插入，ConcurrentHashMap是怎么处理的？</li>
<li>synchronized和java.util.concurrent.locks.Lock的比较。 AtomicInteger原理，为什么要用CAS而不是synchronized？ 银行的后端如果出现多人想一个账户大钱的情况，会碰到什么问题？</li>
<li>什么是CAS操作，如何实现一个自定义锁</li>
<li>Synchronized的实现，锁的升级过程。</li>
<li>AQS锁了解么？</li>
<li>wait()、notify必须在什么情况下使用</li>
<li>线程、进程、协程的关系。</li>
<li>对volatile的理解</li>
<li>详细的说一下concurrentHashMap put流程</li>
<li>你是如何理解同步/异步，并发/并行的概念的</li>
<li>那谈谈Lock接口的API以及其实现类相关的了解？</li>
<li>那么ReentrantLock中的lock和unlock之间的同步如何进行线程间的通信？</li>
<li>Semaphore类的了解？</li>
<li>JUC包下的计数锁？CountDownLatch？</li>
<li>CyclicBarrier的理解？</li>
<li>ReadWriteLock与ReentrantReadWriteLock的理解和区别？</li>
<li>你还了解ReentrantReadWriteLock哪些特性？</li>
<li>ReentrantLock如何实现公平和非公平锁是如何实现？ CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？</li>
<li>乐观锁和悲观锁的区别？ 如何实现一个乐观锁？</li>
<li>AQS是如何唤醒下一个线程的？</li>
<li>ConcurrentHashMap是如何让多线程同时参与扩容？get需要加锁么，为什么？</li>
<li>Disruptor框架的用法，实现</li>
<li>Future的异步调用过程是咋样的？Future超时的情况？无限递归会造成jvm内存的什么问题？</li>
<li>Java8之后的ConcurrentHashMap为什么舍弃分段锁？</li>
<li>线程池一整套（实现类及对应的阻塞队列、拒绝策略、具体参数、ScheduledThreadPool有三种构造方法，分别代表什么含义？）</li>
<li>synchronized分别修饰在实例方法上和静态方法上，多线程并发时是否会竞争锁？synchronized修饰在方法上和代码块上有什么区别，底层是怎么实现的？</li>
<li>并发编程中的生产者消费者模式代码。［最简单的方式就是使用wait和notify去阻塞唤醒，当然还可以使用可重入锁(ReentrantLock)，使用锁计数器(CountdownLatch)等等］</li>
<li>为什么要用读写锁而不用synchronized这种同步锁</li>
<li>如何实现控制线程在某段时间内完成，不完成就撤销。</li>
<li>参照ConcurrentHashMap，如果在多线程场景下使用HashMap，有什么手段提高效率又保证线程安全吗？</li>
<li>对Java内存模型的理解，以及其在并发中的应用；指令重排序，内存栅栏等</li>
<li>Java 有什么锁类型？</li>
<li>并发容器有哪些,并发容器和同步容器的区别？</li>
<li>CLH同步队列是怎么实现非公平和公平的？</li>
<li>HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。</li>
<li>Lock接口有哪些实现类，使用场景是什么。</li>
<li>可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment）</li>
<li>CountDown有了解过吗？CountDown和CycliBarrier的区别是是什么？在使用上有啥区别？</li>
<li>volatile从指令重排序，内存屏障，聊到总线风暴</li>
<li>问了父子线程怎么共享数据</li>
<li>List是非线程安全的，你如何把他变成线程安全的？</li>
<li>synchronized可否在运行当前线程时运行其它线程</li>
<li>什么叫守护线程，用什么方法实现守护线程？如何停止一个线程？</li>
<li>并发编程问的很细。多个线程达到同一个状态然后再一起执行，达到某一个状态之后再继续并发执行，这种怎么实现？</li>
<li>如何实现控制线程在某段时间内完成，不完成就撤销</li>
<li>读写锁中加读锁后如何避免写线程饿死</li>
<li>线程池的一些原理，锁的机制升降级</li>
<li>问自旋锁实现的方式是什么 问指针指向的地址是虚拟地址还是物理地址。 问页表置换的算法有哪些，以及现如今哪种算法比较高效。 问缺页异常置换的过程。 如果一个线程修改一个数据，但这时候需要把当前页表置换出去，操作系统如何处理。</li>
<li>进程与线程的区别，怎么根据硬件确定你最大创建的线程数（线程池需要考虑）</li>
<li>JDK锁自旋的自旋阈值了解吗？如何调整自旋次数？</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>线程池 什么时候到达最大线程数 到达最大线程后继续提交的表现 用过哪些锁</li>
<li>线程池有哪些核心参数？简单描述下线程池的原理？</li>
<li>创建线程池的方式？</li>
<li>线程池线程的提交方式和优缺点。</li>
<li>如果我们在线程池中使用无界队列会造成什么影响呢？</li>
<li>多个核心线程去take阻塞队列中线程，谁能拿到了？</li>
<li>线程池怎么实现复用线程的</li>
<li>JDK中偏向锁、自旋锁、轻量级锁、重量级锁的区别？ JDK锁自旋的自旋阈值了解吗？如何调整自旋次数？</li>
<li>你们系统中下单的时候为什么要用线程池？可以用其他的实现方案吗？</li>
</ul>
<h2 id="多线程的扩展"><a href="#多线程的扩展" class="headerlink" title="多线程的扩展"></a>多线程的扩展</h2><ul>
<li>分布式锁zookeeper的使用场景—— 实现分布式锁的方式———-redis分布式锁和zookeeper分布式锁</li>
<li>你会如何处理高并发场景，例如商城秒杀？</li>
<li>数据库的并发策略</li>
<li>高并发时如何限流</li>
<li>场景模拟:假设有一个场景，系统需要某个特定时间内响应用户请求，比如说100ms内完成用户请求，但是在最高峰的时候每单位时间几百万的用户请求，也就是高并发，但我必须要实现系统响应及时，而且高可用，假如你是架构师，你该如何架构这个系统，聊聊你的方案。</li>
<li>线程编程题： 写两个线程，一个往数组加数据，一个往数组减数据，要求数据不会越界。其实就是生产消费者</li>
<li>秒杀系统如何设计？</li>
<li>如果处理并发时候出现死锁？</li>
</ul>
<h1 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h1><h2 id="字节码相关"><a href="#字节码相关" class="headerlink" title="字节码相关"></a>字节码相关</h2><ul>
<li>知道字节码吗?字节码都有哪些?</li>
</ul>
<h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><ul>
<li>说说JVM的主要组成部分以及作用?</li>
<li>jvm内存模型，内存屏障</li>
<li>对象一定分配在堆栈对象不一定分配在堆上，JIT可以实现栈上分配</li>
<li>java线程模型和jvm线程模型区分</li>
<li>Java堆的内存结构？ 在什么地方会发生OOM？ 如何分析OOM发生的原因？ 让你自己实现OOM，你会怎么做？</li>
<li>什么东西分配在堆上和栈上？</li>
<li>一个对象从创建到销毁都是怎么在这些部分里存活和转移的？</li>
<li>JVM 运行时区域 常见的堆内存溢出情况</li>
<li>栈溢出的情形（递归，调节-Xss</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>什么是双亲委派模型？</li>
<li>类加载器的本质</li>
<li>类加载器为什么有三层结构</li>
<li>怎么自定义类加载器做容器隔离？</li>
<li>讲讲类加载机制呗?都有哪些类加载器,这些类加载器都加载哪些文件?</li>
<li>手写一下类加载Demo</li>
<li>Classloader作用</li>
<li>讲一讲类加载器工作机制？你知道强引用、弱引用和软引用吗?为什么要有这些东西？他们有什么作用？你在项目中用过吗？</li>
<li>说一下java类加载器的工作机制？类加载在那个区域进行的？</li>
<li>你自己定义的类能被最顶级的类加载器加载吗？为什么？ 自定义的类会被什么类加载器加载？ 如何加载一个不在根目录下的类？</li>
<li>什么是双亲委派模型？为什么Java的类加载器要使用双亲委派模型？ 15、如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？</li>
<li>什么是tomcat/jboss类加载机制？</li>
<li>类加载机制，一个类加载到虚拟机中一共有几个步骤，这些步骤的顺序哪些是固定的，哪些是不固定的，为什么不固定？</li>
<li>说一下双亲委派模型？如何破坏双亲委派模型？知道Tomcat中是如何违背双亲委派模型的吗？</li>
<li>Java为什么要设计双亲委派模型？ •什么时候需要自定义类加载器？</li>
</ul>
<h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><ul>
<li>简单阐述下垃圾回收机制</li>
<li>堆的原理和分代了解吗</li>
<li>GC方式有哪些？它们的原理是什么？</li>
<li>CMS和G1各自使用的算法以及优缺点</li>
<li>内存分配策略（如何在Eden和老年代中分配）、回收策略（Minor GC、Full GC）</li>
<li>谈谈你对上面GC中回收对象中提出的对象有什么理解？回收那些对象，需要怎么分辨？</li>
<li>你了解的垃圾收集算法有哪些？</li>
<li>你了解那些垃圾收集器？</li>
<li>线上发送频繁fullgc如何处理?</li>
<li>新生代，老年代说下？</li>
<li>一般新生代逃过几次gc()会被划分到老年代？</li>
<li>survivor区作用</li>
<li>jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等</li>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS</li>
<li>新生代垃圾收集是否会停顿 ,cms是否会停顿，在什么时候停顿</li>
<li>讲讲 GC，清除，整理，交换（survivor 区域），CMS 执行的过程</li>
<li>什么情况会导致内存泄露，内存溢出，你怎么解决的。</li>
<li>gc怎么回收对象的，用了什么算法 说一下分治算法思想</li>
<li>JVM垃圾回收机制，何时触发MinorGC等</li>
<li>新生代和老生代的内存回收策略 ,Eden和Survivor的比例分配等</li>
<li>Java 8的内存分代改进</li>
<li>GC的可达性分析中那些算是GC roots</li>
<li>简述java内存分配与回收策略以及Minor GC和Major GC?</li>
<li>内存溢出一般发生在哪个区？永久代会不会导致内存溢出？</li>
<li>栈溢出一般抛出什么异常？jvm设置栈的大小，参数？</li>
<li>说说GC的过程 强制young gc会有什么问题？ 知道G1么？ 回收过程是怎么样的？</li>
<li>CMS GC有什么问题？ 怎么避免产生浮动垃圾？</li>
<li>如果web服务器突然出现频率很高的FullGC，可能是什么原因?你会怎么去排查呢？</li>
<li>“只对堆进行gc ”这句话对不对？调用system.gc()马上就执行gc吗？</li>
<li>GC的机制是什么？垃圾回收器的基本原理是还说呢么？是否可以立即回收内存？怎么样主动的通知JVM进行垃圾回收？</li>
<li>频繁老年代回收怎么分析和解决？</li>
<li>什么时候一个对象会被GC？ 接着问为什么要在这种时候对象才会被GC？ GC策略都有哪些分类？这些策略分别都有什么优劣势？都适用于什么场景？ 举个实际的场景，让选择一个GC策略？然后问什么要选择这个策略？</li>
<li>内存的哪些部分会参与GC的回收？</li>
<li>线程池中的线程为什么不会被GC回收</li>
<li>JVM 简述 G1，可预测停顿时间，是怎么做到的？</li>
<li>CMS和G1的区别，讲一讲CMS垃圾收集的步骤，哪些步骤是并发哪些是并行。知道哪些垃圾收集算法</li>
<li>触发Full GC 的场景有哪些？ 说说G1垃圾回收器？老年代，年轻代如何分配？</li>
<li>垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数 内存区域：能说清jvm的内存划分 常见问题 CMS GC回收分为哪几个阶段？分别做了什么事情？ CMS有哪些重要参数？ Concurrent Model Failure和ParNew promotion failed什么情况下会发生？ CMS的优缺点？ 有做过哪些GC调优？ 为什么要划分成年轻代和老年代？ 年轻代为什么被划分成eden、survivor区域？ 年轻代为什么采用的是复制算法？ 老年代为什么采用的是标记清除、标记整理算法 什么情况下使用堆外内存？要注意些什么？ 堆外内存如何被回收？</li>
<li>g1收集器用的具体算法？ 遇到过什么线上问题？线程池用法不对，频繁full GC怎么处理的？回答内存dump，定位问题</li>
<li>GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势</li>
<li>标记清除和标记整理算法的理解以及优缺点。</li>
<li>eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。</li>
<li>JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。</li>
<li>强软弱虚引用的区别以及GC对他们执行怎样的操作</li>
<li>Java是否可以GC直接内存</li>
<li>JVM 内存分配策略 FullGC 的触发条件有哪些</li>
<li>虚拟机栈默认设置的大小</li>
<li>CMS有哪些重要参数？ Concurrent Model Failure和ParNew promotion failed什么情况下会发生？</li>
<li>一个对象从新生代到老年代的过程你可以说一下吗？ 那你知道它经过几轮回收到达老年代吗？也就是它的年龄。 新生代三个区域比例是多少</li>
</ul>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><ul>
<li>请问你做过哪些JVM优化?使用什么方法?达到什么效果?</li>
<li>当出现了内存溢出，你怎么排错?</li>
<li>用过哪些命令查看JVM的状态、堆栈信息？</li>
<li>jvm内存调优用过哪些工具，jstate做什么用的？如何dump出当前线程状态？</li>
<li>应用服务器的jvm调优实际经验，如何做的，在哪里用到的</li>
<li>对象比较大，生命周期短，GC参数怎么调优</li>
<li>平时遇到内存溢出的情形，处理 答：-Xms和-Xmx,-XX:+HeapDumpOnOutMemoryError，让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。</li>
<li>如果一个固定的堆内存，当创建线程数很多的时候，你JVM参数怎么配置。</li>
<li>gc,cpu过高如何定位问题；</li>
<li>频繁老年代回收怎么分析和解决？</li>
<li>top和jstack命令用过没，jstack命令的nid是什么意思，怎么查看java某个进程的线程</li>
</ul>
<h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><ul>
<li>mysql索引的数据结构，加索引的原则</li>
<li>InnoDB和myiasm的区别，以及常见的mysql优化方案</li>
<li>sql查询优化</li>
<li>说说Mysql的sql优化</li>
<li>mysql的索引，b+树索引是否支持范围查询，联合索引的失效情况</li>
<li>开发中用了那些数据库？回答mysql，储存引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。</li>
<li>数据库索引原理</li>
<li>mysql索引 B+树原理</li>
<li>mysql索引是怎么实现的？b+树有哪些特点？真实的数据存在哪里？ 哪些情况下建索引？解释下最左匹配原则？ 现在一个表有三列a b c，组合索引(a,b,c)查询的时候where a like ? and b=? and c=?能用到这个组合索引吗？为什么</li>
<li>explain执行计划看过没有？其中type字段都有哪些值？分别代表什么？ 26.你有哪些sql调优经验？</li>
<li>分库分表应该怎么分？怎么解决数据迁移的问题？</li>
<li>数据库索引，多级索引</li>
<li>数据库事务的隔离级别有哪些？Mysql默认的隔离级别？不同的隔离级别是通过什么实现的？mysql的explain有用过吗？讲一讲数据库的慢查询？数据库的悲观和乐观锁都说一下吧，什么时候用乐观锁比较合适？什么时候用悲观锁呢？</li>
<li>谈一下MySQL常见的两种存储引擎，适用场景——MyISAM和InnoDB的对比</li>
<li>谈谈你对数据库索引的理解</li>
<li>如何保证缓存和数据库双写的一致性</li>
<li>mysql数据库默认存储引擎，有什么优点 MySQL的事务隔离级别，分别解决什么问题。 说说事务特性（ACID）？</li>
<li>MySQL有哪些锁？ 解释一下ACID都是什么 Innodb中索引的实现 B+树</li>
<li>AUTO_INCREMENT原理（考察并发情况） 数据库的索引有哪几种？为什么要用B+树来做索引？组合索引和几个单个的索引有什么区别？数据库的大表查询优化了解吗？MVCC机制了解不？MVCC机制有什么问题？怎么去解决这个问题？mysql慢语句调优做过吗？说说你是怎么做的</li>
<li>说一下数据库优化思路？</li>
<li>你知道回表吗？</li>
<li>索引的实现原理？B树和B+树的区别？</li>
<li>说下索引结构，为什么使用B+树？</li>
<li>mysql的隔离级别，有什么区别？ 索引的几种类型？ 索引的存储结构？ 使用B+树的好处？ 索引值改变了，树的结构如何改变？</li>
<li>主键索引与二级索引的区别 主键索引存储什么数据 为什么主键用auto_increment 如何生成唯一主键 A:UUID UUID的缺点 mysql如何实现事务中持久性</li>
<li>Mysql 事务隔离级别、锁、索引的数据结构、聚簇索引和非聚簇索引、最左匹配原则、查询优化（explain等命令） 常见问题 Mysql(innondb 下同) 有哪几种事务隔离级别？ 不同事务隔离级别分别会加哪些锁？ mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？ 说说什么是最左匹配？ 如何优化慢查询？ mysql索引为什么用的是b+ tree而不是b tree、红黑树 分库分表如何选择分表键 分库分表的情况下，查询时一般是如何做排序的？</li>
<li>数据库调优思路的思路。</li>
<li>说说你都做过哪些优化或者优化的思路？ 数据库的索引了解吗？说一下索引的原理？聚集索引和非聚集索引了解吗？了解mysql的回表吗？ mysql实现分布式锁了解吗？还有没有其他更好的方式？ 说一下事务的一些东西？你对事务的了解有哪些？说说数据库的乐观锁和悲观锁？</li>
<li>数据库事务？数据库的并发策略？</li>
<li>介绍下mysql的回表和覆盖索引？ 回表简单来说就是数据库根据索引（非主键）找到了指定记录所在行后，还需要根据主键再次到数据库里获取数据。 如果一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’。即只需扫描索引而无须回表。</li>
<li>mysql索引了解吗，为什么用索引；有哪些索引；如果没有主键的话会怎么样；聚簇索引和非聚簇索引的区别；myisam和innodb哪个会保存表的总记录数，为什么；为什么用联合索引；bc会走abc联合索引吗； mysql锁有哪些，意向锁的原理； mysql隔离级别，分别解决了哪些问题，脏读、不可重复读、幻读是什么意思，可重复读是怎么实现的； mysql主从节点怎么保证数据的一致性；</li>
<li>聚簇索引和非局促索引的区别。 mysql的存储引擎。 innodb和myisam的区别 为什么myisam支持事务 ,innodb是如何支持的事务 ,为什么myisam不采用和innodb相同的方案来解决事务问题 ,为什么数据量大的时候会出现慢sql？ 慢sql如何解决。 如何sql优化。 分库分表如何做的？ 分库分表如何不同库表间数据不重复。</li>
<li>MySQL作为相对于雪花算法全局唯一性id的缺点除了性能问题，还有什么？</li>
<li>mysql两种存储引擎的区别 2.如果由大量的增删操作，那么应该选择哪个存储引擎，为什么？</li>
<li>hash和B+树的区别？分别应用于什么场景？哪个比较好？</li>
<li>为什么MyISAM查询性能好？ 说说事务特性（ACID）？ mysql数据库默认存储引擎，有什么优点 MySQL的事务隔离级别，分别解决什么问题。 SQL慢查询的常见优化步骤是什么？ 说下乐观锁，悲观锁（select for update），并写出sql实现？</li>
<li>MySQL的慢sql优化一般如何来做？除此外还有什么方法优化？</li>
<li>mysql的explain有用过吗？讲一讲数据库的慢查询？数据库的悲观和乐观锁都说一下吧，什么时候用乐观锁比较合适，什么时候用悲观锁比较合适？</li>
<li>数据库事务的隔离级别有哪些？Mysql默认的隔离级别？不同的隔离级别是通过什么实现的？</li>
<li>mysql,innodb引擎，b+树存储结构，索引，事务原理，分库分表，弹性库自动扩容原理</li>
<li>Sql调优经验</li>
<li>mysql为什么是b+树索引。b+高度一般多少，什么量级。</li>
<li>mysql幻读不可重复读区别</li>
<li>为什么InnoDB用的多？ 数据库锁知道吗，有几种，加锁和解锁的场景，给一句SQL和隔离级别，能分析加什么锁吗？索引下推原理</li>
<li>一条sql语句被提交后，mysql是怎么执行这条sql的？</li>
<li>两个数据库表复制数据库有什么方式？</li>
<li>mysql索引、从主原理</li>
<li>联合索引，若(a,b,c)是主键，根据b,c查询会不会用到索引，怎么知道？做索引需要有哪些条件？</li>
<li>平时建mysql表的时候会考虑一些什么？ 13、写sql语句的时候where会考虑什么？</li>
<li>数据库方面有mysql的innodb引擎锁的底层实现、以及回表、怎么避免索引覆盖</li>
<li>如何定位一个慢查询，一个服务有多条SQL你怎么快速定位？ 聚集索引和非聚集索引知道吗？什么情况用聚集索引什么情况用非聚集索引？ Nosql引擎用的什么存储结构，关系型数据库和NoSQL各自的优劣点是什么，如何技术选型？</li>
<li>mysql同步机制原理，有哪几种同步方法？ 数据库主从同步如何实现，事务如何实现？</li>
<li>还问了一个关于数据库优化流程的问题（索引，Mysql的查询缓存，Mysql分库分表方案） 伪共享问题的原理，mysql不同存储引擎的所使用的数据结构的不同</li>
<li>mysql联合索引，判断是否使用了索引 mysql索引结构 间隙锁 mysql处理死锁机制是怎么样的 mysql MVCC 线程池的参数理解</li>
<li>mysql主从复制主要有几种模式？</li>
<li>mysql行锁最大并发数？（秒杀项目指出）</li>
<li>2.数据库底层有了解吗 3.讲下聚簇索引 4.怎么解决慢查询 5.索引底层 6.b+树跟b树有啥区别 7.你说b+树能范围查询，怎么实现的 8.b+树的高度怎么计算 9.b树和b+树的叶子节点和非叶子节点都存什么 10.mysql最多能存多少数据 11.Mysql默认的事务隔离级别是什么，有什么缺点 12.什么是幻读 13.怎么解决幻读 14.Mysql的log有哪些，分别用来解决什么问题 15.怎么看mysql有没有执行索引 16.explain的时候最关心哪些字段，分别是什么含义</li>
<li>怎么定位死锁；</li>
<li>MySQL的查询机制</li>
<li>结构数据库和非结构数据库区别，你了解的非结构数据库有哪些？ 频繁的增删数据量某个表，数据库最终数据只有几万或者更少，为什么查询会变慢？ 数据如果出现了阻塞，你是怎么排查的</li>
<li>Mysql数据库默认的隔离机制。</li>
<li>mysql的索引，b+树索引是否支持范围查询，联合索引的失效情况</li>
<li>mysql 隔离级别有哪些，分别能解决哪些问题（脏读，幻读…）如何解决；</li>
<li>事务是什么，什么特征，事务如何实现原子性和一致性的 e. 索引是什么，接着就是红黑，B B+ 三连问（实现原理，区别，优缺点）； 那什么是聚集索引，讲讲原理，有什么优缺点。</li>
<li>说一下mysql索引 了解数据库锁吗 你怎么做sql优化的 了解MVCC吗 某个字段加了索引比不加索引快多少倍</li>
<li>mysql索引是怎么实现的？b+树有哪些特点？真实的数据存在哪里？ 哪些情况下建索引？解释下最左匹配原则？ 现在一个表有三列a b c，组合索引(a,b,c)查询的时候where a like ? and b=? and c=?能用到这个组合索引吗？为什么？</li>
<li>自增锁、共享锁、排他锁、意向锁、插入意向锁、记录锁、间隙锁是什么；</li>
<li>事务的四大特性、并发一致性导致的问题、四种隔离级别解决的问题以及如何实现的（加了什么锁）；</li>
<li>范式的概念</li>
</ul>
<h1 id="Dubbo和Spring-Cloud相关"><a href="#Dubbo和Spring-Cloud相关" class="headerlink" title="Dubbo和Spring Cloud相关"></a>Dubbo和Spring Cloud相关</h1><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><ul>
<li>你说你了解dubbo，能讲一下dubbo的基本原理吗？</li>
<li>dubbo支持的通信协议和序列化协议？ dubbo负载均衡和集群容错策略有哪些？dubbo的spi思想dubbo进行的服务治理、服务降级、失败以及重试。服务端怎么知道客户端要调用的算法的？</li>
<li>阐述下dubbo的架构</li>
<li>dubbo支持的注册中心有哪些，分别的优缺点</li>
<li>dubbo执行流程？</li>
<li>dubbo和springclond的架构区别和优劣？</li>
<li>说一下dubbo的实现过程?注册中心挂了可以继续通信吗?</li>
<li>dubbo复制均衡策略和高可用策略都有哪些啊?动态代理策略呢?</li>
<li>Dubbo服务调用的概述 consumer每次都要去拉注册中心provider的信息吗 consumer会缓存所有的provider元信息吗</li>
<li>为什么要进行系统拆分啊?拆分不用dubbo可以吗?dubbo和thrift什么区别啊?</li>
<li>Dubbo的服务请求失败怎么处理 •重连机制会不会造成错误</li>
<li>Dubbo相比webservice等方式的优势</li>
<li>Dubbo的RpcContext是怎么传递的？</li>
<li>dubbo默认使用什么传输协议</li>
<li>dubbo和ZK使用时给ZK提交些什么信息？用户是直接调用dubbo还是ZK？</li>
<li>Dubbo超时重试；Dubbo超时时间设置；</li>
<li>dubbo调用端怎么在jvm中生成对应服务？dubbo服务端和调用端超时时间设置和区别、dubbo长连接</li>
<li>dubbo服务治理是怎样的；</li>
<li>dubbo如何一条链接并发多个调用。Dubbo的原理，序列化相关问题</li>
<li>dubbo怎么知道服务器状态有什么内部机制？</li>
<li>使用dubbo进行远程调用时消费端需要几个线程。</li>
<li>dubbo支持的注册中心有哪些，分别的优缺点-</li>
<li>dubbo调用其他服务如何做到不检查；</li>
</ul>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><ul>
<li>spring cloud基本概念</li>
<li>SpringCloudy 容器化</li>
<li>讲讲springcloud个组件原理，zuul、Hystrix</li>
<li>讲一讲springcloud的eureka组件？</li>
<li>gateway和zuul做网关的区别？</li>
<li>Spring cloud相关： （1）Eureka服务注册发现，对比其他组件。 （2）Hystrix熔断与降级</li>
<li>网关选型 Zuul 和 Spring Cloud Gateway Eureka 服务发现的原理 服务发现选型应该要考虑的因素有哪些？</li>
<li>什么是Eureka的自我保护模式</li>
<li>服务发现是怎么实现的 熔断是怎么实现的</li>
</ul>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ul>
<li>分布式锁zookeeper的使用场景，实现分布式锁的方式，redis分布式锁和zookeeper分布式锁结合项目来说 以上两种方式的实现和异同</li>
<li>描述下ZooKeeper的选举机制</li>
<li>ZooKeeper的监听原理是什么？</li>
<li>ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群中最少需要几台？</li>
<li>ZooKeeper常用命令</li>
<li>zookeeper的核心是什么?</li>
<li>zk原理知道吗?zk都可以干什么?Paxos算法知道吗?说一下原理和实现?</li>
<li>在你的项目中spring是如何管理zookeeper的？</li>
<li>看了zookeeper源码，你的收获是什么？</li>
<li>zookeeper宕机与dubbo直连的情况？</li>
<li>zookeeper是保存数据的流程</li>
</ul>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul>
<li>nginx限流模块；</li>
<li>nginx有哪些模块？你比较熟悉哪个？</li>
<li>nginx负载均衡策略有哪几种？</li>
<li>谈下你对nginx和uwsgi的理解、为什么要用wsgi？</li>
<li>nginx负载均衡有哪些，如果其中一台服务器挂掉,报警机制如何实现</li>
</ul>
<h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><ul>
<li>微服务设计问题，rpc实现方式简单介绍；</li>
<li>dubbo、RPC介绍原理 限流算法 zk挂了怎么办 分布式锁的实现方式，zk实现和Redis实现的比较 秒杀场景设计，应付突然的爆发流量 分布式数据一致性 一致性哈希</li>
<li>分布式服务接口的幂等性如何设计</li>
<li>你们项目中分布式的session如何实现?实际就是分布式系统中的session共享 关于分布式事务、以及分布式事务问题</li>
<li>聊一聊SOA和微服务。soa和微服务的区别</li>
<li>项目中怎样使用微服务？ 两个服务之间调用的流程 rpc与http的区别 设计rpc协议需要注意什么</li>
<li>作为调用方和被调用放如何对避免服务雪崩？ rpc接口的超时时间时如何设置得？服务容灾是如何做的,你们工作中采用的微服务是如何部署的？</li>
<li>实现RPC框架需要注意什么？</li>
<li>什么是节流与防抖，如何实现</li>
<li>服务容灾是如何做的？</li>
<li>作为调用方和被调用放如何对避免服务雪崩? rpc接口的超时时间时如何设置得？</li>
<li>负载均衡有哪些算法？</li>
<li>分布式一致性协议raft，paxos 了解吗？Zookeeper中的ZAB协议，选主算法；</li>
<li>实现负载均衡和顺序轮询机制；（考虑并发）</li>
<li>RPC服务的概念，RPC服务一般都怎么做序列化？怎么处理传输层的字节流？</li>
<li>分布式锁的实现原理和有多少种实现方式？</li>
<li>远程服务框架:dubbo的通信过程，服务发现过程，序列化反序列过程原理理解；分布式协调算法：zk的paxos协议原理,zab原理，metaq的raft协议原理；</li>
<li>服务器雪崩是怎么造成的？之前有这样的经历吗？怎么防备？</li>
<li>如何实现何高并发下的削峰，限流？</li>
<li>client调用A服务，A服务依赖于B服务，在不知道B是否高可用的情况下，怎么保证A的高可用？</li>
<li>分布式任务调度怎么做？</li>
</ul>
<h2 id="dubbo扩展"><a href="#dubbo扩展" class="headerlink" title="dubbo扩展"></a>dubbo扩展</h2><p>以下有关dubbo的面试题来自知识星期【芋道源码】</p>
<ul>
<li>说说 Dubbo 的整体架构？有哪些角色，怎么交互的？ps：先不用回答到内部的调用链路。</li>
<li>请说说 Dubbo 一次完整调用的过程？越详细越好，最好画个图</li>
<li>Dubbo 需要考虑优雅上线么？是和否的原因是什么？</li>
<li>Dubbo 有哪些负载均衡策略？默认是哪一种。</li>
<li>43.Duboo 集群容错策略有哪些？如何选择？</li>
<li>Dubbo 的 SPI 机制是什么？为什么需要 SPI 机制？</li>
<li>可以使用 Spring 作为 Dubbo 的 SPI 机制么？可以使用 Java SPI 作为 Dubbo 的 SPI 机制么？ps：这个是换一个思路，看看候选人在 Dubbo SPI 的理解。</li>
<li>Dubbo Filter 机制是否了解？</li>
<li>你有实现过 Dubbo 自定义 Filter 么？</li>
<li>日常开发 Dubbo 服务时，怎么开发调试？</li>
<li>阅读 Dubbo 的标签路由功能，思考有没更好的 Dubbo 调试便利性。</li>
<li>Dubbo 有哪些序列化组件？你们目前使用哪个？原因是？</li>
<li>如何实现一个 Dubbo 本地调试的封装？</li>
<li>在 Dubbo 中，可以使用那些中间件实现链路追踪？知道实现原理么？</li>
<li>什么是 Dubbo 隐式传参？有什么用途？</li>
<li>如果使用 Redis 作为 Dubbo 的注册中心，需要考虑哪些东东？</li>
</ul>
<h1 id="MQ和分布式事务"><a href="#MQ和分布式事务" class="headerlink" title="MQ和分布式事务"></a>MQ和分布式事务</h1><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><ul>
<li>项目中RabbitMQ实现了at least once,包括mq反馈provider,消息持久化,consumer主动反馈mq.线程池消费防止消息积压等</li>
<li>mq 通知时，消费者没消费到怎么办</li>
<li>简单聊聊消息中间件？</li>
<li>你了解那些具体的消息中间件产品？</li>
<li>mq的消费端是怎么处理的？ 整理一下你的消费端的整个处理逻辑流程，然后说说你的ack是在哪里返回的。按照你这样画的话，如果数据库突然宕机，你的消息该怎么确认已经接收？ 那如果发送端的服务是多台部署呢？你保存消息的时候数据库就一直报唯一性的错误？</li>
<li>rocketmq用在什么场景。 如果消费者组A下面有两个消费者组A1,A2,问消费者A1和A2能否消费不同的topic ?rocketmq如何保证的事务。</li>
<li>kafka,activemq,rabbitmq,rocketmq都有什么优点,缺点啊?</li>
<li>如果让你写一个消息队列，该如何进行架构设计啊?说-下你的思路</li>
<li>用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗 ?MQ系统的数据如何保证不丢失</li>
<li>mq 通知时，消费者没消费到怎么办</li>
<li>mq的p2p模式</li>
<li>mq消息的幂等性如何保证？ mq如何保证顺序消费？</li>
<li>MQ怎样保证消息的可靠性以及当时如何做消息幂等处理的</li>
<li>如何确保消息正确地发送至RabbitMQ？ 如何确保消息接收方消费了消息？ 如何避免消息重复投递或重复消费？ 消息基于什么传输？ 消息如何分发？ 消息怎么路由？ 如何确保消息不丢失？ 使用RabbitMQ有什么好处？ rabbitmq的集群。 mq的缺点</li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>首先来一个具体的解决方案的示例</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">*  1、两阶段提交（2PC） 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交. 第二阶段：事务协调器要求每个数据库提交数据。 优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致） 缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。 
* 2、补偿事务（TCC） 针对每个操作，都要注册一个与其对应的确认和补偿（撤销）。Try、Confirm、Cancel 优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些 缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。 
* 3、本地消息表（异步确保） 核心思想是将分布式事务拆分成本地事务进行处理，消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。 优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。 缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。 
* 4、MQ事务消息 RocketMQ支持，RabbitMQ 和 Kafka 都不支持，一次发送消息和一次确认消息，生产方需要实现一个check接口（确认消息或者回滚） 优点： 实现了最终一致性，不需要依赖本地数据库事务。 缺点： 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。 
* 5、Sagas事务模型 长时间运行的事务，该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<ul>
<li>分布式事务了解吗？有哪些处理方法？</li>
<li>项目中有分布式事务处理吗？有哪些常见的分布式事务处理方式？说一下你们在项目中怎么用的。</li>
<li>分布式情况下如何保证事务。 如何设计实现一个分布式事务</li>
<li>分布式事务的各种方案及你的最佳方案</li>
<li>分布式事务是什么</li>
<li>什么是分布式事务？分布式事务如何保证数据一致性？</li>
<li>分布式事务知道吗?你们怎么解决的?TCC?那若出现网络原因,网络连不通怎么办啊</li>
<li>对分布式事务的理解</li>
<li>分布式事务的原理，如何使用分布式事务</li>
<li>多个服务之间调用的数据一致性问题，A服务中调用B服务 、C服务，B成功 C失败怎么解决？ 其实归根到底就是分布式事务的数据一致性解决方案，失败了数据怎么回滚</li>
<li>分布式事务的实现方式，分布式锁，分布式一致性，redis分布式锁；</li>
<li>分布式事务了解吗？你们项目中都用到了哪些分布式事务？都有哪些优缺点？</li>
<li>简单实现分布式事务</li>
</ul>
<h1 id="NIO和Netty面试题"><a href="#NIO和Netty面试题" class="headerlink" title="NIO和Netty面试题"></a>NIO和Netty面试题</h1><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><ul>
<li>阐述 NIO原理？</li>
<li>BIO/NIO/AIO有什么区别？有那些实现？</li>
<li>讲讲NIO的原理与实现？NIO用到了哪个经典技术思想？JDK1.8中NIO有做什么优化</li>
<li>了解多路复用机制 常见问题 同步阻塞、同步非阻塞、异步的区别？</li>
<li>select、poll、eopll的区别？</li>
<li>Linux网络IO模型</li>
<li>哪些库或者框架用到NIO？</li>
<li>redis的事件驱动多路复用底层实现；引申到NIO编程</li>
<li>NIO解决了什么问题</li>
<li>有了解过mina？</li>
<li>NIO的核心是什么？（IO线程池） ，问IO包的设计模式（装饰器模式），为什么要这样设计？有没有更好的设计？</li>
<li>NIO模型，特别是其中的selector的职责和实现原理</li>
<li>select、poll 和 epoll 的区别</li>
<li>NIO过程介绍，NIO怎么做到多路复用的</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><ul>
<li>Netty 分布式任务调度怎么做？</li>
<li>Netty 的优势在哪？有什么问题吗？</li>
<li>NIO，Netty，网络协议，涉及到的OS交互</li>
<li>Netty nio问题，问了流程</li>
<li>Netty的 API gate 设计</li>
<li>Netty线程模型（源码拷问）</li>
<li>Netty的几种线程模型和架构</li>
</ul>
<h1 id="ORM框架-Mybatis-Hibernate和JPA"><a href="#ORM框架-Mybatis-Hibernate和JPA" class="headerlink" title="ORM框架 Mybatis,Hibernate和JPA"></a>ORM框架 Mybatis,Hibernate和JPA</h1><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li>Mybatis怎么实现Dao的一系列操作?原理简单介绍</li>
<li>ORM框架如何配置主从数据源，Mybatis原理</li>
<li>如果让你实现Mybatis，你会怎么设计？ Mybatis常用的标签有哪些？ sql注入怎么预防？ sql一般怎么优化？ 数据量多大的情况下考虑分表呢？ sql语句是怎么样执行的？（不知道，不过我猜应该会先校验sql语句的正确性，然后再放入执行引擎中取执行）。</li>
<li>MyBatis中#{}和${}的区别？</li>
<li>Mybatis的缓存？一级、二级缓存？</li>
<li>MyBatis框架的理解？</li>
<li>对于XML映射文件和Mapper接口对应，这Mapper接口的原理是什么？</li>
<li>Mybatis如何进行分页？</li>
<li>MyBatis是如何将sql执行结果封装为目标对象并返回的？</li>
<li>Mybatis的延迟加载以及实现原理？</li>
<li>介绍下Mybatis/Hibernate的缓存机制。</li>
<li>Mybatis的mapper文件中resultType和resultMap的区别。 Hibernate和Mybatis的区别。</li>
<li>Mybatis中DAO层接口没有写实现类，Mapper中的方法和DAO接口方法是怎么绑定到一起的，其内部是怎么实现的。</li>
<li>Mybatis如何找到指定的Mapper的，如何完成查询的。</li>
<li>Mybatis工作流程。 Mybatis与Hibernate区别。 Mybatis框架传递参数方式</li>
<li>Mybatis 二级缓存原理</li>
</ul>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><ul>
<li>Hibernate的缓存级别。 hibernate是什么，工作原理。 hibernate如何实现延迟加载。 hibernate如何怎样类之间的关系</li>
<li>Hibernate的数据有哪几种状态？状态是如何进行切换的？简单描述下Hibernate的缓存机制？二级缓存是怎么实现的？</li>
<li>Hibernate如何优化的？</li>
<li>Hibernate中多对多的关系处理；Hibernate的继承是否了解</li>
<li>Hibernate对一二级缓存的使用，Lazy-Load的理解；</li>
<li>对Hibernate缓存机制理解及看法；</li>
</ul>
<h1 id="Redis-和MongoDB及应用"><a href="#Redis-和MongoDB及应用" class="headerlink" title="Redis 和MongoDB及应用"></a>Redis 和MongoDB及应用</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li>redis优化策略</li>
<li>redis除了做缓存还能做什么？</li>
<li>说说redis持久化方式？分别优缺点是什么？redis更新策略是什么？</li>
<li>redis的数据结构存储？以及应用场景？如何实现集群和高可用？</li>
<li>业务中redis如何保证可用性 怎么实现分布式锁（redis）</li>
<li>分布式锁的实现方式，zk实现和Redis实现的比较</li>
<li>redis支持的数据类型到跳跃表，redis同步策略 ,如何自己实现lru</li>
<li>什么是缓存击穿，redis的hotkey如何处理？如何保证数据库与缓存双写的一致性。</li>
<li>redis缓存过期策略，准备同步，哨兵机制和集群的区别</li>
<li>遇到的问题就是“缓存穿透”和“缓存击穿”，“缓存雪崩”，双写不一致等。 如何解决上述遇到的问题？</li>
<li>redis有哪几种数据类型，如何持久化，怎么更新，使用场景，主从复制怎么做？影响redis的瓶颈？</li>
<li>NoSQL数据库，以及MongDB和Redis使用场景？</li>
<li>缓存一致性问题 数据先写 redis？还是先写 MySQL？ 写入失败怎么办？ redis 或者 MySQL 挂掉怎么办？</li>
<li>redis的高可用，redis的集群方案，一致性哈希和哈希槽模式下缓存服务器宕机，数据如何迁移</li>
<li>你知道redis为什么读写速度那么快么？ redis数据装在内存中，那么数据可以持久化吗？ redis数据持久化的方式有哪些呢？ 这两种持久化方式的区别在哪里呢？ 你知道redis的内存淘汰机制吗？redis的cluster集群原理能简单说一下吗？</li>
<li>如何解决 Redis 的并发竞争 Key 问题</li>
<li>zset底层怎么实现的?</li>
<li>关于Redis的主从复制？</li>
<li>Redis 怎么保证不丢数据，能不能保证严格意义的一定不会丢 Redis 集群，生产环境Redis 如何做数据迁移</li>
<li>如何理解redis的高性能和高并发</li>
<li>Redis基本数据结构 跳表实现原理 过期处理，Redis单线程优势，影响吞吐因素，支持事务吗 Redis会遇到哪些问题 缓存一致性 穿透 雪崩，解决方案.</li>
<li>BloomFilter 知道吗？说下原理，怎么提高准确性</li>
<li>单线程的redis如何利用多核cpu机器？</li>
<li>有海量key和value都比较小的数据，在redis中如何存储才更省内存？</li>
<li>redis分布式锁如何保证原子性？</li>
<li>redis主备切换过程是怎样的？</li>
<li>redis的过期策略，定期删除何时终止</li>
<li>Redis如何解决key冲突？</li>
<li>如果redis作为分布式锁的时候,主节点挂掉了,但是数据还没有同步到从节点,这种情况怎么办?</li>
<li>redis的key是如何寻址的啊?</li>
<li>分布式缓存redis原理</li>
<li>redis分布式锁三种实现方式</li>
<li>redis和memcached 的内存管理的区别等等</li>
<li>redis的session共享的具体实现</li>
<li>讲讲redis里面的哈希表？</li>
<li>redis 集群主从复制原理。</li>
<li>Guava缓存除了做缓存还能做什么？和Redis的优缺点。</li>
<li>redis分片取模算法。</li>
<li>redis，memcache底层客户端使用一致性Hash，看是否了解；redis的事件驱动多路复用底层实现</li>
<li>redis的事务机制；</li>
<li>Redis 有序集合实现方式有哪些； zset与set区别？ list和set又有什么区别？</li>
<li>set 和setNx有什么区别</li>
<li>redis数据结构、跳跃表,redis qps能上多少，怎么知道的 ,sentinel和cluster区别和各自适用场景,redis cluster集群同步过程</li>
<li>讲下布隆过滤器的实现机制</li>
<li>redis处理大量重复数据</li>
<li>生产环境Redis 如何做数据迁移</li>
<li>Redis官方为什么不提供Windows版本？</li>
<li>redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）</li>
<li>Redis主要消耗什么物理资源？</li>
<li>分布式锁的方案，redis和zookeeper那个好，如果是集群部署，高并发情况下哪个性能更好？</li>
<li>高并发量大的话怎么处理热点，数据等。</li>
</ul>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul>
<li>MongoDB和MySQL的区别，各自使用场景</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p>项目里用redis存哪些数据？为什么用redis？和jetty本地缓存有什么区别？</p>
</li>
<li><p>发散性问题：假如有100万个玩家，需要对这100W个玩家的积分中前100名的积分，按照顺序显示在网站中，要求是实时更新的。积分可能由做的任务和获得的金钱决定。问如何对着100万个玩家前100名的积分进行实时更新？</p>
<blockquote>
<p>思路就是考虑出了前100名的后100W-100名玩家的积分，让变化的积分跟第100名比较，如果比第100名高，那就替换的原则。就是利用缓存机制，缓存—tomcat—DB，层级计算，能不用到DB层就别用，因为每进一层，实现起来都会更复杂和更慢。</p>
</blockquote>
</li>
<li><p>谈谈你对缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级的理解？</p>
</li>
<li><p>解决缓存击穿的方式有哪几种?加锁的时候什么时候选择本地锁,什么时候选择分布式锁?</p>
</li>
<li><p>数据库有1万条数据，怎么很快的加载到redis？</p>
</li>
<li><p>问nosql如何设计？</p>
</li>
<li><p>做个微信商城，其中有各种活动，限时优惠，和秒杀，问我并发的时候怎么做处理的。</p>
<blockquote>
<p>（用redis计数器做，当秒杀的商品库存减低时，直接响应请求）</p>
</blockquote>
</li>
<li><p>设计一个防止缓存穿透的解决方案，</p>
</li>
<li><p>分布式缓存实现原理，秒杀业务怎样防止超卖；</p>
</li>
<li><p>实际场景问题解决:典型的TOP K问题</p>
</li>
</ul>
<h1 id="Spring相关"><a href="#Spring相关" class="headerlink" title="Spring相关"></a>Spring相关</h1><ul>
<li>spring工作原理简单介绍</li>
<li>循环依赖问题</li>
<li>spring/spring boot启动加载过程 ？springboot是怎么运行起来的 使用springboot的好处是什么？</li>
<li>描述下spring的ioc和aop</li>
<li>spring task是怎么实现的？</li>
<li>spring事务你是怎么用的？加了@Transcational注解spring都做了哪些工作？怎么知道事务执行成功了</li>
<li>你常用哪一种注入方式？BeanFactory和ApplicationContext有什么区别？你们项目里用的哪个？说一下spring bean的生命周期</li>
<li>AOP实现原理是什么？两种动态**<em>实现原理？JDK动态**</em>为什么要实现接口？</li>
<li>spring默认事务传播属性是什么？嵌套事务子事务什么时候commit？</li>
<li>spring和springMVC是什么关系？有没有用过JdbcTemplate？ 16.springMVC中对整个请求的处理流程是怎样的？返回json的话是用哪个view？</li>
<li>ioc原理、aop原理和应用</li>
<li>springmvc底层实现大致逻辑?spring mvc有哪些常用的注解？</li>
<li>spring中Bean的作用域，几种scope区别，springMVC的controller是线程安全的吗？怎么去保证线程安全呢？</li>
<li>对spring的理解,仔细讲解一下spring的两大特性。说一下AOP中的切面切点。 用过哪些注解，注解的生命周期</li>
<li>你知道Spring的Scope吗？ 既然是单例的，怎么能保证变量可能会随不同的人访问出现值的改变？</li>
<li>SpringBoot 的自动配置是怎么做的？</li>
<li>spring容器的启动过程？</li>
<li>spring IOC 过程 如何自己设计IOC框架</li>
<li>spring生命周期，几种scope区别，aop实现有哪几种实现</li>
<li>SpringBoot核心配置文件有哪些，区别是什么？Springboot的核心注解组成？springboot的监视器的理解？</li>
<li>属性注入和构造器注入哪种会有循环依赖的问题？</li>
<li>spring事务传播 常见问题,spring事务传播机制的实现原理。</li>
<li>手写个jdk动态代理</li>
<li>spring事务的原理</li>
<li>springmvc的几个核心类及请求过程</li>
<li>@Autowired的作用</li>
<li>Spring的单例Bean是线程安全的吗？</li>
<li>谈一下SPRING的源码，IOC，AOP的源码</li>
<li>配置spring mvc拦截器的步骤</li>
<li>依赖注入属于什么模式？</li>
<li>spring异常处理</li>
<li>spring对bean的管理流程</li>
<li>然后问一个切点可以配置多个切面吗？</li>
<li>问spring用了哪些设计模式；用了哪些分布式缓存？</li>
<li>Spring 都有哪几种注入方式，什么情况下用哪种</li>
<li>执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring？（传播性）</li>
<li>sping如何实现（保证）事务一致性完整性，spring中事务传播机制类型；</li>
<li>spring的http请求的流程</li>
<li>spring底层数据结构？</li>
<li>spring aop的底层实验原理。 aop与cglib，与asm的关系。 spriong ioc的生命周期，init-method，intilizingbean接口方法afterPropertiesSet的先后顺序；</li>
<li>@transactional注解在什么情况下会失效，为什么。</li>
<li>.Spring如何维护它拥有的bean</li>
<li>问了class A和B相互依赖的情况下，spring如何对这两个bean进行加载</li>
<li>spring的bean加载机制和加载过程是怎样的；bean是什么时候消亡；</li>
<li>对spring的Bean加载了解吗？如果是你自己写一个这样的框架，你会如何写？</li>
<li>问 spring的controller中要跳转到一个新页面，并且把数据也传过去，应该返回一个什么对象？</li>
<li>Spring里面怎样实现在容器加载时就执行相关方法；</li>
<li>覆盖spring IOC容器中一个bean</li>
<li>spring的事务管理是如何实现的，编程式如何实现</li>
<li>IOC的主要作用</li>
<li>DI怎么用伪代码来实现。</li>
<li>什么是自动配置？ 什么是 Spring Boot Stater ？ 你能否举一个例子来解释更多 Staters 的内容？ Spring Boot 还提供了其它的哪些 Starter Project Options？ Spring 是如何快速创建产品就绪应用程序的？ 创建一个 Spring Boot Project 的最简单的方法是什么？ 为什么Spring Initializr 是创建 Spring Boot Projects 的唯一？为什么我们需要 spring-boot-maven-plugin？ 如何使用 SpringBoot 自动重装我的应用程序？ 什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？ 如何在 Spring Boot 中添加通用的 JS 代码？</li>
</ul>
<h1 id="docker和linux"><a href="#docker和linux" class="headerlink" title="docker和linux"></a>docker和linux</h1><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>docker的原理？dockerfile里面用过什么命令？</li>
<li>用过docker？dockerfile写过吗，常用命令，说下分层原理</li>
<li>docker 部署有什么好处？</li>
<li>docker 的底层原理是什么？namespace 和 cgroups，一个隔离环境，一个控制资源配额。那隔离环境主要隔离什么环境？</li>
<li>docker镜像和容器有什么区别？为什么要用docker？docker daemon是啥？发现docker daemon响应突然变慢了，如何排查？</li>
<li>docker的image、layer、container分别讲下？</li>
<li>是否用过docker和springCloud这样的搭建微服务？</li>
<li>docker的namespace和cgroup、cmd和entrypoint的区别</li>
<li>问我在docker里面如果查看linux发布版本，看到的是容器的还是宿主机的； 还有docker启动时如果要限制使用的cpu和内存，要加什么参数；</li>
<li>docker和虚拟机区别 docker安全性.和虚拟机比较？</li>
</ul>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li>Linux namespace讲一下？Linux cgroup的层级结构讲一下？</li>
<li>Linux中namespace是怎么实现的，底层的数据结构是什么？</li>
<li>linux中你用哪些命令 ,linux中想看一个文件中某个关键字出现的次数（我不会，后面还会问到。。）</li>
<li>linux下如何查看网络端口状态（netstat），如何查看内存使用情况（top）</li>
<li>linux常用操作命令</li>
<li>linux下查看系统时间的指令是什么？</li>
<li>查看linux内核版本该用哪些命令；</li>
</ul>
<h1 id="分布式和中间件等"><a href="#分布式和中间件等" class="headerlink" title="分布式和中间件等"></a>分布式和中间件等</h1><ul>
<li>raft协议 paxos算法</li>
<li>ddos 如何避免？怎么预防？怎么发现？利用了TCP什么特点？怎么改进TCP可以预防？服务端处理不了的请求怎么办？连接数最大值需要设置吗？怎么设置？ Thrift RPC过程是什么样子的？异构系统怎么完成通信？跟http相比什么优缺点？了解grpc吗？</li>
<li>kafka topic partition介绍下 一个 partition对应多少 生产者（不限），对应多少消费者（一对一） zk你们怎么用的</li>
<li>Redis与Mysql双写一致性方案</li>
<li>微服务架构是什么？它的优缺点？ ACID CAP BASE理论 ,分布式一致性协议，二段、三段、TCC，优缺点 ,RPC过程 ,服务注册中心宕机了怎么办？ 微服务还有其他什么组件 ,分布式架构与微服务的关系</li>
<li>从hystrix一路问到原理-&gt;自己如何实现-&gt;如何优化-&gt;响应流编程(reactive streams);</li>
<li>如何识别tcp和udp报文</li>
<li>如果生产者生产的数据量很多，消费者来不及消费这些数据怎么办？</li>
<li>Kafka消息是采用Pull模式，还是Push模式？</li>
<li>Kafka分区，如何分区等等</li>
<li>RPC的过程？ 如何做到透明化远程服务调用？ 动态代理，把本地调用代理成网络调用 .如何进行服务发布？（Zookeeper） 如何进行序列化与反序列化？（Protobuf、Thrift、Avro） 如何进行通信？（NIO—&gt;Netty）</li>
<li>Zookeeper锁是如何实现的？</li>
<li>分布式缓存读写不一致问题</li>
<li>Kafka是如何实现高吞吐率的？</li>
<li>配置中心项目, 问实时配置推送怎么做</li>
<li>讨论为什么选择所有的组件依赖放在配置中心中控制 ,我现在要做一个限流功能, 怎么做？这个限流要做成分布式的, 怎么做？ 怎么抢锁？锁怎么释放？ 加了超时之后有没有可能在没有释放的情况下, 被人抢走锁？怎么解决？ 不用 zk 的心跳, 可以怎么解决这个问题呢？假如这个限流希望做成可配置的, 需要有一个后台管理系统随意对某个 api 配置全局流量, 怎么做？</li>
<li>某一个业务中现在需要生成全局唯一的递增 ID, 并发量非常大, 怎么做</li>
<li>Kafka 的消费者如何做消息去重？</li>
<li>介绍一下 Kafka 的 ConsumerGroup</li>
<li>瞬时写入量很大可能会打挂存储, 怎么保护？（断路器） 断路器内部怎么实现的？（可以用 ringbuffer） 断路器会造成写入失败, 假如我们不允许写入失败呢？</li>
<li>MMM的DB架构，主从未完全同步，master挂了，未同步的内容会造成什么影响，怎么恢复</li>
<li>分布式锁使用和原理？</li>
<li>kafka为什么性能高？</li>
<li>mq怎么保证消息可靠性？</li>
<li>dubbo的设计和完整调用过程（要详细）</li>
<li>kafka生产端怎么实现幂等的 kafka如何实现分布式消息 kafka的副本同步机制的理解 kafka怎么进行消息写入的ack</li>
<li>分布式系统怎么做服务治理</li>
<li>Dubbo的服务请求失败怎么处理 ,重连机制会不会造成错误</li>
<li>如何实现负载均衡，有哪些算法可以实现？</li>
<li>Zookeeper的用途，选举的原理是什么</li>
<li>Nginx相关 1.nginx有哪些模块？你比较熟悉哪个？ 2.proxy_cache你是怎么配置的？缓存是存在哪里？具体是怎么命中缓存的？</li>
<li>spring cloud 组件和实现</li>
<li>消息可靠性保证；（数据幂等、高可用镜像集群、Confirm机制、事务机制、持久性）</li>
<li>任务拆分执行框架与管理基本手段，高可用实现（基于自己熟悉业务说）</li>
<li>zookeeper是保存数据的流程（选举算法要知道）</li>
<li>消息可靠性保证；（数据幂等、高可用镜像集群、Confirm机制、事务机制、持久性）</li>
<li>消息队列 1、项目中为什么使用消息队列，消息队列可以用来干什么； 2、如何解决消息重复消费、消息丢失、消息积压、顺序消费等问题； 3、如何保证消息队列得高可用性；</li>
<li>Eureka怎么实现高可用； 什么是Eureka的自我保护模式 ；Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别；</li>
<li>Dubbo 1、服务注册与发现； 2、SPI； 3、服务暴露过程； 4、服务引用； 5、降级； 6、负载均衡；</li>
<li>如何解决 Redis 的并发竞争 Key 问题。</li>
<li>zookeeper宕机与dubbo直连的情况？</li>
<li>消息基于什么传输？ 消息如何分发？ 消息怎么路由？ 如何确保消息不丢失？</li>
<li>RabbitMQ 中的 broker 是指什么？cluster 又是指什么？ RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？</li>
<li>解释下分布式系统中的cap理论，怎么保证ca？</li>
<li>Eureka 服务发现的主要功能 Eureka 服务有多少个实例 Eureka 服务同步每次都是全量吗 Eureka 服务发现的数据一致性 Eureka 如何保证数据可靠性，如何确认是一致的 Eureka 如果实例数太多，会面临同步的问题吗 Zuul 限流是如何实现的 限流是这一层起作用还是下一层起作用 为什么要在你这一层去做呢？那如何保护自身呢？ 限流的实现方式，有哪几种算法 时间窗口与令牌桶的对比 配置管理是如何实现的 应用配置的场景 为什么选择 zk 做配置管理 为什么不用 zk 做服务注册 怎么防止雪崩、服务过载这些 网络平时有遇到什么问题吗？ 服务间调用丢包、传输速度慢，怎么去解决？ 如何查看连接是否丢包 大量的连接导致短暂的瘫痪状态，怎么去解决？</li>
<li>Eureka 损失了一致性会带来什么问题呢？ Eureka 有主吗？怎么实现的同步？如果遇到了不一致的问题，谁说了算？ 如果多个节点同时尝试注册会有问题吗？ Eureka 内部采用的一致性算法是什么算法？</li>
<li>介绍 Paxos 原理？缺点是什么？ 本机宕机了怎么办？消息表会丢失的？ 数据存在哪里？消息表存在磁盘或者内存还是远程的数据库？ 本地消息表的缺点和优点是什么？</li>
<li>XA 事务和 TCC 的区别 如何解决 XA/TCC 的单点问题（数据分片） 什么是TCC，它的工作过程？ TCC 和 XA 的区别？ 如果让你优化XA，你会如何优化？</li>
<li>skywalking 的监控原理</li>
<li>redis分布式锁实现的话，setnx和expire命令，如果A线程将expire操作操作到了B线程了，也就是expire了另一个线程的资源，这种怎么避免？</li>
<li>规定给出的并发量外，如果有额外的流量访问进来了，如何做熔断处理？</li>
<li>搜索时延这么高，该如何进行优化？如何提高响应速度？如何优化以提升用户体验度？</li>
<li>分布式锁的方案，redis和zookeeper那个好，如果是集群部署，高并发情况下哪个性能更好？</li>
<li>如何实现何高并发下的削峰，限流？</li>
<li>redis集群，怎么集群，怎么负载，怎么设置？</li>
<li>nginx怎么保证各web容器之间不会串？</li>
<li>redis的高可用如何保证？</li>
<li>spring是如何管理zookeeper的？</li>
<li>了解zookeeper的leader选取算法吗，讲一下它的流程。</li>
<li>分库和分表怎么选择？结合项目场景讨论划分规则</li>
<li>kafka的产生背景和在项目中的使用 topic和partition，partition是干什么的 Consumer Group是干什么的 怎么将partition分配到多个broker上？怎么动态调整partition和broker的数量？ rebalance什么时候发生，rebalance过程</li>
<li>分布式协调算法：zk的paxos协议原理,zab原理，metaq的raft协议原理；</li>
<li>分布式限流如何实现，原理是什么？</li>
<li>分库分表的实现原理是什么，你所在业务一般是怎么分库分表的？对应逻辑是什么？</li>
<li>Nginx轮询的实现原理；</li>
<li>分布式缓存读写不一致问题；</li>
<li>谈谈完全高可用的分布式支付框架的设计构想；</li>
<li>dubbo调用其他服务如何做到不检查；</li>
<li>在分布式服务器群中，有两台服务器对共享数据库的同一条数据进行并发修改，如果解决同步问题；</li>
<li>分布式缓存需要具备的特点是什么？</li>
<li>各种消息中间件的底层实现有何不同；</li>
<li>mysql同步机制原理，有哪几种同步方法？ 数据库主从同步如何实现，事务如何实现？</li>
<li>谈谈你对SOA和微服务的理解，以及分布式架构从应用层面涉及到的调整和挑战。</li>
</ul>
<h1 id="场景和设计"><a href="#场景和设计" class="headerlink" title="场景和设计"></a>场景和设计</h1><ul>
<li>为什么要这样分表？跨库join如何解决？数据量突增怎么解决？ 如何解决线上问题？cpu狂飙怎么办？频繁minor gc怎么办？可能造成的原因是什么？如何避免？ 数据库 隔离级别，怎么实现的？当前读，快照读？MVCC？</li>
<li>分库分表的设计？ 分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入</li>
<li>如何优雅的写代码？什么代码算做优雅？什么代码是规范？你们代码规范是什么样的？ 如何进行code review？</li>
<li>mysql innodb下，能不能不设置主键？主键可以为空吗？可以允许几个？主键跟非主键的区别？索引存储形式？ 联合索引失效问题？索引失效问题？mysql索引，覆盖索引？回表？B+树叶子节点存储什么？为什么不用AVL树？ 数据库锁，乐观，悲观，record lock？next-key lock？</li>
<li>不停机扩容？分表避免冷热？不停机扩库？不停机扩表？跨库事务？</li>
<li>Redis与Mysql双写一致性方案</li>
<li>微服务需要注意些什么?</li>
<li>redis并发竞争key的解决方案</li>
<li>高并发系统的设计与实现</li>
<li>高并发系统的限流如何实现？</li>
<li>如何从0到1设计一个类似Dubbo的RPC框架？</li>
<li>线上有实际的性能优化经验？ 3、从SQL、JVM、架构、数据库四个方面讲讲优化思路，以及如何优先排序？</li>
<li>如果让你实现一个mq，怎么样保证消息不丢失</li>
<li>从简单的生产者消费者模式设计到如何高效健壮实现等等</li>
<li>然后根据一个项目，问如果量级扩大1000倍，你会怎么做？</li>
<li>如果让你做一个监控告警服务，你怎么设计</li>
<li>如果生产者生产的数据量很多，消费者来不及消费这些数据怎么办，</li>
<li>某一个业务中现在需要生成全局唯一的递增 ID, 并发量非常大, 怎么做</li>
<li>考虑一个业务场景: 头条的文章的评论量非常大, 比如说一篇热门文章就有几百万的评论, 设计一个后端服务, 实现评论的时序展示与分页</li>
<li>假如用 id 翻页的方式, 数据库表如何设计？索引如何设计？ 假如量很大, 你觉得需要分库分表吗? 怎么分？ 分库分表后怎么查询分页？ 分库分表后怎么保证主键仍然是递增的？ 现在需要支持深分页, 页码直接跳转, 怎么实现？</li>
<li>工作当中cpu和内存异常排查方法；详细说明分析过程及定位解决方式</li>
<li>redis问了一个实际问题的解决办法，如果redis一个value特别大，有什么解决方案；</li>
<li>接口调用变慢排查</li>
<li>解决项目运行时，CPU占用过高的问题</li>
<li>死锁怎么排查？</li>
<li>怎么不断优化项目、架构升级？如果业务量剧增，怎么保证系统高可用、扩展性？</li>
<li>系统负载过高怎么办、什么问题导致的？怎么排查？</li>
<li>JVM调优思路</li>
<li>redis cluster集群扩容怎么数据平滑过度，从客户端设计</li>
<li>设计一个im系统包括群聊单聊</li>
<li>设计数据库连接池</li>
<li>秒杀场景的设计</li>
<li>VM 出现 fullGC 很频繁，怎么去线上排查问题？</li>
<li>设计一个系统，每天有100亿条数据，需要在后台做实时展示和查找。 我当时回答的大体思路是nginx负载均衡，消息队列存储，多线程读取，批量插入，数据库分库分表。 面试官根据我的回答又衍生出了很多问题，如消息队列存满了怎么办？（也就是消费跟不上生产）批量插入时某一条失败了有什么影响？怎么解决？分库分表应该怎么分？怎么解决数据迁移的问题？</li>
<li>内存泄露，内存溢出解决方案？</li>
<li>A系统和B系统需要交互，A系统需要更新B系统的大量数据，但是更新失败了，有什么解决方法。</li>
<li>高并发场景 1、如何定时得往数据库中插入500万条数据以及删除，保证数据插入正确做到最优解； 2、在高并发下如何设计使用Redis；3、在高并发场景下如何设计一个接口，保证这个接口高性能高可用；</li>
<li>如何读取一个很大得文件里面存入了很多url怎么找到最常用得url；</li>
<li>如果页面点击反应慢，你怎么排查的？最后怎么优化？ 分布式你怎么怎么保持数据一致性的 说一下springboot启动run方法里都干了什么 给你ip1到ip2的一个ip段，再给你一个ip，用程序判断这个ip属不属于这个ip段 讲一下zk 你们zk挂了怎么处理的，你们redis挂了用的什么策略解决的</li>
<li>两个10G的文件，里面是一些url，内存只有1G，如何将这两个文件合并，找到相同的url？</li>
<li>100W 的数据，需要定时更新，失败需要重试，需要尽快执行完成。现在机器数量不固定，如何用最少的代码实现</li>
<li>一个任务在平时只需要 5 个线程就可以处理好，忙的时候需要 100 个线程才能处理完成， 如何设计才能合理利用资源？</li>
<li>规定给出的并发量外，如果有额外的流量访问进来了，如何做熔断处理？</li>
<li>搜索时延这么高，该如何进行优化？如何提高响应速度？如何优化以提升用户体验度？</li>
<li>如何实现何高并发下的削峰，限流？</li>
<li>服务器雪崩是怎么造成的？之前有这样的经历吗？怎么防备？</li>
<li>内存500M，有个文件存有int类型数据1亿条，要去读取，怎么处理</li>
<li>从需求到开发到上线。如何对需求进行有效管理？</li>
<li>假设有一个场景，系统需要某个特定时间内响应用户请求，比如说100ms内完成用户请求，但是在最高峰的时候每单位时间几百万的用户请求，也就是高并发，但我必须要实现系统响应及时，而且高可用(不宕机)，假如你是架构师，你该如何架构这个系统，聊聊你的方案。</li>
<li>如果要对系统进行监控，考虑哪些方面，如何实现？</li>
<li>如果你现在CPU100%了，你如何查询是哪个进程，哪个线程，哪行代码占用CPU过高？</li>
<li>自己写程序实现MySQL不同实例之间的导表/要求尽量高并发高效/给出设计</li>
<li>前台订单数据库如何与仓库库存数据库保持同步？限时抢购如何实现？</li>
<li>场景：同时给10万个人发工资，怎么样设计并发方案，能确保在1分钟内全部发完？</li>
<li>设计一个订餐排队系统，底层模型有哪些？(客户，商家，桌型)</li>
<li>单台机器4核，服务A请求时间为5S，但是A调用的某个服务B耗时4.98S，A服务超时时间是10S，问100QPS的访问量，动态线程池CoreSize,maxSize,等待队列怎么指定？</li>
<li>多个平台（B端C端）有多个支付的接口可利用，如何设计表；</li>
<li>给你100亿个账号和密码，怎么用纯Java自己设计一个缓存系统；</li>
<li>问重启服务的时候，发现线程数特别高，可能是什么问题？</li>
<li>秒杀系统如何设计？</li>
<li>如何实现1亿用户的消息通知机制？</li>
<li>秒杀业务怎样防止超卖；</li>
<li>怎么搭建一个自动化构建和发布环境，怎么从0开始搭建一个测试环境</li>
<li>分布式缓存实现原理，秒杀业务怎样防止超卖；</li>
<li>系统在10：05 设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在？</li>
<li>成千上万个数据文件，每个文件大概2GB数据量，只用java基础实现所有数据的读取，并按每条数据的时间排序；</li>
<li>设计十万并发级别的网站后台，如何计算使用的ecs数目；</li>
<li>10G的整数中，取出最大的一个；</li>
<li>设计一个系统，每天有100亿条数据，需要在后台做实时展示和查找。</li>
</ul>
<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><ul>
<li><p>InnoDB的行锁</p>
<blockquote>
<p>（1）共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 （2）排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁</p>
</blockquote>
</li>
<li><p>Spring的事务传播级别</p>
<blockquote>
<p>（1）REQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。 （2）SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。 （3）MANDATORY：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。 （4）REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。 （5）NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。 （6）NEVER：无事务执行，如果当前有事务则抛出Exception。 （7）NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</p>
</blockquote>
</li>
<li><p>Redis与Mysql双写一致性方案</p>
</li>
</ul>
<blockquote>
<p>先更新数据库，再删缓存。数据库的读操作的速度远快于写操作的，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作</p>
</blockquote>
<ul>
<li>索引B+树的叶子节点都可以存哪些东西？</li>
</ul>
<blockquote>
<p>可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引</p>
</blockquote>
<ul>
<li>分代回收</li>
</ul>
<blockquote>
<p>（1）HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 （2）因为年轻代中的对象基本都是朝生夕死的，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 （3）在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
</blockquote>
<ul>
<li>线程之间如何通信？</li>
</ul>
<blockquote>
<p>（1）利用最基本的synchronized （2）利用synchronized、notify、wait （3）while轮询的方式 （4）利用Lock和Condition （5）利用volatile （6）利用AtomicInteger （7）利用CyclicBarrier （8）利用PipedInputStream （9）利用BlockingQueue</p>
</blockquote>
<ul>
<li>redis并发竞争key的解决方案</li>
</ul>
<blockquote>
<p>（1）分布式锁+时间戳 （2）利用消息队列</p>
</blockquote>
<ul>
<li>如何避免（预防）死锁？</li>
</ul>
<blockquote>
<p>破坏“请求和保持”条件：让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源。 破坏“不可抢占”条件：允许进程进行抢占，方法一：如果去抢资源，被拒绝，就释放自己的资源。方法二：操作系统允许抢，只要你优先级大，可以抢到。 破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出（指定获取锁的顺序，顺序加锁）</p>
</blockquote>
<ul>
<li>高并发系统的设计与实现</li>
</ul>
<blockquote>
<p>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。 （1）缓存：缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。 （2）降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 （3）限流：限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>
</blockquote>
<ul>
<li>高并发系统的限流如何实现？</li>
</ul>
<blockquote>
<p>常见的限流算法有计数器、漏桶和令牌桶算法。漏桶算法在分布式环境中消息中间件或者Redis都是可选的方案。发放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。</p>
</blockquote>
<ul>
<li><p>JVM有哪些回收算法</p>
<blockquote>
<p>1）引用计数法 （2）复制算法 （3）标记-清除算法 （4）标记-整理算法 （5）分代收集算法</p>
</blockquote>
</li>
<li><p>垃圾收集器有哪些？</p>
</li>
</ul>
<blockquote>
<p>（1）Serial收集器 （2）ParNew 收集器 （3）Parallel Scavenge 收集器 （4）Serial Old收集器 （5）Parallel Old收集器 （6）CMS收集器 （7）G1收集器 (8)ZGC</p>
</blockquote>
<ul>
<li>常见的分布式事务方案有哪些？</li>
</ul>
<blockquote>
<p>（1）两阶段提交方案 （2）eBay 事件队列方案 （3）TCC 补偿模式 （4）缓存数据最终一致性</p>
</blockquote>
<ul>
<li>运行时数据区域（内存模型）</li>
</ul>
<blockquote>
<p>（1）程序计数器：程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。是线程私有”的内存。 （2）Java虚拟机栈：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧 ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 （3）本地方法栈：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 （4）Java堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 （5）方法区（1.8叫元数据）:方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<ul>
<li>CAS操作ABA问题</li>
</ul>
<blockquote>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性</p>
</blockquote>
<ul>
<li>为什么选择B+树作为索引结构？</li>
</ul>
<blockquote>
<p>（1）Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描 （2）二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。 （3）平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。 （4）红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。 （5）B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。</p>
</blockquote>
<ul>
<li>脏读和幻读是什么？</li>
</ul>
<blockquote>
<p>（1）脏读是指当一个事务正在访问数据，并且对数据进行了修改。而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。 （2）幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到了表中的全部数据行。同时，第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p>
</blockquote>
<ul>
<li>如何解决Redis缓存雪崩，缓存穿透问题？</li>
</ul>
<blockquote>
<p>缓存雪崩: (1)使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉 (2)缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效 (3)限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务 缓存穿透： (1)在接口做校验 (2)存null值（缓存击穿加锁） (3)布隆过滤器拦截： 将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。 布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。</p>
</blockquote>
<ul>
<li>Redis的持久化机制</li>
</ul>
<blockquote>
<p>redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。 Redis的持久化策略有两种： (1)RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。 当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。 (2)AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。 使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。 Redis默认是快照RDB的持久化方式。</p>
</blockquote>
<ul>
<li>三次握手</li>
</ul>
<blockquote>
<p>（1）第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 （2）第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； （3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
</blockquote>
<ul>
<li>Kafka消息是采用Pull模式，还是Push模式？</li>
</ul>
<blockquote>
<p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式。Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达。</p>
</blockquote>
<ul>
<li>HashMap相关</li>
</ul>
<blockquote>
<p>（1）在jdk1.8之后，HashMap除了数组+链表之外，引用了红黑树。需要说明对于引用了红黑树的 HashMap 如何put一个元素，以及链表是在何时转化为红黑树的。比如，首先需要知道这个元素落在哪一个数组里，获取hashcode后并不是对数组长度取余来确定的，而是高低位异或求与来得到的。这个地方首先得知道异或求与是做什么样的运算的。 （2）之后说一下在HashMap中的实现，比如hashcode无符号右移16位后和原hashcode做异或运算，这相当于把hashcode的高16位拿过来和hashcode的低16位做异或运算，因为无符号右移后前面说的16位都补零，这就是前面说的 “高低位异或“，进而是“求与”，和谁求与呢，和数组长度减1 求与。说到这里起码能够证明你是看过源码的，接下来说说你的思考，比如我们知道对于hashmap 初始化容量决定了数组大小，一般我们对于数组这个初始容量的设置是有规律的，它应该是 2^n 。这个初始容量的设置影响了HashMap的效率，那又涉及到影响HashMap效率的主要因素，比如初始容量和负载因子。</p>
</blockquote>
<ul>
<li>手写一个基于懒汉式的双重检测的单例。</li>
</ul>
<blockquote>
<p>（1）单例有三个比较关键的点，一是私有构造方法，避免外部new出对象；二是保证唯一性；三是提供一个全局访问点。 （2）另外，懒汉式双重检测的实现方式 有三点需要注意的地方，一是全局访问点必须是静态的，外界使用可以通过类直接调用，二是在进入锁之后还需要校验，三是保存单例对象的私有变量一定要用volatile修饰，这个地方可以多说一些，比如volatile防止指令重排序，保证内存可见性(JVM层面和CPU层面可以分别说)。</p>
</blockquote>
<ul>
<li>RPC原理</li>
</ul>
<blockquote>
<p>（1）为什么会出现RPC？ RPC(Remote Procedure Call Protocol)——远程过程调用协议。 一般来说，自己写程序然后本地调用，这种程序的特点是服务的消费方和提供方。当我们进入公司时，面对的很可能就是成千上万的服务提供方，这时候就需要使用RPC来进行远程服务调用。RPC将原来的本地调用转变为调用远端的服务器上的方法，给系统的处理能力和吞吐量带来了近似于无限制提升的可能。 （2）RPC的组成 ①客户端：服务的调用方 ②客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，③然后通过网络远程发送给服务方。 ④服务端：真正的服务提供者。 ⑤服务端存根：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</p>
</blockquote>
<ul>
<li>Redis缓存回收机制</li>
</ul>
<blockquote>
<p>（1）数据过期： ①定时删除策略：Redis启动一个定时器监控所有的key,一旦有过期的话就进行删除（遍历所有key,非常耗费CPU） ②惰性删除策略：获取key的时候判断是否过期， 过期则进行删除 Redis采用的方式:①(随机抓取一部分key进行检测)+② （2）内存淘汰： ①noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略） ②allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用） ③allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。 ④volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。 ⑤volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。 ⑥volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。</p>
</blockquote>
<ul>
<li>Redis主从同步</li>
</ul>
<blockquote>
<p>（1）主从复制作用 ①数据冗余 ②故障恢复（服务冗余） ③负载均衡 ④读写分离（主节点写操作、从节点读操作） （2）主从复制过程 ①连接建立阶段 步骤1：保存主节点信息 步骤2：建立socket连接 步骤3：发送ping命令 步骤4：身份验证 步骤5：发送从节点端口信息 ②数据同步阶段 从节点向主节点发送psync命令 根据主从节点当前状态的不同，可以分为全量复制和部分复制 ③命令传播阶段 主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。 （3）介绍全量复制和部分复制 ①全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。 ②部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。 （4）主从复制缺点：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p>
</blockquote>
<ul>
<li>为什么会有哨兵机制？</li>
</ul>
<blockquote>
<p>在主从复制的基础上，哨兵实现了自动化的故障恢复。</p>
</blockquote>
<ul>
<li>哨兵机制作用？</li>
</ul>
<blockquote>
<p>（1）监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。 （2）自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。 （3）配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。 （4）通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</p>
</blockquote>
<ul>
<li>哨兵机制节点组成？</li>
</ul>
<blockquote>
<p>它由两部分组成，哨兵节点和数据节点： （1）哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。 （2）数据节点：主节点和从节点都是数据节点。</p>
</blockquote>
<ul>
<li>哨兵机制原理？</li>
</ul>
<blockquote>
<p>（1）定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。 （2）主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。 （3）客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。 （4）选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。 （5）故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤： ①在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。 ②更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。 ③将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。</p>
</blockquote>
<ul>
<li>哨兵机制缺点</li>
</ul>
<blockquote>
<p>写操作无法负载均衡；存储能力受到单机的限制。（Redis集群解决了该情况）</p>
</blockquote>
<ul>
<li>Zookeeper锁是如何实现的？</li>
</ul>
<blockquote>
<p>一般使用Curator进行使用Zookeeper锁，例如有两个客户端A和客户端B,首先A先在锁节点下创建例如01子节点的锁，然后再获取节点信息，发现自己的01节点排名第一，那么就获得锁。 客户端B也需要获取锁，现在锁节点下创建例如02的子节点，然后再获取锁节点信息，发现锁节点信息为[01,02],并不排第一，因此获取不到锁，客户端B会在他的顺序节点的上一个顺序节点加一个监听器。 当客户端A使用完锁，删除01节点，客户端B获取到01删除的监听，然后发现自己的02节点排名第一，那么就获取到锁。</p>
</blockquote>
<ul>
<li>JVM内存模型</li>
</ul>
<blockquote>
<p>（1）程序计数器：线程私有，用来程序跳转，流程控制 （2）方法区（1.8叫元数据区）：线程共享，用于存储类信息、常量、静态变量等信息 （3）Java虚拟机栈：线程私有，用于方法调用Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError （4）堆：线程私有，主要的内存区域，存储对象实例，垃圾回收主要针对这一块。 （5）本地方法栈：线程共享，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
</blockquote>
<ul>
<li>G1和CMS垃圾回收器</li>
</ul>
<blockquote>
<p>G1和CMS垃圾回收器 （1）CMS收集器：是一种以获取最短回收停顿时间为目标的收集器。 过程： ①初始标记：标记GC Roots能直接关联到的对象，需要在safepoint位置暂停所有执行线程。—-&gt;STW ②并发标记：进行GC Roots Tracing，遍历完从root可达的所有对象。该阶段与工作线程并发执行。 ③重新标记：修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录。需要在safepoint位置暂停所有执行线程。—&gt;STW ④并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。 优点：并发收集、低停顿。 缺点： ①CMS收集器对CPU资源非常敏感。 ②CMS收集器无法处理浮动垃圾（Floating Garbage）。 ③CMS收集器是基于标记-清除算法，该算法缺点都有：标记和清除效率低/产生大量不连续的内存碎片。 ④停顿时间是不可预期的。 （2）G1收集器：重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。 过程： ①初始标记：标记GC Roots 可以直接关联的对象，该阶段需要线程停顿但是耗时短。—-&gt;STW ②并发标记：寻找存活的对象，可以与其他程序并发执行，耗时较长。 ③最终标记：并发标记期间用户程序会导致标记记录产生变动（好比一个阿姨一边清理垃圾，另一个人一边扔垃圾）虚拟机会将这段时间的变化记录在Remembered Set Logs 中。最终标记阶段会向Remembered Set合并并发标记阶段的变化。这个阶段需要线程停顿，也可以并发执行—-&gt;STW ④筛选回收：对每个Region的回收成本进行排序，按照用户自定义的回收时间来制定回收计划 优点： ①空间整合：G1使用Region独立区域概念，G1利用的是标记复制法，不会产生垃圾碎片 ②分代收集：G1可以自己管理新生代和老年代 ③并行于并发：G1可以通过机器的多核来并发处理 STW停顿，减少停顿时间，并且可不停顿java线程执行GC动作，可通过并发方式让GC和java程序同时执行。 ④可预测停顿：G1除了追求停顿时间，还建立了可预测停顿时间模型，能让制定的M毫秒时间片段内，消耗在垃圾回收器上的时间不超过N毫秒 缺点： G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。</p>
</blockquote>
<ul>
<li>wait/await和sleep区别</li>
</ul>
<blockquote>
<p>（1）两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。 （2）两者都可以暂停线程的执行。 （3）wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。 （4）wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</p>
</blockquote>
<ul>
<li>Redis的LRU过期策略的具体实现 Redis的LRU具体实现</li>
</ul>
<blockquote>
<p>用栈的形式会导致执行select *的时候大量非热点数据占领头部数据，所以需要改进。 Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。 在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。</p>
</blockquote>
<ul>
<li>哪些对象可以作为GC Roots？</li>
</ul>
<blockquote>
<p>（1）虚拟机栈（栈帧中的本地变量表）中引用的对象。 （2）方法区中类静态属性引用的对象。 （3）方法区中常量引用的对象。 （4）本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</blockquote>
<ul>
<li>ConcurrentHashMap的数据结构</li>
</ul>
<blockquote>
<p>在JDK1.7版本中，ConcurrentHashMap维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，并且该类里面维护了一个 HashEntry&lt;K,V&gt;[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。在JDK1.8版本中，ConcurrentHashMap摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。</p>
</blockquote>
<ul>
<li>tcp和udp的优点与缺点</li>
</ul>
<blockquote>
<p>（1）TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 （2）TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。 （3）UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… （4）UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输。什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP。</p>
</blockquote>
<ul>
<li>HashMap原理</li>
</ul>
<blockquote>
<p>（1）hashMap 是非线程安全的， hashMap 1.7的底层实现为数组（table[]）＋链表(LinkList–&gt;Entry)，hashmap 1.8底层为数组+链表/红黑树（当链表长度到达阈值TREEIFY_THRESHOLD（默认为8）时，会转化为红黑树）</p>
</blockquote>
<ul>
<li>HashMap的put和resize的过程</li>
</ul>
<blockquote>
<p>（1）put过程： ①查看数组是否需要初始化 ②根据key计算hashcode ③根据hashcode计算出桶位置 ④遍历链表，查看key值与链表节点的key值是否相等，如果相等的话，那么进行覆盖旧值，并返回旧值。1.8的话需要先查看链表长度是否达到阈值，如果达到阈值，先进行红黑树转化然后再进行检查扩容。 ⑤新增的时候需要检查是否需要扩容，需要扩容的话进行两倍扩容，扩容完成后进行插入新值。 （2）resize过程： resize扩容需要从四个方面来进行回答： ①什么时候触发resize? 当容量超过当前容量（默认容量16）乘以负载因子（默认0.75）就会进行扩容，扩容大小为当前大小的两倍（扩展问题，为啥是两倍：通过限制length是一个2的幂数，h &amp; (length-1)和h % length结果是一致的）。 ②resize是如何hash的：h &amp; (length-1) ③resize是如何进行链表操作的：使用头插法进行数据插入，每次新put的值放在头部 ④并发操作下，链表是如何成环的：HashMap的环：若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。</p>
</blockquote>
<ul>
<li>线程池有哪些类型</li>
</ul>
<blockquote>
<p>①FixedThreadPool:创建可重用固定线程数的线程池。 ②SingleThreadPool:创建只有一个线程的线程池。 ③CachedThreadPool:一个可根据需要创建新线程的线程池，如果现有线程没有可用的，则创建一个新线程并添加到池中，如果有被使用完但是还没销毁的线程，就复用该线程。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 ④ScheduledThreadPool：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
</blockquote>
<ul>
<li>ConcurrentHashMap分段锁原理</li>
</ul>
<blockquote>
<p>（1）ConcurrentHashMap采用了分段锁技术，其中Segement继承了RecentLock，当ConcurrentHashMap进行get、put操作时，均是同步的。各个Segement之间的get、put操作可以进行并发，即当一个线程访问ConcurrentHashMap的Segement时，不会影响对其他Segement的访问。</p>
</blockquote>
<ul>
<li>B-树和B+树区别</li>
</ul>
<blockquote>
<p>1）B-树和B树是一个概念，是多路搜索树（相比于二叉搜索树，IO次数更少）。B-树的特性： ①关键字集合分布在整颗树中； ②任何一个关键字出现且只出现在一个结点中； ③搜索有可能在非叶子结点结束； ④其搜索性能等价于在关键字全集内做一次二分查找； ⑤其最底搜索性能为O(logN) （2）B+树是B-树的变体，也是一种多路搜索树 B+的特性： ①所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； ②不可能在非叶子结点命中； ③非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； ④更适合文件索引系统； （3）B+树的优势： ①单一节点存储更多的元素，使得查询的IO次数更少。 ②所有查询都要查找到叶子节点，查询性能稳定。 ③所有叶子节点形成有序链表，便于范围查询。</p>
</blockquote>
<ul>
<li>Mysql数据库索引原理</li>
</ul>
<blockquote>
<p>（1）MyISAM索引实现：MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。 （2）Innodb索引实现： ①第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 ②第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
</blockquote>
<ul>
<li>组合索引怎么使用？最左匹配的原理。</li>
</ul>
<blockquote>
<p>1）组合索引怎么使用？ 例如组合索引（a,b,c），组合索引的生效原则是： 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面（范围值也算断点，orderby不算断点，用到索引）的索引部分起作用，断点后面的索引没有起作用； （2）最左匹配的原理：以最左边的为起点任何连续的索引都能匹配上</p>
</blockquote>
<ul>
<li>Spring生命周期</li>
</ul>
<blockquote>
<p>Bean 的生命周期概括起来就是 4 个阶段： （1）实例化（Instantiation） （2）属性赋值（Populate） （3）初始化（Initialization） （4）销毁（Destruction）</p>
</blockquote>
<ul>
<li>Spring几种scope区别？</li>
</ul>
<blockquote>
<p>（1）singleton:Spring的IOC容器中只有一个实例bean，该值为scope的默认值 （2）prototype：每次getBean时都会创建一个新的实例 （3）request:每次请求都会创建一个实体bean （4）session：每次session请求时都会创建一个实体bean （5）globalsession:每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。</p>
</blockquote>
<ul>
<li>Spring AOP实现有哪几种实现</li>
</ul>
<blockquote>
<p>接口代理和类代理会有什么区别？ （1）Spring AOP有两种实现，均为动态代理： ①JDK动态代理：基于反射进行动态代理，核心类是InvocationHandker类和Proxy类，被代理的类必须实现接口 ②CGLIB动态代理：被代理类无需实现接口，主要实现MethodInterceptor接口即可实现代理 （2）Spring AOP如果代理的类存在接口，优先使用JDK动态代理，否则使用CGLIB动态代理。</p>
</blockquote>
<ul>
<li>MVCC,binlog,redolog,undolog都是什么，起什么作用？</li>
</ul>
<blockquote>
<p>（1）undolog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如”把id=’B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id =’B’的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。 （2）redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。 （3）MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。 （4）binlog由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑，比如”把id=’B’ 修改为id = ‘B2’。binlog会写入指定大小的物理文件中,是追加写入的,当前文件写满则会创建新的文件写入。 产生:事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用binlog恢复</p>
</blockquote>
<ul>
<li>Kafka是如何实现高吞吐率的？</li>
</ul>
<blockquote>
<p>1）顺序读写：kafka的消息是不断追加到文件中的，这个特性使kafka可以（2）充分利用磁盘的顺序读写性能 （3）零拷贝：跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区” （4）文件分段：kafka的队列topic被分为了多个区partition，每个partition又分为多个段segment，所以一个队列中的消息实际上是保存在N多个片段文件中 （5）批量发送：Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去 （6）数据压缩：Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩</p>
</blockquote>
<ul>
<li>Http请求的完全过程</li>
</ul>
<blockquote>
<p>（1）浏览器根据域名解析IP地址（DNS）,并查DNS缓存 （2）浏览器与WEB服务器建立一个TCP连接 （3）浏览器给WEB服务器发送一个HTTP请求（GET/POST）：一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。 （4）服务端响应HTTP响应报文，报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。 （5）浏览器解析渲染</p>
</blockquote>
<ul>
<li>Spring的@Transactional如何实现的？</li>
</ul>
<blockquote>
<p>（1）配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。 （2）spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。 （3）真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的</p>
</blockquote>
<ul>
<li>为什么要使用线程池？</li>
</ul>
<blockquote>
<p>（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 （2）提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 （3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</blockquote>
<ul>
<li>rpc框架实现原理？</li>
</ul>
<blockquote>
<p>主要有以下几个步骤： （1）建立通信： 首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有相关的数据都在这个连接里面进行传输交换。 通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。 （2）服务寻址： 解决寻址的问题：即A机器上的应用A要调用B机器上的应用B，那么此时对于A来说如何告知底层的RPC框架所要调用的服务具体在哪里呢？ 通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。比如基于Web服务协议栈的RPC，就需要提供一个endpoint URI，或者是从UDDI服务上进行查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。 （3）网络传输： ①序列化 当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。 ②反序列化 当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。 （4）服务调用： B机器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。</p>
</blockquote>
<ul>
<li>redis热key怎么解决？</li>
</ul>
<blockquote>
<p>(1)利用二级缓存： 比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。 现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。 (2)备份热key： 这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。</p>
</blockquote>
<ul>
<li>不同年代GC收集器有哪些？</li>
</ul>
<blockquote>
<p>（1）serial收集器：单线程，工作时必须暂停其他工作线程。多用于client机器上，使用复制算法 （2）ParNew收集器：serial收集器的多线程版本，server模式下虚拟机首选的新生代收集器。复制算法 （3）Parallel Scavenge收集器：复制算法，可控制吞吐量的收集器。吞吐量即有效运行时间。 （4）Serial Old收集器：serial的老年代版本，使用整理算法。 （5）Parallel Old收集器：第三种收集器的老年代版本，多线程，标记整理 （6）CMS收集器：目标是最短回收停顿时间。标记清除算法实现，分四个阶段： •初始标记：GC Roots直连的对象做标记 •并发标记：多线程方式GC Roots Tracing •重新标记：修正第二阶段标记的记录 •并发清除。 缺点：标记清除算法的缺点，产生碎片。CPU资源敏感。</p>
</blockquote>
<ul>
<li>ES脑裂问题分析及优化</li>
</ul>
<blockquote>
<p>（1）脑裂问题可能的成因 •网络问题：集群间的网络延迟导致一些节点访问不到master，认为master挂掉了从而选举出新的master，并对master上的分片和副本标红，分配新的主分片 •节点负载：主节点的角色既为master又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。 •内存回收：data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。 （2）脑裂问题解决方案： •减少误判：discovery.zen.ping_timeout节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。 •选举触发 discovery.zen.minimum_master_nodes:1 该参数是用于控制选举行为发生的最小集群主节点数量。 当备选主节点的个数大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为（n/2）+1，n为主节点个数（即有资格成为主节点的节点个数） 增大该参数，当该值为2时，我们可以设置master的数量为3，这样，挂掉一台，其他两台都认为主节点挂掉了，才进行主节点选举。 •角色分离：即master节点与data节点分离，限制角色</p>
</blockquote>
<ul>
<li>讲一讲类加载的过程</li>
</ul>
<blockquote>
<p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载，连接，初始化，具体行为在 Java 虚拟机规范里有非常详细的定义。 （1）首先是加载过程（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，比如 jar 文件，class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。 （2）第二阶段是连接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转入 JVM 运行的过程中。这里可进一步细分成三个步骤：1，验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。2，准备（Pereparation），创建类或者接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显示初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。3，解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在 Java 虚拟机规范中，详细介绍了类，接口，方法和字段等各方面的解析。 （3）最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。再来谈谈双亲委派模型，简单说就是当加载器（Class-Loader）试图加载某个类型的时候，除非父类加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
</blockquote>
<ul>
<li>不可重复读和幻读区别</li>
</ul>
<blockquote>
<p>（1）”不可重复读” 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，bai另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 （2）幻觉读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
</blockquote>
<ul>
<li>单例对象会被jvm的gc时回收吗</li>
</ul>
<blockquote>
<p>（1）jvm卸载类的判定条件如下： ①该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。 ②加载该类的ClassLoader已经被回收。 ③该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 （2）只有上面三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被卸载。也就是说，只要单例类中的静态引用指向jvm堆中的单例对象，那么单例类和单例对象都不会被垃圾收集，依据根搜索算法，对象是否会被垃圾收集与未被使用时间长短无关，仅仅在于这个对象是不是不可回收的。</p>
</blockquote>
<ul>
<li>Get和Post区别</li>
</ul>
<blockquote>
<p>（1）Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 （2）Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 (3)Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 (4)Get执行效率却比Post方法好。Get是form提交的默认方法。 GET产生一个TCP数据包；POST产生两个TCP数据包。（非必然，客户端可灵活决定）</p>
</blockquote>
<ul>
<li>死锁的4个必要条件</li>
</ul>
<blockquote>
<p>（1）互斥条件：一个资源每次只能被一个线程使用； （2）请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放； （3）不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺； （4）循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</p>
</blockquote>
<ul>
<li>Redis 的数据结构及使用场景</li>
</ul>
<blockquote>
<p>1)String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。 (2)Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对 结构，添加命令：hset key field value。哈希可以用来存放用户信息，比如实现购物车。 (3)List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 (4)Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过 索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (5)Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作</p>
</blockquote>
<ul>
<li>ZAB协议</li>
</ul>
<blockquote>
<p>ZAB协议包括两种基本的模式：崩溃恢复和消息广播。当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。 当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p>
</blockquote>
<ul>
<li>volatile作用</li>
</ul>
<blockquote>
<p>（1）volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。(共享内存，私有内存) （2）volatile关键字通过“内存屏障”来防止指令被重排序。</p>
</blockquote>
<ul>
<li>什么是值传递和引用传递</li>
</ul>
<blockquote>
<p>（1）值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. （2）引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</p>
</blockquote>
<ul>
<li>Java内存模型</li>
</ul>
<blockquote>
<p>Java虚拟机规范中将Java运行时数据分为六种: （1）程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。 （2）Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。 （3）本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。 （4）Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。 （5）方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。 （6）运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。</p>
</blockquote>
<ul>
<li>string.stringbuilder.stringbuffer的区别，为什么string不可变</li>
</ul>
<blockquote>
<p>（1）区别 ①String是字符串常量，而StringBuffer和StringBuilder是字符串变量。由String创建的字符内容是不可改变的，而由StringBuffer和StringBuidler创建的字符内容是可以改变的。 ②StringBuffer是线程安全的，而StringBuilder是非线程安全的。StringBuilder是从JDK 5开始，为StringBuffer类补充的一个单线程的等价类。我们在使用时应优先考虑使用StringBuilder，因为它支持StringBuffer的所有操作，但是因为它不执行同步，不会有线程安全带来额外的系统消耗，所以速度更快。 （2）String为什么不可变： 虽然String、StringBuffer和StringBuilder都是final类，它们生成的对象都是不可变的，而且它们内部也都是靠char数组实现的，但是不同之处在于，String类中定义的char数组是final的，而StringBuffer和StringBuilder都是继承自AbstractStringBuilder类，它们的内部实现都是靠这个父类完成的，而这个父类中定义的char数组只是一个普通是私有变量，可以用append追加。因为AbstractStringBuilder实现了Appendable接口</p>
</blockquote>
<ul>
<li>为什么在重写equals方法的时候要重写hashcode的方法？</li>
</ul>
<blockquote>
<p>（1）我们知道判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，造成hashcode的值不同，而equals()方法判断出来的结果为true。 （2）在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。</p>
</blockquote>
<ul>
<li>反射的作用是什么？</li>
</ul>
<blockquote>
<p>（1）反射的主要作用是用来扩展系统和动态调用程序集。 （2）所谓扩展系统就是先把系统写好，系统里面定义接口，后面开发的人去写接口的代码。 （3）动态调用程序集就是利用反射去调用编译好的dll，当然此时的dll没有被引用到你所建的工程里面。</p>
</blockquote>
<ul>
<li>同步与异步区别？</li>
</ul>
<blockquote>
<p>（1）同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 （2）异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p>
</blockquote>
<ul>
<li>Java中overload override的区别</li>
</ul>
<blockquote>
<p>（1）Overload是重载的意思，Override是覆盖的意思，也就是重写。 （2）重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中的方法给覆盖了，这也是多态性的一种表现。 （3）重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法可以改变返回值类型。所以，如果两个方法的参数列表完全一样，是不能通过让它们的返回值类型不同来实现重载的。 （4）override是覆盖一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。 （5）overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同类型的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行。 （6）方法的重写和重载是Java多态性的不同表现。重写是父类与子类之间多态性的一种表现，而重载是一个类中多态性的一种表现。</p>
</blockquote>
<ul>
<li>线程的创建方式</li>
</ul>
<blockquote>
<p>（1）继承Thread ①定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 ②创建Thread子类的实例，即创建了线程对象。 ③调用线程对象的start()方法来启动该线程。 （2）实现Runnable接口 ①定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 ②创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 ③调用线程对象的start()方法来启动该线程。 （3）实现Callable接口 ①创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 ②创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 ③使用FutureTask对象作为Thread对象的target创建并启动新线程。 ④调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
</blockquote>
<ul>
<li>LinkList和ArrayList的区别</li>
</ul>
<blockquote>
<p>（1）ArrayList的底层实现就是数组，且ArrayList实现了RandomAccess，表示它能快速随机访问存储的元素，通过下标 index 访问，只是我们需要用 get() 方法的形式，数组支持随机访问，查询速度快，增删元素慢； （2）LinkedList的底层实现是链表，LinkedList没有实现RandomAccess 接口，链表支持顺序访问，查询速度慢，增删元素快；</p>
</blockquote>
<ul>
<li>垃圾回收算法</li>
</ul>
<blockquote>
<p>（1）标记—清除算法 标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程。 （2）复制算法 复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。 （3）标记—整理算法 复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
</blockquote>
<ul>
<li>Hashtable 和 HashMap的区别？</li>
</ul>
<blockquote>
<p>（ 1）主要区别在于 HashMap允许将 null作为一个 entry的 key或者 value，而 Hashtable不允许。由于非线程安全，多线程情况下，效率上可能高于 Hashtable。 Hashtable和 HashMap采用的 hash/rehash 算法都大概一样，所以单线程性能不会有很大的差异。 （ 2） Hashtable的方法是 Synchronize的，而 HashMap不是，在多个线程访问 Hashtable时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步 (Collections.synchronizedMap)。 （ 3） HashMap是 Hashtable的轻量级实现（非线程安全的实现），他们都完成了 Map接口， Hashtable继承自 Dictionary类，而 HashMap是 Java1.2引进的 Map interface的一个实现。</p>
</blockquote>
<ul>
<li>servlet的线程安全问题？</li>
</ul>
<blockquote>
<p>答：如果代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。那么我们都知道servlet是多线程的，同时一个servlet实现类只会有一个实例对象，也就是它是Singleton的,所以多个线程是可能会访问同一个servlet实例对象的。同一个实例对象被多个线程访问，如果没有做同步处理，那么servlet就是非线程安全的，如果做了同步处理，就是线程安全。所以，servlet是否线程安全是由它的实现来决定的，如果它内部的属性或方***被多个线程改变，它就是线程不安全的，反之，就是线程安全的。</p>
</blockquote>
<ul>
<li>为什么要用volatile关键字？</li>
</ul>
<blockquote>
<p>答：在高并发时会出现并发模式异常，volatile可以防止指令重排，创建对象操作并不是一个原子操作，分为三个步骤 （1）构建对象：根据Person类元信息确定对象的大小，向JVM堆中申请一块内存区域并构建对象的默认信息(加载Person对象成员变量信息并赋默认值如 int类型为0，引用类型为null)。 （2）初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。 （3）引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址……</p>
</blockquote>
<ul>
<li>java并发锁机制。</li>
</ul>
<blockquote>
<p>（1）偏向锁：JDK1.6提出来的一种锁优化的机制。其核心的思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就是说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，从而节约了操作时间，如果在此之间有其他的线程进行了锁请求，则锁退出偏向模式 （2）轻量级锁：如果偏向锁失败，Java虚拟机就会让线程申请轻量级锁，轻量级锁在虚拟机内部，使用一个成为BasicObjectLock的对象实现的，这个对象内部由一个BasicLock对象和一个持有该锁的Java对象指针组成。BasicObjectLock对象放置在Java栈帧中。在BasicLock对象内部还维护着displaced_header字段，用于备份对象头部的Mark Word。 （3）重量级锁：当轻量级锁失败，虚拟机就会使用重量级锁。重量级锁在操作过程中，线程可能会被操作系统层面挂起，如果是这样，线程间的切换和调用成本就会大大提高。 （4）自旋锁：它可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。</p>
</blockquote>
<ul>
<li>了解zookeeper的leader选取算法吗，讲一下它的流程。</li>
</ul>
<blockquote>
<p>（1）自增选举轮次。Zookeeper规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对logicalclock进行自增操作。 （2）初始化选票。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为Leader。 （3）发送初始化选票。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper会将刚刚初始化好的选票放入sendqueue中，由发送器WorkerSender负责发送出去。 （4）接收外部投票。每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。 （5）判断选举轮次。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。 ·外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。 ·外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理，并返回步骤4。 ·外部投票的选举轮次等于内部投票。此时可以开始进行选票PK。 （6）选票PK。在进行选票PK时，符合任意一个条件就需要变更投票。 · 若外部投票中推举的Leader服务器的选举轮次大于内部投票，那么需要变更投票。 · 若选举轮次一致，那么就对比两者的ZXID，若外部投票的ZXID大，那么需要变更投票。 · 若两者的ZXID一致，那么就对比两者的SID，若外部投票的SID大，那么就需要变更投票。 （7）变更投票。经过PK后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。 （8）选票归档。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档。recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票。 （9）统计投票。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤（4）。 （10）更新服务器状态。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的Leader服务器是否是自己，若是自己，则将自己的服务器状态更新为LEADING，若不是，则根据具体情况来确定自己是FOLLOWING或是OBSERVING。</p>
</blockquote>
<ul>
<li>双亲委派机制及其使用原因？</li>
</ul>
<blockquote>
<p>（1）当某个特定的类加载器它在接到需要加载类的请求时，这个类会首先查看自己已加载完的类中是否包含这个类，如果有就返回，没有的话就会把加载的任务交给父类加载器加载，以此递归，父类加载器如果可以完成类加载任务，就返回它，当父类加载器无法完成这个加载任务时，才会不得已自己去加载。这种机制就叫做双亲委派机制。 （2）原因： 双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。</p>
</blockquote>
<ul>
<li>treemap和HashMap的区别？</li>
</ul>
<blockquote>
<p>（1）HashMap是通过hashcode()对其内容进行快速查找的；HashMap中的元素是没有顺序的；TreeMap中所有的元素都是有某一固定顺序的，如果需要得到一个有序的结果，就应该使用TreeMap； （2）HashMap继承AbstractMap类；覆盖了hashcode() 和equals() 方法，以确保两个相等的映射返回相同的哈希值；TreeMap继承SortedMap类；他保持键的有序顺序； （3）HashMap：基于hash表实现的；使用HashMap要求添加的键类明确定义了hashcode() 和equals()；为了优化HashMap的空间使用，可以调优初始容量和负载因子；TreeMap：基于红黑树实现的；TreeMap就没有调优选项，因为红黑树总是处于平衡的状态；</p>
</blockquote>
<ul>
<li>java内存泄露解决</li>
</ul>
<blockquote>
<p>堆的dump文件，通过jmx的mbean生产当前 的heap信息， 用eclipse自带的静态分析工具Mat（windDBG）打开 分析内存泄露：那些被怀疑为内存泄露，哪些占用空间大，对象调用关系</p>
</blockquote>
<ul>
<li>分布式锁的实现原理和有多少种实现方式？</li>
</ul>
<blockquote>
<p>目前主流的分布式锁的实现方式有三种： ①借助数据库来实现，新建一张锁表； 操作前向表添加一条锁记录（锁id建立唯一索引），成功添加者获得锁权限，处理完后删除锁记录来释放锁。 ②基于缓存实现，如memcache 和 redis； memcache的add操作具有原子性，可以保证同一个key add操作只有一个成功，来获取锁权限，利用缓存的失效时间来解决死锁问题。相对于第一种方案，这种方案性能更好，而且操作更方便。 ③通过zookeeper实现； 客户端会在zookeeper生成一个临时的目录节点，存储在一个序列中，每次节点序号最小的节点对应的客户端获得锁，处理完成后删除最小节点，而且可重复获取锁（通过判断序号是否和最小的节点相同）。这种方式可以实现阻塞分布式锁，和锁的重复获取问题。</p>
</blockquote>
<ul>
<li>HashMap和Hashtable的区别</li>
</ul>
<blockquote>
<p>主要的区别有：线程安全性，同步，以及速度。 （1）HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 （2）另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p>
</blockquote>
<ul>
<li>HashMap中是否任何对象都可以做为key,用户自定义对象做为key有没有什么要求？</li>
</ul>
<blockquote>
<p>用自定义类作为key，必须重写equals()和hashCode()方法。 自定义类中的equals() 和 hashCode()都继承自Object类。 Object类的hashCode()方法返回这个对象存储的内存地址的编号。 而equals()比较的是内存地址是否相等。</p>
</blockquote>
<ul>
<li>对sql进行优化的原则有哪些？</li>
</ul>
<blockquote>
<p>（1）减少返回不必要的数据 （2）减少物理和逻辑读次数 （3）减少计算次数</p>
</blockquote>
<ul>
<li>String和StringBuffer的区别</li>
</ul>
<blockquote>
<p>1）运行速度：StringBuilder &gt;StringBuffer &gt;String String是字符串常量，不可变，每次改变只是创建一个新的对象，然后GC回收掉老的那个，所以执行速度最慢，另外两个是字符串对象，可变。 （2）线程安全： StringBuilder是线程不安全的，StringBuffer是线程安全的，看是否带synchronized关键字。多线程则采用StringBuffer，单线程则要建议用速度较快的StringBuilder。 （3）String：适用于少量的字符串操作的情况，String是final类，无法被继承。StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况。 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。</p>
</blockquote>
<ul>
<li>如果A和B对象循环引用，是否可以被GC？</li>
</ul>
<blockquote>
<p>答：这个循环引用是否被回收，就看这个循环引用是否挂在根上，A引用B，B引用A，A和Ｂ并没有挂在某个内存元和根上，当他们的生命周期结束的时候。这两个对象都有可能被回收。</p>
</blockquote>
<ul>
<li>Error、Exception和RuntimeException的区别，作用又是什么？</li>
</ul>
<blockquote>
<p>Error是Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error的任何子类，因为这些错误可能是再也不会发生的异常条件。 Exception类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明。它是Exception的子类。</p>
</blockquote>
<ul>
<li>reader和inputstream区别</li>
</ul>
<blockquote>
<p>（1）InputStream是表示字节输入流的所有类的超类；Reader是用于读取字符流的抽象类 （2）InputStream提供的是字节流的读取，而非文本读取，这是和Reader类的根本区别。 即用Reader读取出来的是char数组或者String ，使用InputStream读取出来的是byte数组。</p>
</blockquote>
<ul>
<li>hashCode的作用；</li>
</ul>
<blockquote>
<p>hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p>
</blockquote>
<ul>
<li>Java中的内存溢出是如何造成的？</li>
</ul>
<blockquote>
<p>（1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据； （2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； （3）代码中存在死循环或循环产生过多重复的对象实体； （4）使用的第三方软件中的BUG； （5）启动参数内存值设定的过小；</p>
</blockquote>
<ul>
<li>springMVC的工作原理图</li>
</ul>
<blockquote>
<p>（1）客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配 DispatcherServlet的请求映射路径（在web.xml中指定）， web容器将请求转交给DispatcherServlet； （2）DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请 求参数Cookie等） 以及HandlerMapping的配置找到处理请求的处理器（Handler）； （3）DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将 具体的处理进行封装）， 再由具体的HandlerAdapter对Handler进行具体的调用。 （4）Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet； （5）Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过 ViewResolver将逻辑视图转化为真正的视图View； （6）Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端；</p>
</blockquote>
<ul>
<li>RPC框架和普通http有什么区别和优势？</li>
</ul>
<blockquote>
<p>基于Tcp封装还是http封装的？ （1）1、RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。 （2）RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。 （3）HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。 （4）HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。 （5）HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。 （6）HTTP需要事先通知，修改Nginx/HAProxy配置。RPC能做到自动通知，不影响上游。 （7）HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。</p>
</blockquote>
<ul>
<li>GC的基本原理？什么时候需要GC？为什么需要GC？</li>
</ul>
<blockquote>
<p>GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停 （1）对新生代的对象的收集称为minor GC； （2）对旧生代的对象的收集称为Full GC； （3）程序中主动调用System.gc()强制执行的GC为Full GC。 不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型： （1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收） （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC） （3）弱引用：在GC时一定会被GC回收 （4）虚引用：由于虚引用只是用来得知对象是否被GC</p>
</blockquote>
<ul>
<li>怎样避免死锁？</li>
</ul>
<blockquote>
<p>（1）破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。 （2）破坏”请求与保持条件”：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 （3）破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程</p>
</blockquote>
<ul>
<li>BEAN的生命周期</li>
</ul>
<blockquote>
<p>（1）应用启动的时候检查加载需要被Spring管理的bean. （2）根据实现的接口，依次设置beanName，BeanFactory，ApplicationContext应用上下文。 （3）根据实现的接口，依次调用加载前，设置值，自定义初始化方法，加载完成后。 （4）bean已经可以用了，存活直到上下文也被销毁。 （5）销毁的时候调用destroy方法和自定义的销毁方法。</p>
</blockquote>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a target="_blank" rel="noopener" href="https://github.com/zhendiao/JavaInterview"> JavaInterview</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">CS-Notes</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">欧葵</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://cutieagain.github.io/2021/03/08/java/%E9%9D%A2%E8%AF%95/%E5%B7%A7%E7%9B%AEjava%E9%9D%A2%E8%AF%95%E9%A2%9820210308/">http://cutieagain.github.io/2021/03/08/java/%E9%9D%A2%E8%AF%95/%E5%B7%A7%E7%9B%AEjava%E9%9D%A2%E8%AF%95%E9%A2%9820210308/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">欧葵</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/03/13/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%85%AD%E8%8A%82%20%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="第六节 监控管理">
                        
                        <span class="card-title">第六节 监控管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-03-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java/" class="post-category">
                                    java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E5%A4%A7%E5%AD%A6/">
                        <span class="chip bg-color">极客大学</span>
                    </a>
                    
                    <a href="/tags/Java-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%90%A5/">
                        <span class="chip bg-color">Java 项目实战营</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/07/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%B0%8F%E9%A9%AC%E5%93%A5%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="小马哥代码学习记录">
                        
                        <span class="card-title">小马哥代码学习记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java/" class="post-category">
                                    java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E5%A4%A7%E5%AD%A6/">
                        <span class="chip bg-color">极客大学</span>
                    </a>
                    
                    <a href="/tags/Java-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%90%A5/">
                        <span class="chip bg-color">Java 项目实战营</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="366499907"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">欧葵</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">212.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/cutieagain" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:330449857@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=330449857" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 330449857" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
