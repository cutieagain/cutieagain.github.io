<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日记-20210416</title>
      <link href="2021/04/16/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210416/"/>
      <url>2021/04/16/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210416/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="be608cc94d72a361f0845534da16facf40318129f773ab34e424d76511f90997">675ef3242d144ff249cb5b90ca6783763f30085172d8865c81550f115938b016639c25f98c0f8bd85257ccd748c2920acd58b2c9aa3cdc1702d1b0cc943a5da423c60fc0273627bc54cf5fc9a356e05742cec44f20f37e75c5acbe93a3de2bc22f2c3193d7f8ff5df30d28eeb4fc54261cdfd7a9758361f8aaeb315dc85ae83e154ab11769cc011b16b9cbdff0884da9513cb7046b55db303fd65269d9126edb70643b04429d4ae680c8f6ba94dd70cc52599b4902eceb2aeb76c57f63775795f4b7af98800a8424bdbfd254002ac1e963a34532c97416fcc56f9c38412543d5aa5922dfa9c894d7700edf533f4e47a5dbfe1c7eb9ea235763063f7edf861ed9e0f091a740f608e3a9b5b512e600862f0b1c508e3048af2a9b54d8510a201607db9df19600a19a14445e3f9c82e7e55cc2ee3743761da6197385f0117529cd3ccf0c014d034563efe52b5527ad49b9f111ed74c363ebe4050f31d70ad6e546e7740ccbe246c672abedff7c6ccee510745007f1975a0a8b68b9efb4e49bd2bedd3d50af5d5f65c48cd050b35f9f740bb7ae454380c59ced705d94f53ee78b3eb12e48b4a458ca857a1c3491ff9cbf8937ed30f479ce9bc8ee8a08a7d837ad76457573da1dd47e73f0ad3d400fb1c03e2f85abade7e2f26ba5698af52eba64c08e96205ee25b37f1f9f3ac0c7c6cdfb16237ae29cbca580564075ec26907e35a5fade93b6cb261ac1576a680f54da2390524fd42c69b0a32d4c58f39de64ed3d16a632f51049c7e09984c6489ca696fe50a30d9ab20ef7a03c336ccfb94284c8aa54eacc7f7f9ca9ee71e1e07482a3580689b30e12fed9cf296a065ff53efd60b852e760cfd7e83cbe5f47fa055ffb48b562cdd0f071d5bc2dc4b1ee98e35ddc52c317a67dceceff8cc06d8a5efffd577d8cd448399d658b361a7220df99222e36f2555edded2a0f6234934b9dd5de75e5ab269472d6f72f794b76dfc2e17b63740ad0840985700915d8d6188a2afea8a7311a475f865cf49731028b3f78f57905507b5cb89646058594188e33fdb113abe0fbfacf3a197d3cea496e8c6ebbb67ebf95a2c93b553fa1bfd527c79e00215242ba54a1b257ad73d9be4ec34b62d91cb5f2925a05d818c6227a0310795207f6caefcd3ec368229ddb96c68d7b8d1e0970311e2c76290655c90a1264697f3f29c749b0f035bb4221427bf1d5aa91b0e1963c94898c3a2b8dd8fa5d5601ee46d774a282511fb9b6df953c2c9287db230e5c3d26d2163107050684cb475d39461b58c6910efa61db60588ab5361f3bf3c43fe3b9976f3b6c77c5761553f069de2b72a9041f2e87f288262edf768b1da44005706ca272e5aecf78813a301772d0dc23f7fff93b47e261990c0d6c1dff4980bfddb5a3ee08bb00c1a3c207e9caf89f45ceada30bf91ccc029564288b3c021d9d24341f6eb16be69c5529f6415c94e124d6336638870353237be60c2ee3a21e9a471bc7c329ab64446ef4450532ba76ddbd90dc3e1c6bdd7757d9454b12992cc38b5f5c17b6b7c750303dfcfe38ad5e939b477ceb528229a8a7acb35baf0976626c2a93b9abc701e2d12e46fa626702110ee3dc4ee8a85de4a262c22b3f1f1f456d5dafc519c93a91455f8a1b397f9b8c3f9032538dd1274ec810e4a131cd6e4dbddac9e04042223f4db9687b5d13e8581a046526e53390bef4cdead49564f54094e5a3a8091c68e4d7e15e67ffa472c800f3daf3e6b0f1558d9ffa64b775689940a7900f288aa6349d4ba9b56f444a41968643a35ad4c12b5008b110ea27caf1ebcdefb594cc8e21bef8dfab6333f3f64e4f90fd6da2e95d4dfa275946b515b1495421b1d918a524dd4c2406de1e7ff9a03a0201f437c7cb245405d644ec043c89901140ec451cc76d00ea80f28b992a3a38315d8abd2fa22ba68ee365ae1f26f07b6d615084eada3eb2bd349447eb265f2857d46526f6114a72b93ee0ce0c61b01e7ce8102b219cad0e5b74c4ea79a89fb80ec462a381a2f5fea8ca062beefb49df0acaacee477f0cdad483485f59d28b4a527102c380be05810a6532455178449a726c82994cecbfde684731ae8c9fc5eb8e82d677c02848c1e04e793de41e36cad638e29b1eddef1451077ee41b2eeba821965693d41b431e89cd603502a4294dabc98beca74ba1dbf4daeb0c898a4c98509371a72725376c8c9b5a319adfcfb9aa1c97bc1a149cac6a9a1670a5f2b4ae6953726078c9ac7396ecdbc2ceef6a18e512301a4bbc777bf361c02cf811b7b0c13281cc675c67e2bcb93e1e49a81182d4aafb6d02aefc55173dc69ba91118c4589c6d44baa896c206fcb8f5a73a26eef626555dce89cad87573aa44c197763b3c35a0d003682cd209bb88e0977e6f71128156edd803c71ac2a52b797fd9aa19d3799c4cbe8c7160f3bc7b522e1a5de189ddf2dfe7d886f63c052aedd2608cb5aaacca24c444be760d808e5bf266db0b55228af4be341e3741629a672250eb66114442f7aa575c6dcb25c9aad6d2589a4b9bbde43c6257f07d3f6198dd79d29bef0a8393c621308dbc4a8a850900427401e1d03fa7556a95312369a286d7fa9f59b226ead0011fbb180b5c07bf07ea48f5a8f03c5b303d2383923ac56f5d32fa300be4409aac313009b3216a79871aeda031f132ea60eb3711e44c389e8837ceb0d7c0fc2fd321064de4d217229a5c9ed64da53557ac3aec7ae0b4aee16c7b3b276895dacf44cda9c544b0a821bd523395a480e3b3792a9ee0894fdec6fdbb4f0cb90d3d5091f0b975a4c87c860180302e5d576dcad8d2a373b9711a263b028c7e9616db85c812ad6bfc7a009fee8ea4d8400085b1a70f1e22a78b3400d49f251457c1fc57869371ea4e3f7d436412e13782ca14308f375c0b1f6ca87361edac5cf6cc9389ce2e1c5bd4ef78e2c5f511a20db9144042805cdbc547a122c5de8c41b278c1884f22ccf8270beed3f4cf8d81d0a6b855797219495c743532cc9ededb9bde56061ae194ce71a5425e9bfde21510cc59c4b281c4b830dada91594e39066739bc476547f36d66e76bc420453b095c29f8de698d8ee5d384d3c49f98cb8a0d940cd1523f229eeaf51e670548f39f8d425187185c50587af2af4077e3fcdfceda8b4268df7db91a737aaf9103a017f93413354357f77de875e0516084411689b7b141f7e89b54ab6f0d2e7245315d60280b75744bff4d4b855e9270ae2dbf13029c2ca1ebe56d1827c208b11cf58ee0473bae41d09b636f0a7733d0a4995787fd1d541081606f51bd0505da33f7e45a9a6523bf50ab3822fcacee68978eff78bd9daffcdfc59f911618b8d402f305abdd40725549f3f9b4843044b5116c49eb7ebf727a0bb656c0ee5ca0b7b2ddaa4c71757857a64bb1641a5b8489c7c35bb62abea78dc833f674f7324a6f8de679b66395731c64249a4f7654231ecd52a81eca95a4f118ab9fca94939a840bb4f44c99f725027650b7c91a6fbaf9380410ef13efb1c06a83297336efd7c750bd67fe8bec1c997f49f73599d67eda4ed7ae882e857874a0bbd1729f1db58fb1d46034889428becb118846d436ad3b1ed20c9e3956bccd0b81560a1fd25944f37847aff4d4ea8a46632762280df9eaa31c37081df7646665a43a2c1e3f0a061a576e8c1d845e5b119da447574ea7fe058091e2d7fff18937f1876baf08036399f90492eba80919d5d558d14416c2b3523c9eb99f74638a196159f82d0f0e4a5758e1fdf7bc7251127b300e25d3b97238c20f61651e79e2adfb95d01efdc3f7c34d182e271233f8671ee9ecc4417e4c95ed8232bd91d7f3c9beff7807f6fb4dc3f67245dd732055136790e7a670bbda74402f46c1990a215ac4044a339c5cb41bf4b023db4950a18a8d51f9ed7f93339c848313b4aa5c1efbdb3708d908dfa623fc3b37e300aa91dc7aab381ba64d13481a7100bc410538b3cc6ca936a471caa88d50d60bef0a270c66273a1f259be40ef1923d8ec10caf8678090f0c4f52283737cc60841e4bed5e5093b2f36ac5897d609f63f46eb568a4b6a54a5a5b354735134dcdcb983602988c7800dd3ea5741502bda1b2fc25f52e2fa32f255e3d903586ecc5e90c7a85b5a2be915fd1f51787b3c75a0ab6621f85deeb7478834906e89d3c5ce27f4b5cabcef4156f2f27dc9469c69d7df9f3582bf141adc5038b3f8e76cc6f840e68edfd5ee83e908036de58c52a552fd96cb562145cff271d33c777ca4d9e2a6e5df71fa518e137f1b48d50a700ba2da052365bf403cd866c612ce462b9134e355397d3d928a93ae0838b05a112325ca2ee4a17619ea92304d2f2326c1ea7184e8ef7ae8bd0ae6b78361765c6186a455559b279fe4a87277bf1d9df0c646ab3314f17ecb78911a432e64892db6665a635600ea4af0d3b3eee0467f97211a270363671049e1b119f2df1ebed3e0dfeceb2bfb65357294465a6c9619e473d7241cc004ba1ff38e229f4ca1698dfe3612a196a24b78a53d38d048148e425241bc50087ad8602c02ed29721a09a30e24061601487a187a4f6c89483253687768fccfd115c11d4175da55f5cdb6fbe3ed57fb98e1c6572dba122ec015676af1a204b0031bde12c96a33a261365c0ce73db9c4836c5c6cdf8e77152153c04b5cf0980604adafb67897f80216711e8b22238abc9a05bbf94def46eb000ed6f1225d67cd342326c3fa2d9550097b99a9cd9ab0548f1800643dc75c749ceb81f4c22a504950a439bd8ceac4b161505900d4d3d137d9f4a1dc4d9329be8f1cdc74dee0ef89a504b1c5bbbc053c397e4cdb976702d49b9bdead1a3767fa6a003404391637f9cb1cbaf5933d67835e21dc2a3743a0f4e6a3e09d59b600aec5f7717e712b398f3bc2cd7c9aa8e6844ed9d8578acf8cae8c308db280cee7862ca93b003996f1b8e7733956eeafe54a1e24812c6979cf9489847347c93e15b92d6e2ee50f89292cdeaa4bca04b7814919817815abda7556acad1898b9a84dffc05d4ba4dd97c9e4f458205157dce7176d90bd91abc551f8f7a94250aa4c1b44a08470976e3ec6856f28cfcef05e9c9375bc45f9bca49fb95daab21ecdb05f5b60ae16e4e53012d043882de012bbbdd7f8c519a1d69576b001861b4d0089b8abc008abe3e44a4fe9c9e945801a68868740db2c517bc2257a74fa0c0d437b71d9df2f30960b5e247d3bc32f85594cef7aaed8c5dbc74c72805387c93c3481d0751445a75e05a17afcadcc6f196118d0d1a5670d75bc72f56e49a0f76ec5eee8cd2b04d7187b105dce2d74d6a7a3327184d9cf8cfe9d472017cb6ef7fce72e2e798676c00f019605e1364cbfd8aca88a2a78392c27b027ba2b208276479ebf836668c920db3772a9654be8e479146e595c69b260daeb1a1e07af718af91f104ccf6e788f510363e7cefbd4b451752c5fd99b77392b04438606ba5efcd31a85f2e5cb2a1e6111efdece788d6c0f151b3bfb8972e1929243ad6699c1c8fce98b6549d36ec31c388d60e32a7f412df73a5e7415caa0028e861db8b54f804c0b7811eadf1c853f5bd682f468774838d8300bacc00920e47d967e566f155d617b57e246418aac099f0ea3c87e10979d25390c03407d9a7893cdbeb10d166f91742064c707b007c0acad3bb52139c7fd5e82a2e748088be827b995eabd5124af78d4ca6b21d2fff2f7a27bad90c16cb2820993cdcce6ba2c741f8608663ff950b6f68048ecb10f6ef75a77377ec6b51e5e9709a91d151bb1fd60b8cdd16897045680a02baf51e794eb30cae227bdfdd83fc78dba78609a9534c4808f5bb34d69c4123c0a25817d9ce8a811c86a6716300ef76c89bad5d96936f94789858cfee1e222ff4adde87d240710d6c0a777535ca83178080a3363cfbc4b971cccfa33b6f7d43c1b3223d3b6a10af587260681bfac358e4a170fbb5213659db2b051c428aff80302cb508db39ec0753689b3c1ea527413faa6d25d3012f30ab75b5c92507deb28a7472c1dad7ff6d66c052af2791b585b8666fd8cd6c4302baa04856ee3a062da3a4298222d9eaa0c4acd8bf323b745f539e93525a67ce96273820124320bc09957a17f70d094a08a6ee6aa6433de6e8dca35ab9b878dceea1b4db9986261a28f7ab019e061383c7ba8ae798b99a15e2f34e2b666ac81d0073a97966c7feac13a103668fc6f93984f2481fae63d0bb3ea382446a8559d21dabdfc01d36e795b6f21305d6cb59132047f0ea018274b1b3ef7cab007e87e5e14439c9ae4a29a6534184a7a022be94b37e6457940049f169b6a089f7984dc860804faafdb227506a3f330297f8ab5920dea6f0a4045754b37645f71368c97282fd6ccedc87f9b3344e89949e973556f0e701dca1280dbb62f6ca8aabcfddc31bffa3e76ff1f6fd2f4e4b5a30dc29e8554e105380996a7aa968bea149ccfb3eee534ef540e1e4bda8ee4d9f6a059542f8fd5d7193cbd679b655afab982d757f7437bd559aa77b7ff74249e89a068256c70c8526fefed35bfdab7f3da0c104fdb37e50478e450bc9388221aa26c386a4b4e408b9016a56172cbfbad67deb236853f74670d625ec35fb7be3e8ee1a4ac3153b935d387af45deda1e178e75c3949b4474795389bc5cd817b313ad34ab1a034da610aa99cc312fa874bea5fcf7f69fe062cca436219441b4f62f447471d5483e1b5e4472bb1f36caaeb8409b2f75545dcaf469e0ac241578c307dc2c65750ceafe86939a361d7d6ab7a1f733e866b5b33d1d7b7ef442868f0f89f04903779eea8a912434f6a7c529c981928aba31bc8bc92cc7509d9f47145b8f2a183270e4cf4b706c489e07d0201023e426da70b2cafb1829da9e612d99b54f14074ec3977f7e2823515774b5ce3ca77</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐11：搞定面试</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%9011%EF%BC%9A%E6%90%9E%E5%AE%9A%E9%9D%A2%E8%AF%95/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%9011%EF%BC%9A%E6%90%9E%E5%AE%9A%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><p>第 +07 课 软实力培养 </p><p>如何搞定面试？ </p><p>KimmKing </p><p>Apache Dubbo/ShardingSphere PMC</p><p><strong>目录</strong> </p><p>\1. 面试到底是怎么回事儿？ </p><p>2.如何做到充分准备面试？ </p><p>3.技术面试环节注意什么？ </p><p>4.HR面试环节需要注意什么？ </p><p>5.拿到多个offer应该如何选择？</p><h2 id="面试到底是怎么回事儿？"><a href="#面试到底是怎么回事儿？" class="headerlink" title="面试到底是怎么回事儿？"></a>面试到底是怎么回事儿？</h2><p><strong>为什么要有面试？</strong> </p><p>面试就像是高考。 </p><p>资源少，竞争多。 </p><p>那就需要有一个方式来做区分。 </p><p>高考题也好，筛选简历也好，面试问题也好，都是这种区分。</p><p><strong>为什么要有面试？</strong> </p><p>这种区分，本质上是一个充分竞争市场的销售过程。 </p><p>我们要做的事儿，是把自己推销给客户（大学/用人单位）； </p><p>然后卖个好价钱，好读大学/专业，一线公司/职位/薪水。</p><p><strong>为什么要有面试？</strong> </p><p>反过来考虑，用人单位到底怎么想，招什么样的人？ </p><p>不算校招和特招，一般情况下JD代表了基本想法： </p><p>1、要求：精通JVM，NIO，并发编程，理解分布式系统架构。。。 </p><p>2、职责：负责公司核心交易系统的架构设计，开发实现和日常维护。。。 </p><p>3、其他：良好的沟通能力，学习能力，自我驱动力。。。 </p><p>思考：<em>为什么面试造火箭，上岗拧螺丝钉<strong>？</strong></em>为什么要有面试？** </p><p>好公司的机会难得，发一个岗位招聘招3-5个人，可能会收到30-50甚至上百份简历。 </p><p>怎么从这么多人里，怎么用较小成本代价，找到最合适的那么3-5个人？ </p><p>所以，需要筛选简历，有面试 -&gt; 过程成本 </p><p>HR面试和谈薪水 -&gt; 人力成本</p><h2 id="如何做到充分准备面试？"><a href="#如何做到充分准备面试？" class="headerlink" title="如何做到充分准备面试？"></a>如何做到充分准备面试？</h2><p><strong>锚定目标公司与岗位</strong> </p><p>知己知彼，百战百胜 </p><p>对目标公司和岗位是否了解，会影响你面试的全流程 </p><p>评估好你要投的公司和岗位，是不是适合你 </p><p>朋友圈里，找类似岗位的人，了解详情 </p><p>熟人圈里，找经验丰富的人，问问意见</p><p><strong>找好推荐渠道</strong> </p><p>渠道影响成功率和效率： </p><p>目标团队负责人直接找的人 &gt; 同事朋友推荐 &gt; 猎头 &gt; 自己网投 </p><p>为什么？ </p><p>1、减少沟通和考核成本 </p><p>2、增加员工稳定性 </p><p>3、降低招聘费用</p><p><strong>准备好简历</strong> </p><p>简历写多还是写少？打磨简历目的有二：筛简历时能存活，展示自己实力和经验。 </p><p>机会是留给有准备的人的。 </p><p>建议： </p><p>准备一份非常全的简历，再准备一份最简单的简历。 </p><p>如果自己有几个不同方向或领域的就业考虑，可以多做几个不同侧重的简历。 </p><p>每年不管怎么样，思考一下自己的职业发展，找前辈聊聊经验，更新自己的简历。 </p><p>工作年限越长，我其实一般情况建议简历越简单。</p><p><strong>准备好简历</strong> </p><p>简历怎么写？ 跟面试一样，守正出奇。 </p><p>建议： </p><p>1.扬长避短。不要直接写自己的短板和明显的缺点。人是感觉的动物，这是减分项。 </p><p>2.突出亮点。突出业绩。突出深度和思考，比如开源/博客/奖励，跟其他简历有区分度。 </p><p>3.找结合点。对公司和部门，进行充分的事先调研，把自己经历和能力里，最契合部门和 </p><p>JD需求的部分，加以详细描述。 </p><p>4.态度端正。简历结构清晰，描述逻辑性强，字体排版格式工整，没有错别字！ </p><p>&gt; 小技巧：可以把你对自己的整体评价和对职位的认知，写几句话放到简历的最前面或者 </p><p>是发送简历的邮件正文里。</p><p><strong>准备好简历</strong> </p><p>永远不要简历造假！ </p><p>长期来看，造假的后果，损失远大于收益。 </p><p>学历不好怎么办？ </p><p>实话实话，通过技术能力、职位匹配度等，弥补学历的短板。 </p><p>如果连续几个目标公司都对学历这一块有要求，那就去搞个更好的学历。 </p><p>想一想：为什么有些公司说我们卡学历?</p><h2 id="技术面试环节注意什么？"><a href="#技术面试环节注意什么？" class="headerlink" title="技术面试环节注意什么？"></a>技术面试环节注意什么？</h2><p><strong>准时参与+形象整洁</strong> </p><p>面试需要在短时间内体现出我们的专业能力和素养，尽量做加分项，不要减分项。 </p><p>候选人的准时与否，是给面试官和HR的第一印象。 </p><p>见面后的第一印象就是，候选人是不是你的形象是否OK？ </p><p>我们对面试官做培训时有个说法就是： </p><p>&gt; 如果技能都满足要求，你可以思考一下，你是否愿意跟候选人成为同事</p><p><strong>技术面试问什么</strong> </p><p>面试官能了解你的渠道有限： </p><p>简历、HR或前一轮面试官的反馈、你自己的陈述。 </p><p>一般来说，面试官着重会关注三个方面： </p><p>1、你简历里写的业务，技术，方法。 ==&gt; 个人价值 </p><p>2、招聘的这个岗位设计的业务，技术，方法。==&gt; 岗位价值 </p><p>3、面试官想从你身上挖掘的部分（很有可能是面试官自己比较熟悉的）。 ==&gt; 培养价值</p><p><strong>技术面试问什么</strong> </p><p>简历里个人经历的技术，业务，方法： </p><p>1、最重要的: 挑重点项目，整理清楚，理解透逻辑脉络，如果不行就背熟。 </p><p>2、所以提及的结论，都需要准备好案例或者数据来佐证你的说法，陈述可信。 </p><p>3、准备好几个处理过的比较重要技术问题，往往有奇效。 </p><p>4、描述一个事情，注意策略，先说大概，然后再沟通里往深里走。</p><p><strong>技术面试问什么</strong> </p><p>目标岗位相关的业务、技术和方法： </p><p>1、根据事先的准备和知识储备，讲自己的认识和理解。 </p><p>2、如果不清楚一些背景，可以让面试官给出补充细节和场景。 </p><p>3、可以穿插在对话过程，表示对目标业务/岗位/团队的认可。</p><p><strong>技术面试问什么</strong> </p><p>面试官发散和挖掘的部分： </p><p>1、引导话题，把各种不熟悉的，对应到你熟悉的部分； </p><p>2、实在不知道，大方的说出来，并要求对方给出线索和提示； </p><p>3、切记不要说一堆似是而非的话，非常减分。</p><p><strong>其他的几个技巧</strong> </p><p>1、可以背下来，一些常用话术，比如个人介绍部分，特长、兴趣爱好、优缺点等。 </p><p>2、永远不要跟面试官直接冲突，情商问题，你兼容他或他兼容你。 </p><p>3、不要因为个别问题，影响后面的面试发挥，心态稳定。 </p><p>4、有效利用面试官的“你有什么想问我的”？进一步的了解目标，以及对面试本身的反馈， </p><p>对面试过程中的一些技术的进一步讨论。 </p><p>5、如果有可能，可以尝试跟面试官加微信，并持续交流沟通，跟进面试。</p><h2 id="HR面试环节需要注意什么？"><a href="#HR面试环节需要注意什么？" class="headerlink" title="HR面试环节需要注意什么？"></a>HR面试环节需要注意什么？</h2><p><strong>HR看什么？</strong> </p><p>一般情况下，到HR面说明你基本得到用人部门的认可了，这时候主动权其实在你手里。 </p><p>HR就看两方面： </p><p>1、参考前面面试评价，给你的沟通/潜力/职业稳定性等方面一些附加评价； </p><p>2、跟你确定最终的offer，包括级别，薪水，福利。 </p><p>需要注意的是：大部分公司里，HR并没有否决权，所以第一条往往是虚的，真实情况是为 </p><p>了确定你的最终offer，帮用人部门把你争取到。</p><p><strong>怎么谈offer？</strong> </p><p>我们需要明确提出自己的offer要求，问清楚团队的职级划分和分步，薪资组成。 </p><p>不要等到offer那到手，发现薪水综合算起来，跟自己理想的有较大差距。 </p><p>不管HR跟你聊得多么融洽，本质上就是最后的定价。 </p><p>用最小的成本，来获得候选人的一个offer意向。 </p><p>按自己期望值报价即可，如果对方对薪酬的增幅有异议，尽量把自己的所有收益都计算在 </p><p>内：期权分红、各种费用和福利、加班补贴和倒休、补充医疗、额外的项目奖金等等。 </p><p>如果这么也列不出来，那么可以考虑用其他公司更高薪水的offer来佐证自己的开价。 </p><p>如果对方实在给不了，你又想去，可以再酌情给出适当让步，注意主动权在你。</p><p><strong>关于背调</strong> </p><p>很多同学跟我说，担心背调。 </p><p>只要不造假，背调都不会有什么问题。 </p><p>特别是让你自己填报信息的背调。</p><h2 id="拿到多个offer应该如何选择？"><a href="#拿到多个offer应该如何选择？" class="headerlink" title="拿到多个offer应该如何选择？"></a>拿到多个offer应该如何选择？</h2><p><strong>如果有多个offer，怎么选</strong> </p><p>这是一个两难选择。 </p><p>可以使用 SWOT 分析。 </p><p>需要注意的是，选哪一个，过几年都可能后悔，如果当初去了xx公司，怎么怎么样。 </p><p>那么，只要当下你依据自己所能获取的信息量，做了最适合你的选择就可以。</p><p><strong>如果有多个offer，怎么选</strong> </p><p>行业团队， </p><p>技术实力， </p><p>发展空间， </p><p>薪水福利。 </p><p>把这些所有你能想到的因素，列出来，重要性做个排序， </p><p>然后把不同offer的情况写下来。 </p><p>通过这么一个分析过程，也许你就知道了。<strong>总结</strong></p><p>今天我教了大家什么？</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐10:如何准备汇报、述职、晋升答辩?</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%9010:%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%B1%87%E6%8A%A5%E3%80%81%E8%BF%B0%E8%81%8C%E3%80%81%E6%99%8B%E5%8D%87%E7%AD%94%E8%BE%A9?/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%9010:%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%B1%87%E6%8A%A5%E3%80%81%E8%BF%B0%E8%81%8C%E3%80%81%E6%99%8B%E5%8D%87%E7%AD%94%E8%BE%A9?/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><p>第 +06 课 软实力培养 </p><h1 id="如何准备汇报、述职、晋升答辩？"><a href="#如何准备汇报、述职、晋升答辩？" class="headerlink" title="如何准备汇报、述职、晋升答辩？"></a>如何准备汇报、述职、晋升答辩？</h1><p>KimmKing </p><p>Apache Dubbo/ShardingSphere PMC</p><p><strong>目录</strong> </p><p>\1. 为什么展示工作成果非常重要？ </p><p>2.如何准备日常/项目工作汇报？ </p><p>3.如何准备转正/年终述职汇报？ </p><p>4.如何准备晋升答辩提高成功率？ </p><p>5.总结</p><h2 id="为什么展示工作成果非常重要"><a href="#为什么展示工作成果非常重要" class="headerlink" title="为什么展示工作成果非常重要"></a>为什么展示工作成果非常重要</h2><p><strong>酒香也怕巷子深</strong> </p><p>不能只低头走路，还要抬头看天，让别人看到你在前进 </p><p>职场上，首先团队的一员，然后才是自己 </p><p>为了自己，得到认可 </p><p>为了团队，争取利益 </p><p>一个非常不好的普遍现象： </p><p>*我的贡献/功劳/辛苦/努力，自己不说，大家也都能看到，领导也会记得我</p><p><strong>展示原则</strong> </p><p>基于事实，真实而不虚构 =&gt; 不可作假 </p><p>基于思考，拔高但不浮夸 =&gt; 提高认知 </p><p>基于分析，深刻而不平庸 =&gt; 突出优势 </p><p>基于需要，精炼不必全面 =&gt; 把握关键 </p><p>下面就日常汇报/无竞争、年底述职/有竞争、晋升答辩/强竞争三个常见场景聊聊。</p><h2 id="如何准备日常-项目工作汇报"><a href="#如何准备日常-项目工作汇报" class="headerlink" title="如何准备日常/项目工作汇报"></a>如何准备日常/项目工作汇报</h2><p><strong>日常汇报的关键在于对工作的控制能力</strong> </p><p>为什么需要日常汇报，甚至天天汇报？ </p><p>日常汇报是管理组织里最重要的一环。 </p><p>1、一个完整的研发组织架构下，信息和决策的基本依据 </p><p>2、通过汇报和反馈，持续调整发展策略 </p><p>3、跟踪项目发展，表明工作都是可控的</p><p><strong>怎么准备日常工作汇报</strong> </p><p>TODOLIST 工作法。 </p><p>每天早上，晚上，分别对今天的工作计划，今天的工作情况进行汇总。 </p><p>做到随时随地，可以直接说出来自己所有的重要工作任务： </p><p>1、整体的计划安排 </p><p>2、当前的进度情况 </p><p>3、跟各方的配合情况 </p><p>4、有什么问题和风险 </p><p>5、估计是不是能顺利完成 </p><p>6、当前看来跟预期是否有偏差</p><p><strong>怎么准备项目工作汇报</strong> </p><p>其实可以看到，前面就是对个人的 “项目管理”。 </p><p>对项目的话，可以采取的办法很多，简单来说，可以scrum或者采用进度跟踪表。 </p><p>项目四要素。进度跟踪表的计划、资源安排，进度问题、问题跟踪。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416145229.png" alt="image-20210416145229189"></p><p><strong>怎么做工作汇报</strong> </p><p>看汇报对象，补齐他人需要获得的信息。 </p><p>1、组内沟通沟通 </p><p>拉齐信息，告诉他们我们手上的工作情况事实即可。 </p><p>2、一线管理者/项目经理沟通 </p><p>反馈情况，了解新信息，提出问题和要求。 </p><p>3、向总监、部门经理、合作方经理，公司管理层汇报 </p><p>思考：需要注意什么，重点是什么？</p><p><strong>怎么做工作汇报–金字塔原理</strong> </p><p>当我们与人沟通时，需要想清楚3件事情： </p><p>谁是我的听众，他们想听什么，他们想怎样听？ </p><p>想清楚，说明白，知道说什么，怎么说。 </p><p>金字塔原理四原则 </p><p>a. 结论先行：每篇文章/演讲只有一个中心思想，并放在文章/演讲的最前面； </p><p>b. 以上统下：每一层次上的思想必须是对下一层次思想的总结和概括； </p><p>c. 归类分组：每一组中的思想必须属于同一逻辑范畴； </p><p>d. 逻辑递进：每一组中的思想必须按照逻辑顺序排列；</p><p><strong>怎么做工作汇报</strong> </p><p>可以尝试我经常要求团队用的一个办法： </p><p>1、准备一个全面的，用1-2个小时说清楚项目详细工作的材料； </p><p>2、准备一个15分钟说清楚项目大概轮廓的演讲； </p><p>3、准备一个3-5分钟只介绍项目核心要素和逻辑的演讲； </p><p>4、准备一个1分钟内，只说明项目价值和困难的说明。 </p><p>分别给谁讲？</p><h2 id="如何准备转正-年终述职汇报"><a href="#如何准备转正-年终述职汇报" class="headerlink" title="如何准备转正/年终述职汇报"></a>如何准备转正/年终述职汇报</h2><p><strong>转正/述职–有明确目标的汇报</strong> </p><p>锚定目标来准备即可。 </p><p>转正 ==&gt; 完成任务，满足要求，符合质量。 ==&gt; 预期。 </p><p>年终/半年述职 ==&gt; 锚定KPI/OKR ==&gt; 额外需要注意不低于平均水平。</p><p><strong>怎么做述职</strong> </p><p>如果有竞争，没有优势，或者KPI/OKR不是太好，怎么办? </p><p>① 给自己打分和评价，稍微往上打。 </p><p>② 找增量，找变化量，补充到工作里。 </p><p>③ 找自己工作价值最大化的点，用于佐证自己的打分。 </p><p>④ 通过述职汇报，证明自己值得自己打的分数。 </p><p>==&gt; 跟面试准备是一个道理。</p><h2 id="如何准备晋升答辩提高成功率"><a href="#如何准备晋升答辩提高成功率" class="headerlink" title="如何准备晋升答辩提高成功率"></a>如何准备晋升答辩提高成功率</h2><p><strong>正确认识晋升答辩</strong> </p><p>晋升答辩是晋升过程中最重要的一环。 </p><p>有多因素会影响对晋升答辩的效果。 </p><p>1、评委较多，有些不熟悉你和你做的事儿； </p><p>2、竞争激烈，只有极少数人能成功； </p><p>3、自己和团队的成绩，影响力； </p><p>4、自己当时的具体表现，，，等等。 </p><p>本质上说，就是一场面试，一场你和别人，你团队和别团队的战争。</p><p><strong>答辩不是唯一因素，但是是必要因素</strong> </p><p>一般情况下，你答辩表现的不好，很可能会失败。 </p><p>答辩的好与不好，不在于你讲了多少技术，多少成果。 </p><p>而在于，你做的这些事儿，从评委角度来看，价值多大。 </p><p>而评委是不同的背景，让大家都觉得有很大价值。 </p><p>所以，对于价值是需要有统一的认识和衡量的。 </p><p>提前准备好，从不同角度来看，你说的都有很大价值。 </p><p>最好是：非你不可。</p><p><strong>答辩不是唯一因素，但是是必要因素</strong> </p><p>晋升答辩，建议做2-3次演练。 </p><p>讲熟悉，讲的过程，会发现一些平时没注意的细节，需要补充和完善。 </p><p>让同事和领导，提出意见，挑战你。 </p><p>聚焦： </p><p>越是关键的演讲和面试，越要去掉哪些可有可无的东西， </p><p>把时间精力和重点，放到最核心和最有价值的东西上。 </p><p>提前适应，稳定心态。</p><p><strong>从多个角度准备</strong> </p><p>思考一下，晋升成功，需要哪些必要因素： </p><p>1、工作和成绩，要达标 ~ 30% </p><p>2、个人和团队，特别是你leader的人缘 ~ 30% </p><p>3、个人的准备和演讲 ~ 40% </p><p>怎么从这些角度思考和去争取。</p><p><strong>总结</strong></p><p>今天我教了大家什么？</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐9:soul网关源码学习答疑</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%909:soul%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AD%94%E7%96%91/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%909:soul%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AD%94%E7%96%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐8:夯实Java基础：常见类与常见错误</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%908:%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%B1%BB%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%908:%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%B1%BB%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐7:一封迷茫小同学的来信</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%907:%E4%B8%80%E5%B0%81%E8%BF%B7%E8%8C%AB%E5%B0%8F%E5%90%8C%E5%AD%A6%E7%9A%84%E6%9D%A5%E4%BF%A1/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%907:%E4%B8%80%E5%B0%81%E8%BF%B7%E8%8C%AB%E5%B0%8F%E5%90%8C%E5%AD%A6%E7%9A%84%E6%9D%A5%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐6.工作软实力</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%906.%E5%B7%A5%E4%BD%9C%E8%BD%AF%E5%AE%9E%E5%8A%9B/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%906.%E5%B7%A5%E4%BD%9C%E8%BD%AF%E5%AE%9E%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐5.分布式事务</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%905.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%905.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐4.Soul网关源码解析</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%904.Soul%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%904.Soul%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐2:并发编程、锁和AQS以及工作和学习方法</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%902:%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%81%E9%94%81%E5%92%8CAQS%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%902:%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%81%E9%94%81%E5%92%8CAQS%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐3.聊聊开源与如何深入思考问题</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%903.%E8%81%8A%E8%81%8A%E5%BC%80%E6%BA%90%E4%B8%8E%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%903.%E8%81%8A%E8%81%8A%E5%BC%80%E6%BA%90%E4%B8%8E%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加餐1.软实力培养：工作与学习方法</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%901.%E8%BD%AF%E5%AE%9E%E5%8A%9B%E5%9F%B9%E5%85%BB%EF%BC%9A%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%8A%A0%E9%A4%901.%E8%BD%AF%E5%AE%9E%E5%8A%9B%E5%9F%B9%E5%85%BB%EF%BC%9A%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><h1 id="第-01-课-软实力培养"><a href="#第-01-课-软实力培养" class="headerlink" title="第 +01 课 软实力培养"></a>第 +01 课 软实力培养</h1><p>工作与学习方法 </p><p>KimmKing Apache Dubbo/ShardingSphere PMC</p><p><strong>目录</strong> </p><p>1.TODO LIST工作法 </p><p>2.学习与记忆的基础</p><h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO LIST"></a>TODO LIST</h2><p><strong>为什么要TODO LIST</strong></p><p>\1. 记不住 </p><p>\2. 拎不清 </p><p>\3. 被打断 </p><p>TODOLIST 原理就像是CPU时间片 </p><p>1、事件 </p><p>2、状态 </p><p>3、优先级 </p><p>==》 进展</p><p><strong>为什么要**</strong>TODO LIST** </p><p>番茄工作法 </p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416143159.png" alt="image-20210416143158964" style="zoom:33%;"><p>有效的时间管理 </p><p>养成习惯</p><p><strong>TODO LIST</strong> <strong>工具</strong> </p><p>我自己用过的： </p><p>1、wunder list ==》最好用 </p><p>2、Microsoft To-Do(微软待办) </p><p>3、note笔记（evernote、youdao、wiznote等等） ==》最综合 </p><p>4、markdown文件自己记 </p><p>5、excel文件 </p><p>6、直接手写 ==》 最有感觉 </p><p>跟git一样</p><p><strong>TODO LIST</strong> <strong>工具</strong> </p><p>我自己用过的： </p><p>1、wunder list ==》最好用 </p><p>2、Microsoft To-Do(微软待办) </p><p>3、note笔记（evernote、youdao、wiznote等等） ==》最综合 </p><p>4、markdown文件自己记，github issue也可以哦 </p><p>5、excel文件 </p><p>6、直接手写，台账 ==》 最有感觉 </p><p>跟git一样</p><p><strong>TODO LIST</strong> <strong>工具</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416143224.png" alt="image-20210416143224893"></p><p>学习与记忆</p><p><strong>学习是一个爬坡的过程，且反人性</strong></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416144835.png" alt="image-20210416144835095" style="zoom:33%;"><p><strong>学习没有捷径，但是有技巧</strong> </p><p>会了就是会了，不会就是不会。 </p><p>归纳抽象 –&gt; 逻辑演绎 </p><p>1、找内在规律，构建知识体系，建立深层次连接 </p><p>2、用个人技巧，变陌生为熟悉，建立浅层次记忆 </p><p>时常总结</p><p><strong>现学现用</strong> </p><p>现场教大家一个记忆的方法</p><p><strong>为什么知识体系很重要</strong> </p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416144855.png" alt="image-20210416144855956" style="zoom:33%;"><p>\1. 数据：原始的信息 </p><p>\2. 信息：加工组织过的数据 </p><p>\3. 知识：对信息的理解，因果关联 </p><p>\4. 洞见：对知识结构有独特的理解，形成 </p><p>闪光点，对未来的判断 </p><p>\5. 智慧：运用知识、经验、理解、常识和 洞见进行思考与行动的能力 </p><p>\6. 影响力：影响力能放大智慧 </p><p>==》 自己树立知识，做脑图，找关联</p><p><strong>为什么参与、实践很重要</strong></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416144915.png" alt="image-20210416144915881" style="zoom:33%;"><p><strong>总结</strong></p><p>今天我教了大家什么？</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week15-02 第 30 课架构师修炼之道--如何升级打怪终成一线技术专家</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week15-02%20%E7%AC%AC%2030%20%E8%AF%BE%E6%9E%B6%E6%9E%84%E5%B8%88%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93--%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%E6%89%93%E6%80%AA%E7%BB%88%E6%88%90%E4%B8%80%E7%BA%BF%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week15-02%20%E7%AC%AC%2030%20%E8%AF%BE%E6%9E%B6%E6%9E%84%E5%B8%88%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93--%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%E6%89%93%E6%80%AA%E7%BB%88%E6%88%90%E4%B8%80%E7%BA%BF%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><p>第 30 课 </p><h1 id="架构师修炼之道–如何升级打怪终成一线技术专家"><a href="#架构师修炼之道–如何升级打怪终成一线技术专家" class="headerlink" title="架构师修炼之道–如何升级打怪终成一线技术专家"></a>架构师修炼之道–如何升级打怪终成一线技术专家</h1><p>KimmKing </p><p>Apache Dubbo/ShardingSphere PMC</p><p><strong>个人介绍</strong> </p><p>Apache Dubbo/ShardingSphere PMC </p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人 </p><p>阿里云 MVP、腾讯 TVP、TGO 会员 </p><p>10 多年研发管理和架构经验 </p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong> </p><ol><li>程序员升级打怪之路 </li></ol><p>2.夯实自身硬实力技能 </p><p>3.培养个人全面软实力 </p><p>4.努力成为更好的自己 </p><p>5.总结回顾与作业实践</p><h2 id="第-30-课-1-程序员升级打怪之路"><a href="#第-30-课-1-程序员升级打怪之路" class="headerlink" title="第 30 课 1. 程序员升级打怪之路"></a>第 30 课 1. 程序员升级打怪之路</h2><p><strong>技术道路没有捷径</strong></p><p>以我自己的个人发展经历为例…</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074307.png" alt="image-20210416074307240"></p><p><strong>Java 程序员的职业发展</strong> </p><p>应届毕业生 </p><p>.NET/PHP程序员 </p><p>转行人员 </p><p>其他情况 </p><p>核心研发 </p><p>架构师 </p><p>技术经理 </p><p>研发leader </p><p>技术专家 </p><p>技术总监 </p><p>研发总监 </p><p>架构总监 </p><p>高级总监 </p><p>技术部门总经理 </p><p>技术VP </p><p>CTO </p><p><strong>成为优秀技术人才</strong> </p><p>积累了足够多的技术实力 </p><p>某个领域具有足够的深度 </p><p>解决复杂问题，独当一面 </p><p>不断从实践中学习新技能 </p><p>用过往经验提升团队能力 </p><p>=&gt; T 型综合性人才 </p><p>加入大厂，获得更好发展机会</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074337.png" alt="image-20210416074337475"></p><p><strong>能力模型</strong> </p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074354.png" alt="image-20210416074354561" style="zoom:25%;"><p>技术能力</p><p>架构能力</p><p>业务能力 </p><p>软实力</p><p><strong>架构师做什么</strong> </p><p><strong>定义</strong>：项目里或组织里对技术决策负责的角色。也可以细分为系统架构师、 应用架构师、企业架构师等。 </p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074414.png" alt="image-20210416074414950" style="zoom:33%;">    <p><strong>问题</strong>：搭建一个SSH\SSM框架的技术人员，算不算是一名架构师呢？ </p><p><strong>一般职责</strong>： </p><p>①技术规划与重大决策 </p><p>②技术选型与新技术引入 </p><p>③技术难点的解决与问题排查 </p><p>④技术工具与基础设施的实现与维护 </p><p>⑤技术创新类工作 </p><p>⑥技术人才的引入与培养 </p><p>⑦技术规范相关标准的制定与监督 </p><p>⑧技术相关指标的定义与度量 </p><p>⑨重点项目的架构设计 </p><p>⑩测试与运维、安全等领域的技术支持等</p><h2 id="第-30-课-2-夯实自身硬实力技能"><a href="#第-30-课-2-夯实自身硬实力技能" class="headerlink" title="第 30 课 2. 夯实自身硬实力技能"></a>第 30 课 2. 夯实自身硬实力技能</h2><p><strong>六大硬实力</strong> </p><p>\1. 技术能力，技术人员的核心竞争力 </p><p>\2. 设计能力，通过设计解决问题 </p><p>\3. 抽象能力，提升思维和认知层次 </p><p>\4. 管理能力，管理自我，管理他人 </p><p>\5. 结构化思维能力，细化问题，弄清楚问题 </p><p>\6. 系统化分析能力，深度思考问题，第一性原理 </p><p><strong>六大硬实力</strong> </p><p>技术能力 、设计能力 、抽象能力</p><p>通过技术手段，推动业务发展。 </p><p>支撑业务实现 -&gt; 推动业务发展 -&gt; 优化改进业务 </p><p>本课程的前9个部分。 </p><p>四级/五级流程法。 </p><p><strong>六大硬实力</strong> </p><p>结构化思维能力 、管理能力 、系统化分析能力</p><p>高效的做事。 </p><p>对人，对事儿。 </p><p>过程，结果。从定性到定量。 </p><p>《管理的常识》《卓有成效的管理者》《领导梯队》 </p><p>《金字塔原理》 </p><p>《系统化思维导论》 </p><h2 id="第-30-课-3-培养个人全面软实力"><a href="#第-30-课-3-培养个人全面软实力" class="headerlink" title="第 30 课 3. 培养个人全面软实力"></a>第 30 课 3. 培养个人全面软实力</h2><p><strong>七大软实力</strong> </p><p>\1. 大局观能力：提升一个层级看问题 </p><p>\2. 沟通协作能力：事半功倍解决问题，推动任务 </p><p>\3. 持续学习能力：更新知识结构，引入新的办法 </p><p>\4. 专注力：专注事物本质，积累深入，做到极致 </p><p>\5. 探索力：对新事物保持好奇心，接受新思维 </p><p>\6. 决策力：勇于做出分析和决策，推动发展 </p><p>\7. 自我驱动力：外因的驱动都无法持久 </p><p><strong>七大软实力</strong> </p><p>大局观 、沟通协作 、持续学习</p><p>提升自己，自我进化 </p><p>通过更全面的内部外认知，信息的有效传递和补充 </p><p>《非暴力沟通》 </p><p><strong>七大软实力</strong> </p><p>专注力 、探索力 、决策力 、自我驱动力</p><p>保持长期有效发展的基础 </p><p>更深一层次的要求 </p><h2 id="第-30-课-4-努力成为更好的自己"><a href="#第-30-课-4-努力成为更好的自己" class="headerlink" title="第 30 课 4. 努力成为更好的自己"></a>第 30 课 4. 努力成为更好的自己</h2><p><strong>积累知识，积点成面</strong> </p><p>知识必须要体系化，行为一个完整的结构。 </p><p>甚至，思考任何问题，分析任何问题，都要考虑用一个良好的结构化思路。 </p><p>积累，可以复用。</p><p><strong>学以致用，创造价值</strong> </p><p>不创造价值的知识，本身就没有价值。 </p><p>如果我们认识不到它的价值，说明我们思考的不够深入。</p><p><strong>走出技巧，关注方案</strong> </p><p>工作和学习的过程中，逐渐的走出对技巧的外在追求， </p><p>更关注于，如何解决问题，如何更好的解决问题， </p><p>这个办法/方案/知识/工具，还可以解决哪些类似问题。 </p><p>搞清楚问题，永远比稀里糊涂解决了问题，更重要。</p><p><strong>方法重要，胜过细节</strong> </p><p>好的方法是逐渐培养和形成的。 </p><p>不同人，对于适合自己的方法，也不尽相同。 </p><p>找到最适合自己的，高效方法。 </p><p>细节是魔鬼，需要的时候再去跟魔鬼斗争。</p><p><strong>关注他人，影响团队</strong> </p><p>这个时代不是一个人的英雄主义时代。 </p><p>关注他人，影响他人，将自己的能力，通过团队放大。 </p><p>建立自己的影响力。</p><p><strong>养成习惯，终身学习</strong> </p><p>四句口诀： </p><p>善用时间管理， </p><p>构建知识体系， </p><p>实践积累经验， </p><p>终身持续学习。 </p><p>很多技术背后的原理都是相通的，学习本身具有飞轮效应。 </p><p>善于复盘，在每一段经历中得到锻炼和成长。 </p><p>每天进步一点点。</p><h2 id="第-30-课-5-总结回顾与作业实践"><a href="#第-30-课-5-总结回顾与作业实践" class="headerlink" title="第 30 课 5.总结回顾与作业实践"></a>第 30 课 5.总结回顾与作业实践</h2><p><strong>第 30 课总结回顾</strong></p><p><strong>关注和思考职业发展</strong> </p><p><strong>夯实自身硬实力技能</strong> </p><p><strong>培养全面个人软实力</strong> </p><p><strong>努力成为更好的自己</strong></p><p><strong>第 30 课作业实践</strong> </p><p>1、（选做）分析自己的硬实力和软实力，总结自己的优缺点，正视自己并思考改进。 </p><p>2、（选做）针对自己的分析，规划自己未来1年、2年、3年、5年的职业发展。 </p><p>3、（选做）分别用100个字以上的一段话，加上一幅图（架构图或脑图），总结自己 </p><p>对下列技术的关键点思考和经验认识： </p><p>1）JVM </p><p>2）NIO </p><p>3）并发编程 </p><p>4）Spring和ORM等框架 </p><p>5）MySQL数据库和SQL </p><p>6）分库分表 </p><p>7）RPC和微服务 </p><p>8）分布式缓存 </p><p>9）分布式消息队列 </p><h1 id="机会永远是留给有准备的人"><a href="#机会永远是留给有准备的人" class="headerlink" title="机会永远是留给有准备的人"></a><strong>机会永远是留给有准备的人</strong></h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week15-01 第 29 课 业务系统重构--分享一个真实的重构案例</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week15-01%20%E7%AC%AC%2029%20%E8%AF%BE%20%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84--%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E9%87%8D%E6%9E%84%E6%A1%88%E4%BE%8B/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week15-01%20%E7%AC%AC%2029%20%E8%AF%BE%20%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84--%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E9%87%8D%E6%9E%84%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><p>第 29 课 </p><h1 id="业务系统重构–分享一个真实的重构案例"><a href="#业务系统重构–分享一个真实的重构案例" class="headerlink" title="业务系统重构–分享一个真实的重构案例"></a>业务系统重构–分享一个真实的重构案例</h1><p>KimmKing </p><p>Apache Dubbo/ShardingSphere PMC</p><p><strong>个人介绍</strong> </p><p>Apache Dubbo/ShardingSphere PMC </p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人 </p><p>阿里云 MVP、腾讯 TVP、TGO 会员 </p><p>10 多年研发管理和架构经验 </p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong> </p><ol><li>A系统的现状和问题 </li></ol><p>2.如何推动重构A系统 </p><p>3.重构的目标和方式 </p><p>4.重构的过程和结果 </p><p>5.对于本次重构的复盘 </p><p>6.总结回顾与作业实践</p><h2 id="第-29-课-1-A系统的问题与现状"><a href="#第-29-课-1-A系统的问题与现状" class="headerlink" title="第 29 课 1. A系统的问题与现状"></a>第 29 课 1. A系统的问题与现状</h2><p><strong>A系统的背景</strong> </p><p>业务上：从杭州刚挪到北京，作为重新孵化项目，想要做大做强。行业竞争压力非常之 大，做不出成绩，就是生与死的问题。 </p><p>技术上：遗留的老系统，再一起其他系统的基础上改的单体，团队拥抱变化，换手了4 次以上，找不到一个做过这个系统的人了。 </p><p>关系上：北京新业务定位是新业务的创新和孵化，这是一个大项目，也是要树立标杆的 项目。</p><p><strong>A系统的问题</strong> </p><p>当时我写的一封邮件，说的相对委婉： </p><p>国内机票旧系统开发于2006年，期间几十名开发人员在代码里留下了痕迹。不久前移 交到北京新业务研发团队维护，主要问题有： </p><p>1、代码量大(40万行)，质量不高，结构复杂，难以修改和维护。一些代码的具体作用 和逻辑细节，没有人清楚。很多注释和代码不一致，文档缺乏，比较混乱。 </p><p>2、业务处理过程逻辑复杂，中间数据冗余，与外部接口耦合度高，性能较差，稳定性 不高，扛不住大促活动压力。 </p><p>3、对业务过程的数据和状态监控不足，难以管理控制和跟踪，各方使用不方便。 </p><p>4、刚交接过来，没有人真正懂这个系统的业务，业务方也是空降，这个问题尤其严重。</p><p><strong>重构面临的压力和选择</strong> </p><p>其实当时看来，重做是最好的路线，但不现实： </p><p>业务方：<em>不能停止业务发展，死路一条</em> </p><p>开发方：没有太多资源，也经不起折腾，半年后大促</p><h2 id="第-29-课-2-如何推动重构A系统"><a href="#第-29-课-2-如何推动重构A系统" class="headerlink" title="第 29 课 2. 如何推动重构A系统"></a>第 29 课 2. 如何推动重构A系统</h2><p><strong>核心矛盾点在哪里？</strong> </p><p>这是一个很常见的矛盾点： </p><p>业务不认可重做/重构，伤筋动骨。 </p><p>一提就说：反正系统还能用。 </p><p>重做周期太长，成本太大。 </p><p>重构不带来业务价值，步子大了也会影响业务。 </p><p>祖传屎山，维护不易。<strong>对于业务方</strong> </p><p>业务上： </p><p>必须要稳定推动业务发展，快速加功能，开发营销促销系统，不然被对手越拉越大。 </p><p>核心要求： </p><p>1、业务不停 </p><p>2、保障稳定 </p><p>3、提升性能 </p><p>4、快速开发<strong>对于产品方</strong> </p><p>产品上： </p><p>提升用户体验，跟竞品在产品层面拉齐，多对接航司和第三方，引流，打通各方。 </p><p>核心点： </p><p>1、用户体验 </p><p>2、改版引流 </p><p>3、同业务方</p><p><strong>对于开发方</strong> </p><p>技术上： </p><p>最大问题是，资源不够。 </p><p>最少的资源，最大满足业务和产品需求，同时能够发展北京研发团队。</p><p><strong>最终达成一致</strong> </p><p>各方妥协，但是研发肯定是压力最大的。 </p><p>不用怕，临危受命的同时，可以提要求，定规则。 </p><p>不停机，发展业务，改进体验，都没问题。 </p><p>本着这个大目标，要求按我们的安排来。 </p><p>1、所有其他项目为这个项目让路，优先级P0，（后来改成-1） </p><p>2、资源主要用来保障这个项目，所有人配合，包括后面招聘的 </p><p>3、人员管理等方面，特事特办，所有人不管考勤等制度</p><h2 id="第-29-课-3-重构的目标和方式"><a href="#第-29-课-3-重构的目标和方式" class="headerlink" title="第 29 课 3. 重构的目标和方式"></a>第 29 课 3. 重构的目标和方式</h2><p><strong>怎么定重构目标？</strong> </p><p><em>平衡短期利益和长期利益</em>。 </p><p>分阶段，先重构搜索模块，然后是订单交易、产品库存。 </p><p>国内机票搜索重构启动于6月底，经过近两个月的紧张开发，于8月底完成开发并提测， </p><p>目前进入测试和准备上线阶段。 </p><p>预计上线后，能带来更高的性能(+30%以上)，更好的用户体验(数据的准确性、缓存策 </p><p>略)，更好的代码质量与扩展性(更易于日常维护和添加功能)，更好的监控和管理(at- </p><p>eye)。 </p><p>为国内机票年底的双12大促(预期投入一亿费用)，做好最充足最全面的准备。</p><p><strong>怎么定重构目标？</strong> </p><p>国内机票搜索重构的目标主要有五个： </p><p>1、培养机票新人。梳理清楚国内机票搜索部分的业务和各种潜规则，培养懂机票的新 </p><p>人。</p><p>2、提高代码质量。设计更合理，结构更清晰更易维护，系统耦合更低、扩展性更高。 </p><p>3、提升搜索性能。使系统更稳定，更高效，搜索更快，资源消耗更低，大促不宕机。 </p><p>4、监控搜索过程。统一管理搜索过程中的各种开关和参数调整，管理缓存，跟踪搜索 </p><p>步骤。 </p><p>5、国内机票搜索去oracle化。 在搜索重构的过程中，用mysql代替旧系统的oracle数 </p><p>据库。<strong>目标的具体说明</strong> </p><p>① 培养新人问题，主要是XX\XX\XXX\XXXX。在此过程中，熟悉淘宝技术体系和开发 </p><p>过程，掌握国内机票业务，能逐步的cover机票系统。 </p><p>② 代码质量问题，主要是项目结构合理的分层，搜索的分段式处理，code review，高 </p><p>覆盖率的单元测试，使项目易懂易上手易维护。 </p><p>③ 提升性能方面，主要从简化中间结果和数据结构，理清业务简化旧逻辑，整理各步 </p><p>骤缓存最大化合理利用缓存结果三个方向来提升系统在CPU计算和内存、以及网络 </p><p>IO等方面的开销。提高系统吞吐量、QPS，降低响应时间。 </p><p>④ 监控搜索过程，通过哈勃、timetunnel+ateye、memlog、系统log等手段埋点，管 </p><p>理系统多种粒度的开关和参数设置，跟踪和调试搜索流程中的数据和状态、各种外 </p><p>部接口数据和缓存。 </p><p>⑤ 去Oracle，改用mysql+tddl，实现分库分表，为进一步的分布式架构打下基础。</p><p><strong>重构的组织方式</strong> </p><p>三个要点： </p><p>\1. 小黑屋主力，核心+全流程 </p><p>\2. 其他后备力量，业务模块+迭代周期 </p><p>\3. 开发期间，试行996(全部算倒休)，抢在年底大促前搞定三期重构</p><h2 id="第-29-课-4-重构的过程和结果"><a href="#第-29-课-4-重构的过程和结果" class="headerlink" title="第 29 课 4. 重构的过程和结果"></a>第 29 课 4. 重构的过程和结果</h2><p><strong>重构怎么做–规划、启动</strong> </p><p>确定规划，分步改造 </p><p>启动项目，拉齐思想</p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074100.png" alt="image-20210416074100891" style="zoom:50%;"><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074116.png" alt="image-20210416074116402"></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074125.png" alt="image-20210416074125861" style="zoom:50%;"><p><strong>重构怎么做–明确业务</strong> </p><p>1、重建业务需求文档。 </p><p>需求是一切的起始点。 </p><p>2、如何保障业务不停？ </p><p>架构层面的设计，与产品方达成一致。</p><p><strong>重构怎么做–架构调整</strong> </p><p>分层改造和逐步对接，借鉴与微软的outlook团队的案例。 </p><p>这在当时是一个很大的冒险。 </p><p>例如，页面的改版需求，我们顺带着把一些后端的业务逻辑，代码结构，数据库都改掉 </p><p>了。</p><p>在一个需求周期内，搭车业务需求，做技术改造。<strong>重构怎么做–性能优化</strong> </p><p>从优化业务处理角度。同步大事务到小事务，异步处理。 </p><p>从优化系统代码角度。一个8层for循环的例子。 </p><p>从优化数据结构角度。笛卡尔积的例子，一次请求500M内存。 </p><p>从优化缓存策略角度，从静态有效期到动态有效期。</p><p><strong>重构怎么做–引入标准</strong> </p><p>借鉴之前的ESB经验，解决对接的复杂性问题，标准化集成方式。 </p><p>不同航司的接口，差异非常大，数据结构不同，数据的有效性不同。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074200.png" alt="image-20210416074200531"></p><p><strong>重构怎么做–灰度发布</strong> </p><p>通过灰度开发+特性开关，保障可靠上线。 </p><p>先是预发环境上线，办公室内访问， </p><p>然后线上灰度，公司内部IP访问， </p><p>再接着杭州和北京访问， </p><p>最后全国可以访问，完全放开。</p><p><strong>重构怎么做–监控运维</strong> </p><p>实现一套全方位的运维系统，快速发现和处理问题。 </p><p>实现线上开关和debug的机制，快速定位问题。 </p><p>对每天的业务数据进行自动统计和发邮件，做到所有人对业务情况了然于心。</p><p><strong>项目的效果</strong> </p><p>业务上，支持了大量新功能，包括营销促销系统。 </p><p>技术上，重构了新系统，完成了去O和分库分表，保证了大促。 </p><p>产品上，优化了用户体验，补齐了系统的各项短板。 </p><p>团队上，培养了一批懂业务，懂新系统底层的研发核心人员。 </p><p>新系统文档完善，架构先进，代码只有旧系统的1/3不到，性能提升30倍。 </p><p>&gt; 做减法比加法难。 </p><p>此外，在新架构的基础上，打通了各个业务线。 </p><p>后来我又负责了其他系统的重构，旅行线业务统一项目，关联销售项目等。</p><h2 id="第-29-课-5-对本次重构的复盘"><a href="#第-29-课-5-对本次重构的复盘" class="headerlink" title="第 29 课 5. 对本次重构的复盘"></a>第 29 课 5. 对本次重构的复盘</h2><p><strong>复盘总结</strong> </p><p>为什么要做重构？ </p><p>重构的难点是什么？ </p><p>重构要做哪些事儿？ </p><p>怎么解决重构过程的各种问题？ </p><p>怎么保证重大改造的稳定上线？</p><p><strong>一个彩蛋</strong> </p><p>机票的数据迁移。</p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416074221.png" alt="image-20210416074221922" style="zoom:33%;"><h2 id="第-29-课-6-总结回顾与作业实践"><a href="#第-29-课-6-总结回顾与作业实践" class="headerlink" title="第 29 课 6.总结回顾与作业实践"></a>第 29 课 6.总结回顾与作业实践</h2><p><strong>第 29 课总结回顾</strong></p><p><strong>项目的现状和问题</strong> </p><p><strong>如何推动项目重构</strong> </p><p><strong>重构具体要怎么做</strong> </p><p><strong>重构的结果和思考</strong></p><h2 id="第-29-课作业实践"><a href="#第-29-课作业实践" class="headerlink" title="第 29 课作业实践"></a><strong>第 29 课作业实践</strong></h2><p>1、（选做）学习《重构–改善既有代码的设计》这本书，写读书笔记。 </p><p>2、（选做）对于目前自己维护的项目代码，思考如何改善设计和实现。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week14-02 第 28 课 分布式系统架构--如何设计一个秒杀系统</title>
      <link href="2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week14-02%20%E7%AC%AC%2028%20%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84--%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/04/15/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week14-02%20%E7%AC%AC%2028%20%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84--%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><p>第 28 课 </p><h1 id="分布式系统架构–如何设计一个秒杀系统"><a href="#分布式系统架构–如何设计一个秒杀系统" class="headerlink" title="分布式系统架构–如何设计一个秒杀系统"></a>分布式系统架构–如何设计一个秒杀系统</h1><p>KimmKing </p><p>Apache Dubbo/ShardingSphere PMC</p><p><strong>个人介绍</strong> </p><p>Apache Dubbo/ShardingSphere PMC </p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人 </p><p>阿里云 MVP、腾讯 TVP、TGO 会员 </p><p>10 多年研发管理和架构经验 </p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong> </p><ol><li>从架构师视角出发 </li></ol><p>2.具体要做哪些事情 </p><p>3.功能性和非功能性 </p><p>4.如何编写设计文档 </p><p>5.如何考虑技术选型 </p><p>6.其他相关设计要点 </p><p>\7. 总结回顾与作业实践</p><h2 id="第-28-课-1-从架构师视角出发"><a href="#第-28-课-1-从架构师视角出发" class="headerlink" title="第 28 课 1. 从架构师视角出发"></a>第 28 课 1. 从架构师视角出发</h2><p><strong>像架构师一样思考问题</strong> </p><p>为什么要做秒杀？ </p><p>为什么秒杀难做？ </p><p>第一性原理：秒杀的本质到底是什么？</p><p><strong>秒杀的本质</strong> </p><p>业务上：一场营销促销活动，具有明确的活动业务特点 </p><p>技术上：一种主动DDos攻击，具备技术的不确定性和复杂度</p><p><strong>早期的秒杀怎么做</strong> </p><p>早期的单体系统，不具备很好的扩展性，一有突发流量就挂。 </p><p>那么如何实现抗住较大的突发压力呢？ </p><p>最开始大家是真不知道，摸石头过河。 </p><p>大促宕机时常态。</p><p><strong>技术上有哪些优化办法</strong> </p><p>1.丢弃订单：最早期，量太大扛不住，直接前端随机reject一些，返回给抢单失败，简 单粗暴，但是有效，比如10万人抢100个iPhone，只要能提前预测有大概1万以上的人 参与（通过资格确认、报名等方式收集信息），那么直接请求进来以后随机挡回去 99%的流量都没有啥问题。 </p><p>2.优化吞吐：中间有段时间，提前准备一大批机器，服务化、分库分表搞定后端性能， 让前端业务可以加一定量的机器，然后搞稳定性，依赖关系，容量规划，做弹性，提升 吞吐量。 </p><p>3.异步队列：然后就是使用可堆积的消息队列或者内存消息队列了，如果抢单具有强顺 序，那么先都进队列，然后拿前N（就是库存数）个出来平滑处理，剩下的所有都可以 作为失败进行批处理了，甚至还可以做一个定长的队列，再往里写直接提示失败。队列 把并发变成串行，从而去掉了锁。</p><p>4.内存分配：一些具体的业务，也会考虑预热，提前在每个机器节点内存分配好库存数 量，然后直接在内存里处理自己的库存数即可，这样可能也会在极端情况下啊， </p><p>5.拆分扩展：针对不同类型、不同商家、不同来源的商品，部署不同的前端促销集群， 这样就把压力分散开了。具体到每个商家，其实量就不大了，双十一销售第一名的商家， 并发也不是特别高。 </p><p>6.服务降级：越重要的抢单，大家越关心自己有没有抢到，而不是特别在意订单立即处 </p><p>理完，也就是说，下单占到位置比处理完成订单要更有价值。比如12306春运抢票，只要告诉用户你抢到了票，但是预计1个小时后订单才会处理完，用户有这个明确预期， 就可以了，用户不会立马使用这张票，也不会在意1分钟内处理完还是1小时处理完。需要注意的是其中部分模式会导致销售不足或者超卖，销售不足可以从抢购里加一些名单补发，也可以加一轮秒杀。超卖比较麻烦，所以一般会多备一点货，比如抢100个iPhone，提前准备105个之类的，也会证明在实际操作里非常有价值。</p><p><strong>系统设计上的改进和优化</strong> </p><p>将营销促销活动，从交易业务系统里剥离出来，成为独立的系统。 </p><p>促销活动：满减，满赠，折扣等。 </p><p>业务因素：用户范围，商品范围，使用时限，发放形式，还是账务相关、预算与核销等。 </p><p>其他： </p><p>• 优惠券 </p><p>• 红包 </p><p>• 积分 </p><p>秒杀业务本质上是一个特殊的折扣活动。</p><h2 id="第-28-课-2-具体要做哪些事情"><a href="#第-28-课-2-具体要做哪些事情" class="headerlink" title="第 28 课 2. 具体要做哪些事情"></a>第 28 课 2. 具体要做哪些事情</h2><p><strong>做系统架构设计的步骤</strong> </p><p>1、分析现状 </p><p>1.1 明确具体需求。特别是要挖掘和明确非功能性需求。 </p><p>1.2 分析可行性。明确可行性与相关技术指标。 </p><p>2、寻找路径 </p><p>2.1 实现整体方案设计。 </p><p>2.2 完成POC验证和关键技术选型。 </p><p>3、确定方案 </p><p>3.1 根据分析设计出最终方案，并与各方达成一致。 </p><p>3.2 完善方案相关设计图和文档，成为项目研发的蓝图。</p><p><strong>做系统架构设计的步骤</strong> </p><p>1、分析现状 </p><p>产出：新需求文档，系统当前现状（包括业务和技术指标）的相关文档和设计图，可行 性分析文档。 </p><p>2、寻找路径 </p><p>产出：设计方案初稿，关键问题分析，关键技术选型报告，POC验证的场景设计文档 和DEMO，测试/压测结果等。 </p><p>3、确定方案 </p><p>产出：架构设计方案和设计图终稿，组织会议同步和宣贯。</p><h2 id="第-28-课-3-功能性与非功能性需求"><a href="#第-28-课-3-功能性与非功能性需求" class="headerlink" title="第 28 课 3. 功能性与非功能性需求"></a>第 28 课 3. 功能性与非功能性需求</h2><p><strong>功能性需求</strong> </p><p>商家：上架秒杀商品和库存，定义活动规则。 </p><p>平台：(自营的话，不需要) </p><p>用户：满足条件，参与秒杀，抢购商品。 </p><p>购买后的流程，与普通活动流程相同。</p><p><strong>功能性需求</strong> </p><p>网上找了一个天猫的秒杀库存系统。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416073746.png" alt="image-20210416073746776"></p><p><strong>非功能性需求</strong> </p><p>根据业务指标，估算并发指标，以此来反推非功能性需求。 </p><p>但是实际情况往往是，压力到底多大，不知道怎么办？ </p><p>1、根据线上压测，现有系统指标的测量和计算 </p><p>2、参考业内水平，设定并发流量的倍数 </p><p>3、建立基线</p><p><strong>注意事项</strong> </p><p>脱离场景谈性能，都是耍流氓 </p><p>需要注意：不同互联网电商发展阶段，不同的现实条件下，对于秒杀系统的实际需求和 </p><p>解决办法，是有非常大的差异的。 </p><p>PS：面试与实战的区别？</p><h2 id="第-28-课-4-如何编写设计文档"><a href="#第-28-课-4-如何编写设计文档" class="headerlink" title="第 28 课 4. 如何编写设计文档"></a>第 28 课 4. 如何编写设计文档</h2><p><strong>系统设计文档</strong> </p><p>传统软件开发一般有概要设计和详细设计。 </p><p>互联网相关系统不会这么复杂，关键在于描述清楚我们的系统。 </p><p>回忆一下，我们上一节讲的，什么方法可以达到这一点。</p><p><strong>系统设计文档</strong> </p><p>\1. 需求分析 </p><p>\2. 整体设计 </p><p>\3. 系统架构图 </p><p>- 业务架构图 </p><p>- 技术架构图 </p><p>- 数据架构图 </p><p>- 部署架构图</p><p><strong>扩展到整个研发项目应该使用的文档结构</strong> </p><p>非常详细的研发文档结构。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416073812.png" alt="image-20210416073812037"></p><h2 id="第-28-课-5-如何编考虑技术选型"><a href="#第-28-课-5-如何编考虑技术选型" class="headerlink" title="第 28 课 5. 如何编考虑技术选型"></a>第 28 课 5. 如何编考虑技术选型</h2><p><strong>技术选型的原则和方法</strong> </p><p>原则上，综合考虑采用相当成熟稳定的合适技术。 </p><p>符合公司技术发展路线和选型规范（如果有）。 </p><p>方法：基于关键场景编写case，实现demo，验证多种类似技术的各项指标。</p><p><strong>是否要采用最新的技术</strong> </p><p>参考公司和团队的研发成熟度和技术能力水平，业界技术雷达，可以适度预研，不建议 </p><p>大规模采用不熟悉的新技术。 </p><p>&gt; <em>当你采用一个不熟悉的东西试图去解决已有问题，那么恭喜你，你现在有了2个问题</em>。</p><h2 id="第-28-课-6-其他相关技术要点"><a href="#第-28-课-6-其他相关技术要点" class="headerlink" title="第 28 课 6. 其他相关技术要点"></a>第 28 课 6. 其他相关技术要点</h2><p><strong>系统设计上的其他要考虑的要点</strong> </p><p>体系化的稳定性建设</p><p><strong>系统设计上的其他要考虑的要点</strong> </p><p>架构团队与架构能力建设</p><p><strong>系统设计上的其他要考虑的要点</strong> </p><p>营销活动工具的平台化建设</p><h2 id="第-28-课总结回顾"><a href="#第-28-课总结回顾" class="headerlink" title="第 28 课总结回顾"></a><strong>第 28 课总结回顾</strong></h2><p><strong>架构具体要做什么</strong> </p><p><strong>了解清楚具体需求</strong> </p><p><strong>编写架构设计文档</strong> </p><p><strong>其他相关设计要点</strong></p><h2 id="第-28-课作业实践"><a href="#第-28-课作业实践" class="headerlink" title="第 28 课作业实践"></a><strong>第 28 课作业实践</strong></h2><p>1、（必做）针对课上讲解的内容，自己动手设计一个高并发的秒杀系统，讲架构图， 设计文档等，提交到github。 </p><p>2、（选做）针对自己工作的系统，或者自己思考的复杂场景，做系统性的架构设计。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四节 Spring 数据存储与校验</title>
      <link href="2021/04/15/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%8A%82%20Spring%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A0%A1%E9%AA%8C/"/>
      <url>2021/04/15/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%8A%82%20Spring%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><p>Java EE 项目 - 第十四节 Spring 数据存储与校验 </p><p>小马哥（mercyblitz）</p><p><strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>• Java 劝退师 </p><p>•Apache Dubbo PMC </p><p>•Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><p><strong>议题</strong> </p><p>• Spring 数据存储 </p><p>• Spring 数据校验 </p><p>• 问答互动• 核心 API </p><p>• JDBC </p><p>• JPA </p><p>• Bean Validation </p><p>• 复习课程 </p><p>• 小马哥讲Spring核心编程思想 </p><p>• 第十三章：Spring校验（Validation） </p><p>• 小马哥讲Spring AOP编程思想 </p><p>• 第一章：Spring AOP 总览 </p><p><strong>预习知识**</strong>Spring** </p><p><strong>数据存储</strong> </p><p>• Spring JDBC </p><p>• Spring ORM </p><p>• Spring Data JPA<strong>Spring JDBC</strong> </p><p>• JDBC 核心 API 回顾 </p><p>• 数据源接口 - javax.sql.DataSource </p><p>• JDBC 驱动接口 - java.sql.Driver </p><p>• 驱动管理器接口 - java.sql.DriverManager </p><p>• 数据连接接口 - java.sql.Connection </p><p>• SQL 命令接口 - java.sql.Statement </p><p>• SQL 执行结果接口 - java.sql.ResultSet </p><p>• ResultSet 元数据接口 - java.sql.ResultSetMetaData </p><p>• SQL 执行异常 - java.sql.SQLException </p><p>• 事务保护点接口 - java.sql.Savepoint</p><p><strong>Spring JDBC</strong> </p><p>• JDBC 编程特征 </p><p>• 面向数据表行列编程 </p><p>• 几乎所有的操作需要捕获 SQLException </p><p>• 开发人员需要关注 DDL 与 DML API 的差别• Spring JDBC 核心 API </p><p>• 主门面接口 - org.springframework.jdbc.core.JdbcTemplate </p><p>• Connection </p><p>• 回调接口 - org.springframework.jdbc.core.ConnectionCallback </p><p>• Statement </p><p>• 回调接口 - org.springframework.jdbc.core.StatementCallback </p><p>• PreparedStatement </p><p>• 创建器 - org.springframework.jdbc.core.PreparedStatementCreator </p><p>• 回调接口 - org.springframework.jdbc.core.PreparedStatementCallback </p><p>• 数据设置器 - org.springframework.jdbc.core.PreparedStatementSetter </p><p><strong>Spring JDBC</strong></p><p>• Spring JDBC 核心 API </p><p>• ResultSet </p><p>• 结果抽取器 - org.springframework.jdbc.core.ResultSetExtractor </p><p>• 结果处理器 - org.springframework.jdbc.core.RowCallbackHandler </p><p>• 结果映射器 - org.springframework.jdbc.core.RowMapper </p><p>• Key </p><p>• 存储对象 - org.springframework.jdbc.support.KeyHolder </p><p><strong>Spring JDBC</strong></p><p>*Spring JDBC** </p><p>• Spring JDBC 编程特征 </p><p>• 面向数据表行列和面向对象混合编程 </p><p>• 通过 Callback 接口无法显示地捕获 SQLException，而是 DataAccessException </p><p>• 通过操作方法屏蔽 DDL 和 DML 在 JDBC API 中的差异</p><p><strong>Spring ORM</strong> </p><p>• Spring 对 Hiberante 整合 </p><p>• org.springframework.orm.hibernate4.LocalSessionFactoryBean </p><p>• Spring 对 JPA 整合 </p><p>• org.springframework.orm.jpa.LocalEntityManagerFactoryBean• Spring ORM - Hiberante </p><p>• IoC 整合 API - org.springframework.orm.hibernate4.LocalSessionFactoryBean </p><p>• SessionFactory FactoryBean 实现 </p><p>• Session（回话） </p><p>• 有状态 - org.hibernate.Session </p><p>• 无状态 - org.hibernate.StatelessSession </p><p>• 模板实现 - org.springframework.orm.hibernate5.HibernateTemplate </p><p><strong>Spring ORM</strong></p><p>• Spring ORM - JPA </p><p>• IoC 整合 API - org.springframework.orm.jpa.LocalEntityManagerFactoryBean </p><p>• EntityManagerFactory FactoryBean 实现 </p><p>• 通过 JNDI 获取 EntityManagerFactory </p><p>• org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean </p><p><strong>Spring ORM</strong></p><p>• Enable 模块驱动 </p><p>• org.springframework.data.jpa.repository.config.EnableJpaRepositories </p><p>• Spring Data Commons 操作接口 </p><p>• org.springframework.data.repository.CrudRepository </p><p>• Spring Data Commons 排除注解 </p><p>• org.springframework.data.repository.NoRepositoryBean </p><p><strong>Spring Data JPA</strong></p><p>• JPA 操作接口 </p><p>• org.springframework.data.jpa.repository.JpaRepository </p><p>• 分页和排序支持 - org.springframework.data.repository.PagingAndSortingRepository </p><p>• Example 查询 - org.springframework.data.repository.query.QueryByExampleExecutor </p><p><strong>Spring Data JPA</strong></p><p>• Spring Valiadator </p><p>• 实现 org.springframework.validation.Validator 接口 </p><p>• 实现 supports 方法判断是否需要支持校验 </p><p>• 当方法返回 false时，视作不予校验 </p><p>• 实现 validate 方法，判断 target 参数是否校验合法 </p><p>• 当校验非法时，通过Errors 对象返回 </p><p>• 实现 MessageCodesResolver 或重用框架实现，完成错误信息编码化 </p><p>• 使用工具类 ValidationUtils ， 辅助通用校验逻辑 </p><p><strong>Spring</strong> <strong>数据校验</strong></p><p>• Spring Valiadator 与 Bean Validation 整合 </p><p>• org.springframework.validation.beanvalidation.LocalValidatorFactoryBean </p><p>• 适配 org.springframework.validation.beanvalidation.SpringValidatorAdapter </p><p>• 实现 Bean Valiation javax.validation.ValidatorFactory </p><p>• 创建 javax.validation.Validator 实例 </p><p>• Spring Bean 生命周期实现 </p><p>• org.springframework.context.ApplicationContextAware </p><p>• org.springframework.beans.factory.InitializingBean </p><p>• org.springframework.beans.factory.DisposableBean </p><p><strong>Spring</strong> <strong>数据校验</strong></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>代码单元覆盖度</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记-20210412</title>
      <link href="2021/04/13/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210412/"/>
      <url>2021/04/13/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210412/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e914ef7db1fc5491d6b2d848e70c885a68cd265d1cabb396476739acf8ed5d75">675ef3242d144ff249cb5b90ca678376d6a1f386101f4da42c4ec4b00a2e11016ca2b0f68b0546f8d9a8bc88c92c73b25821aaa997bf8eb39beebc7e34f03d277a43b68a0e029a65ce502d99520a9d121a1b3f3be2ff1366c26b18e1fb6dfadc1e3c0e091c2febca89b38bcd5e08030e9c92bd8449bb6fad1f373da7bededb35f3369c24888cd4635f9b3e2ae7210cb52c883d7b48964f9430e1cc5bee87829b2b61ba49b915d4a0122f4c9f72875c8d679d46fd317317b8addafc5b6e7ceb0198facd8791d21b3a5d717a904eb90a9971452757c561fc688d40b037edbee86cab5db02be0082696873a5dd2dd92faa32663c2ffb877dee3235672a2dcfc5a8160639d369ebfb69b1e501756fef68ec9a5642b8808846b35bf85ddf0dc7bc642974c835965896500f422472f30d53c0e800875cb135121c4b70e86aec0a4b8d865689489b00a053cb526270a240ecdba1dacf3f3e1cad9c800e5802b03e6190957520920e81a353acc0d0ceb6535b525dfa8b3fa6c432e3cdbafd1a2ca155e3227089d53e9708a2ebf9e93ae705101791871e3c3e47608267741ec9a9af9afd254d8a6639424b87080a8a2a99e23bff7fd30c85584f4b8e372dd93e4a0686818a900e08c046691f401fe8d8ea95e0800839d3adfc33fe28ffcbe6e7a372aafefeb2baaa04a2cdec54a3a5f1150825b46ea286ac86ff692b3aa44e69d5d5aebf9c4d7ff2359144379388a0f408dad683e4fd2a0a68b5cacd37c0d571754354565102e8f0baee3735df4259c195364cad46a0da07b9f0a9180d9852217c757e36eb3360d5663f6e3f40341309b5fa7c8d36a70409d32ec78e1f3d895f9608f8d540213f317df4f0273562b7d752683c1ac11700082d59fe9c16e5f6dd4887389f05cb2b5bbf59ff909298baf38af0c10e8432e54ccde4758c8271cc3b82730204a80cb22ec12f26f36b4f38a773d973515042d295e7b91ff00e8a34a3f8e080a2af3e10c33a3b866e8beaef33efe7cf5f7da34c5704bcde7684801e72e07212749d4afeb2c85fcc6726194b6c9bccb96c437bf495373c37a703ec37f4e5613979f87929b1013037dd0f84dda329ebe4931d906f9b89e977face0c67d2f0a81a491ff331452aad6c1a9aa6796ffa86a91fe61a2c7f8eaae083047fd7527f69dfa6f88f9f4a612182f33e6252769f3e37dc9d4d395437e4ea5e26e5c0895c5c464caf0484ead2125bdf239edda5240fb353155258b54a79dd1cf6be57ac10991d6d73204f9eddc34f4aef0b5e5a9887b04f5d7e0e1d6427b27acde80fe758dadbe074f29089e44531eaff1eabd3e3f69bec06fd3394028a6b5c90c2221853b7bb7241f687471696a1ae00806c78bbfa1d0b415b26600b438007a05cd03ff40d7d99c42056a059556de5ef15d6b170f80afed989f1a7dc2122fe7c243230dffc58c5efb2cec6d23d9bf173fd9339b3fb25a050dfe81a89854666148e36e3e4be907a570a4d57427a5dca53c5249d20b1af6c34ba68abcddb53057d3dcd28f767c4d819fd8d5bd939b21321662086f7a0c27da2e4b1b06c5d9d0a1b20ab4eda773c92045ccf0c7663f3c4488521aa1d18981089934d58d7b69e1c0e6c166929c642f2fa42dd3c9e0488052b40f71d590b9eee2fdcb8a8e6b0eb901cfb642c7e453c5bd17f43a4f79716573afc72fa0d4f141d75afb578a5b3585c99580c5b0f20c79acee01d3522afb338fcc9dfae708a5b33831ea65306231486cf17b3d6c09c03320c000ce51ff85ae8eff342e3c5d8a3f7a3e617244439a5892248ae9eddb5377d917ae68d723dafac614c2ad7b405a1b860b06b660ce927c4a135d6d17a6225641da405a827b492fcdb9837af9c3b524fdc73346a3dffdfd281c7f046243454cd5773d787cf9b02dc1fb278644b122d5cf6ed4939b37e201699e6f08c3f8e87281b6777fd58d37c34e027d2468d15735d1b66ef1e5a7f92d23876169c292e769e16b69fbd2a88ac1452732ae3fbcf7e4c9898d3753dea705a96a4dec8a7846fb271fe6ccf7e30180b58d10c8d4e10879b6039c611f821e0c5a83b36ce4e469e635b7235db9cadb6a39258795f8b417ea44c193e848b862ccc9a4357a50c692747b3fd24543d53731b1b3ccff6afbd542b21e9901c965cd99040868349837a0ed8551db2ae7077f9407c844b29c1aee124dcb91882edfa784711cc6e4585fb82ff979eb9675f8b1c82627651b752c21c143f1adb6fb5292decd85b1bae6de0f3f5c0e12d34326c8753ea700efa8468831d165bf761c97865f5356baff3117509b12760fa9064118311bf96d8bf9cd395d475357009dddea782dde7cd712acfaf191122b22388b5743f7cdd831b6fc8a476aebec94246def54a72bbb46b36c18b339c4772471c868c4b2692a840cba48aabeb92b7492ccdf0206504a5ffbcaa340311028c1c373db01035c9f192f15ed9fda7e62cc276f28b1a22b8df91054615c40ea99948d911dabced83db4a091419b15133c59c8eecae4b6ff565e643f547fd9a7e1484644f3dd11a414a2d5f515db59fc28eb036fab91cae883ab376f45d2344ad60e375835805be104f82895338b95255e1217d711ca1b02627c75c9a08a8930816bf23a5811907c7e2332a651dc014f0323a0c5b84e0abfafd98ef6f46f56acc8417c0f5bcdfb8e4d58a2e6df542782360fcc229c8147f2674c850b5817db83d3433a49f191938fb4a8a70b33670b285d36a8740de67e79419f816e2e7902e5df0195e762a07d96f41d46cd9c79c4a8716fbe52f915e63579f00fae0c82663ef3b29c622b440f0b1b4dbbeea0c3d68740484b23d69f5658b0688564350d71859fee1ebb0642a26a27a72e05f0715a323190e65b9b3c1cd6a64c12daa841559842913785f1010e3c6f3f8eb4e322025f7dbd11238eaa9049c05e021fa61da8dd3f1b6a45d2d5c36c5581b640b723b22a5458a0e1bb572201f71e3dd6f02600ca592709f65e8e45221f26570696ed498ec83cbb8c67d826dca5f5d2455ffe890aed97c6cf6cce8a5b0111cca17ac318a9ff1c533bb43c7058e2c1c576d04cfe6fdb4d18be166c9458cb32eb63897381dae4075ef72c0859af714db8a151c383793c07cae05057edfe82927618eb875d977b16bdf9a574806f45c0de90a97bb2231461d62ab89a0a202bb099f0506b5ebb1f80de5011bb513b40daf004ed2a0ac40a5b5a1745a96958fa49f1ea6bf1e66a4eb17a3039f52bb2a55c0f4327c9ed861121e02de0664244381633325254c158a8fabfca76ea7cb00122f3f0988e70faa45b4da8d4dcb7b1d41432b5f38dca50e323068aac00a619656e1114ce1c0256a66fe9f6792ba840965119ab215cf9fe9b9191976aec889825c8014d366fdfa03cc6a07230d7c03d4feccc6c7a087f979561475d10b9307c78c7bca839f35f73ec43231ebde9e309b1cafd91effb543a4f6cd6157d4b7b00b042c5d3b2cff44fbb10c3654f9ea6de993d4d2026c95932e0333192e65de992e980607e0c20d8ad06828a069bca1e3bef71c963095849393f2c83a012eaaa192f51634fab7020d0830abfcc098ceb1fa6c1b8ff1ad223c330be9295190439782ef8e703fd98271f5573049074261b83439e587405f46cd345ec0891b1875c204682db255d972c06413c858dad9e27a0046e7227a5d6e609cf70c61f2d1e01e31903f56edbbe114f4cb65b025fbe2c60e8340e2238b9c5aac72250ec79a7ebf8e25623034dfa6e82f4ad25e6329477565f06325cbacbb2d0232cfeff52c6b18761abd0f8123726feff4c42c3982fc3ee490d8d5afd18191e46072daa77102a15c2dc7484c2b9684ec07586b544bdda60ab09c10f777f7d6062e95a34d5fdcc353b0b6bf85b7e04d30928c9047bd5082f182163fa4298da4f277eff04698887a10111bc2ec9d4890cca5b64dff93f966f96ba15e18cc70ac237e4c231f093db4135004e3bae467c0a67c5234ea92203f207cd84341ec1b769c7065d09ee06ba10002c3a1dd93fb31f2ef4ccdfc94695a9ae972a883fd2b0d13a66432404da22eb39f3e28060e7773a2ed204104a2878912cf8e4d9743b64a8d1d6fea833dcc91fda5d940f3dbd9ffaebdd152a6415a58987de6bd3c446c4a9fe533d7650d06900758680ac0e9be433655a515f8b561ace497c22499177180c1c0f15b225fc74737859bafdbf7d13feca72adcba447c4532c82fbcb2a5189d0479b735b5bd9230acafc3e0eb16bbecc336eb8b76f680b65167e00fd5697f1312c4e39e6410e5ede9870a9e7330808e21528961618f4cc4216dc28666ef9251171a75c980f3b605b3952b430b92179bbaac72efce92b740bb8da967a9cd21bcf89c6dc45e8c0d087a57b6d17233aa3a4c4b831883fbdb43468c2383d55fe1c5d05833b3e1323531d2bcdcc73aab8cf84cd3acb3f6492d76fc80486880a99a3aa5f5b9194015e52ef27a661eb5453c917c14ee8036ba129565cd996949a621c53d456d723e3882a363a027e201f5ea50b9c5684629b65efe446a4834d58df68e3263daf23103c0f306271f3127661feea3d175708a2b252a7117bcfabcd5f2a6f47b22a064c4b2254fa45a7cc994ad21a5a331311809c8f5b003023df1f98b53a8e80bb39e5aa81e71be45825335a057510013bd779ce3825b09b76b6e323064a19b5b253942691bd7bf5fc1f749496519bce7e3229be30c22dbb9a9150d72c275ed23780a305a8b37029979b52f3ae3b68430d53f60705e432a2abed6c326c278666ca5a0de9f47c1ab756d5e213285c2f2d77320087b9c876e0478bc7e16388a88ac98edaf8be740c5466ff41154e350abfebf1e57db41f47bdc31cc869475f6d2da30b5d130a643b06046303cdaa32c4ccdb9c374b55a6ebd39d95c2f5047bb43af4302d60d0c73f4a5c87c7d6475a35270de80ed929cceec04c60693badb58e16ba60592b7237ca832ce0ef89a44315494a6e7c527921b6d94c1ad836fc8e3e0d556abd3e15707b2caff88725defa0d4ebba838740f333c312759c46c76be403467b3465fa8206c67df352a13286a5c23067f924c6aafc022b43d9e3f2832cd869c6c16e3c29b5faa14f05edc8b0010787d3e312170ce3487e523daeae73a14b2d408801b60360640532c45288f4f3ca4228349c5c49e9e70561580a0f8fbf8a935c3821db47dc4a5c9e590d4779ff14a66ea06a06523b9c0a1bfe7bf0c4a8dc0154b4b21e9193ece7dde1c494444f7e1f08c7167dc9903fa3d56b836e03e626fb1bf2332be3953d50ef56eb151f201fdd4119e7aad4df1cf1d4fe4080ff20cad89e469972cd5837754419b945ab41b5a057582a2ce52fa8ad1006186bf606a53dceb439135064d47fcb4c0cdaa941b4a470e694c31acf76964c563ad0d368e4f1c6aac5941365068b84c9554f9ed8dccd5b64e40bf0bb9baddc0b4c5ef09d7fe3bc199bb3a86adc809799ea85b9c5475a85ea261d9808b608af98f8e8ab7f6e06a732cc202d47bdf7f03e453b14f9451f664bbf367639d487a68230c6efa09dc93619c9625f1e196c2cf9f3e2013eab71bfee420df77c88c293cd480b649ea88e74c7dd2fc61382fec71fe711d154ea523f070dc590f822aa158b5f17b7797dce2140eaab6939074cd1bed12f37e9984cffd670b97f22c7e39e9294bfe9639fc991397f557b16d94e2e0958919ab74cb69a88884b24133c35cd5a547ff9d08bc7ae73ce4225d5e7476d3c5094d871d0d154fb8985753290c81d3b3b86e4a11afdda9130b97e8a92ab1165be33e5009efadbb99a5159c01426984b3ab377b29098a95e26332cd30cc7796ec49ce573008419a20f38a22399413f7bc0a69e89be00994b32f5c13c34ec65d3593e9b2e6b9aaf8a4839718e6c42e3b501e94b1688180fb75680ed6b03acc7608128f72551a0c78168d05ee8008117964f63dbc60746973fb279b82897fb85952f76f2c833024cc19605bee2191e5658bd83b4447908c38e0fcb844122f6bcb7168b42091ba5d7643c2f8a068dbffeb0356440d0c776f17ce3232a4fba3441bc3513c3d4bcc0bef61b181c930e1d23bc0788e07b78c96d5b55d1ab7e80b49b999be30f042a608a9f10a21d37d2f89471f8ae4ed704aedb0d1b83c1971b161507d8b0589e04c905f599bde11079ea784086fd057488816eb3d934518883fba9507e4e2578565f366f7a153f4e824672f65ba4942fa9b1cdb0e0db48a44bd1c51a28b5ac3266c2eb9863d4c1d3d931d8a7019180efa33cb80d02a2386fcefa994182b27870523bb60bffab9a99ebc544100a3a7ad0f4f5e5ec9e2cecef98441de4cfff7d3da525842504f8161dc4d2ef303126bc00fc3b77395e07dab9c02bbb4c20ffa838c80017f9d8376c199c9c50f30f8f0eb9d18484d9dbac230c4e65d461b89cbb89118ab62cb216ad70c27959fabf31f9e0601ca4ef2aa520239e9074e9f195325332b4efd80689e0a4e23c46c197f56f2b88518eba73a7406befa084fae9dc89a69ab333a0cbad86eec51f2d11ddb8e130f6e45eb5ab022d65ae32b04a7da631690da6ca8cda4160b4af2e3ea2c58ace0d07617304652b49865ba615264eb839e6bfbb33992f9433db941210f29309b25c8c9c606c5ae0a354266b87924e6ce119bb257c79752c07a627e1262b8ea75ea04768e97a70a3b89ac47681824072f5bb048b5c7057e86b47f6b2b9300973a5da9e25d24cdb5ff87d47900f6096940ba0cba687d3b3b18517c7e0794921413e5726d897e4afc2e33729b3d833f35a57a5ed012fa0f0ff67282ad7aee081cd7f997630a207ce570959784619aace3324e124e4a1a2f19429634f4bb618acda516e48143e8e5e1cf48601047d1f3e31a4e382b4ba414a99ff5526aab4dda51b4e240fdabd14467b29cbb301472cc8e59213fa1faa7089e35228864c8b213878339968b439e33e1fa0458e1d5c613f827130bf609332e77a3b06dec100ed21903ed020211dbec4354e3d75b19afdb56ce5557115c26c6aec2931fc87e77f09ec8b1a32444136c172057c0e9a922705621b34a582d0f7d7230b309e6f34c760db679130c04e5a0662b1f929a1694669ea937f5b1634f6786d2be1c29502fb9aaa2cbbbab4087ef9dc7379138ad481dfee53122bb234cd378ed83cccd983733bb6c99060682a1853acc89cb1f113e31a35d10c7af2d052f777249e1a04ad937dcd76b48969cea0871d5d4f5ba0e55adac65777fd9e5f186bae703664498cb922912a70d729f89be4cbdecad7a43cfe1a0f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week14-01 第 27 课 分布式系统架构--高并发系统架构设计</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week14-01%20%E7%AC%AC%2027%20%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84--%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week14-01%20%E7%AC%AC%2027%20%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84--%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营 </p><p>第 27 课 </p><h1 id="分布式系统架构–高并发系统架构设计"><a href="#分布式系统架构–高并发系统架构设计" class="headerlink" title="分布式系统架构–高并发系统架构设计"></a>分布式系统架构–高并发系统架构设计</h1><p>KimmKing </p><p>Apache Dubbo/ShardingSphere PMC</p><p><strong>个人介绍</strong> </p><p>Apache Dubbo/ShardingSphere PMC </p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人 </p><p>阿里云 MVP、腾讯 TVP、TGO 会员 </p><p>10 多年研发管理和架构经验 </p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.到底什么是架构设计 </p><p>2.系统架构的演化发展* </p><p>3.架构设计形式与方法* </p><p>4.架构的一些实践经验 </p><p>5.总结回顾与作业实践</p><h2 id="第-27-课-1-到底什么是架构设计"><a href="#第-27-课-1-到底什么是架构设计" class="headerlink" title="第 27 课 1. 到底什么是架构设计"></a>第 27 课 1. 到底什么是架构设计</h2><h3 id="什么是架构（Architecture）"><a href="#什么是架构（Architecture）" class="headerlink" title="什么是架构（Architecture）"></a><strong>什么是架构（Architecture）</strong></h3><p>架构（Architecture）一词源于建筑领域，就是建筑的意思，也是体系结构的意思。 </p><p>维基百科英文版里对Architecture的解释是：规划、设计和建造建筑物的过程及产物。 </p><p>Architect/Architecture ? </p><p>软件工程 ~ 建筑工程 </p><p>- 人的因素， </p><p>- 标准的因素， </p><p>- 技术的因素, </p><p>- 产品的因素，，，软件边际成本是0。 </p><p>为什么建筑工程如此成熟？</p><p>国际标准化组织（International Orgranization for Standardization，ISO）系统和软 件工程标准认为，系统的架构是一系列基本概念或者系统在其环境中表现出来的属性， </p><p>体现在它的元素、关系及设计和发展的原则中。 </p><p>1.架构过程：在系统整个生命周期中构思、定义、表达、记录、交流，验证合适实现，维护和改 进架构的过程，也就是设计过程。 </p><p>2.架构：一个系统体现在其环境中的元素、关系的基本概念或属性，以及其设计和进化原则。 </p><p>3.架构描述：表达一个架构的工作产出物（通常指的是各种架构图和设计文档）。 </p><p>4.架构视图：通过系统的某些关注点的视角，表达一个系统的工作产出物（例如部署视图、开发 视图等）。 </p><p>5.系统：包含了一个或多个进程，硬件，软件，工具与可以满足需求的人的集合。 </p><p>6.环境：决定了开发、操作、策略和其他影响系统的设置和条件。</p><p>总结：<code>软件架构是一个用于指导系统实现的草图，这个草图越详细对于系统实现的指导 意义越重大，贯穿于软件的整个生命周期。</code> </p><p>在建筑领域，大楼尚未建造前，就已经存在于建筑师的脑海里；同样地，系统开始编写 第一行代码之前，就已经存在于软件架构师的心里。至于怎么样把架构草图表达出来呢？ </p><p>我们一般都是采用架构图和设计文档的形式。 </p><p>架构相关的文档就是，用来描述和交流系统架构的媒介。</p><h3 id="架构的一些概念"><a href="#架构的一些概念" class="headerlink" title="架构的一些概念"></a><strong>架构的一些概念</strong></h3><p>架构领域长时间发展，积累了很多的概念和基础知识。 </p><p>例如，我们经常说得软件领域名词还有模式、组件、服务、模块、类库、框架，平台等， </p><p>他们跟架构有什么关系和区别呢？</p><h4 id="架构的一些概念-模式"><a href="#架构的一些概念-模式" class="headerlink" title="架构的一些概念-模式"></a><strong>架构的一些概念-模式</strong></h4><p>模式是表示上下文环境、动机、解决方案三个方面关系的一个规则，每个模式描述了一 </p><p>个在特定上下文环境里不断重复发生的问题的一类解决方案。UML中给出的解释更通 </p><p>俗易懂：模式是对于普遍问题的普遍解决方案。 </p><p>我们把一类问题的共性抽象出来，这样就可以用同样的处理办法去解决这些问题，从而 </p><p>形成模式，所以模式是一些经验的总结。 </p><p>从这个角度来说，软件架构作为一种软件设计过程的指导准则，也是一些经验的积累和 </p><p>问题的抽象，同样也可以作为一种模式。 </p><p>更一般的，依据于处理问题领域的粒度不同，我们可以把模式分为架构模式(Architectural </p><p>Pattern)、设计模式(Design Pattern)、实现模式(Implementation Pattern)三个层次。 </p><p>• 架构模式是最高层次的模式，在软件过程里描述系统的基础结构、子系统划分，确定职责和边 </p><p>界，以及相互作用关系。 </p><p>• 设计模式是用来处理解决程序设计里具体场景下的问题的解决办法。 </p><p>• 实现模式是最低层次的具体问题处理办法，例如编码规范、命名规则等。</p><h4 id="架构的一些概念-类库"><a href="#架构的一些概念-类库" class="headerlink" title="架构的一些概念-类库"></a><strong>架构的一些概念-类库</strong></h4><p>类库（Library）是一组可复用的功能或工具的集合，应用系统通过调用它们从而达到 </p><p>复用功能的目的。 </p><p>例如，windows应用开发里的各种静态或动态链接库DLL文件，Java开发里项目里依赖 </p><p>的或者maven中央库里的各种jar包，都是Library，比如apache commons-io、 </p><p>httpclient，log4j等。 </p><p>类库根据其所在的语言或平台环境的不同，可以是编译后的二进制执行码或中间码形式 </p><p>（DLL或jar），也可以是源代码（PHP、NodeJS里的类库）。类库的调用关系一般在 </p><p>开发期引入到目标应用的项目中，运行期执行实际调用。</p><h4 id="架构的一些概念-框架"><a href="#架构的一些概念-框架" class="headerlink" title="架构的一些概念-框架"></a><strong>架构的一些概念-框架</strong></h4><p>框架是基于一组类库或工具，在特定领域里根据一定的规则组合成的、开放性的应用骨 </p><p>架，比如SSM/SSH框架，甚至Dotnetfx、JDK都算是一种框架。框架具有如下特性： </p><p>a）支撑性+扩展性：框架不解决具体的业务功能问题，我们可以在框架的基础上添加各种具体的业务功能、 </p><p>定制特性，从而形成具体的业务应用系统。 </p><p>b）聚合性+约束性：框架是多种技术点的按照一定规则的聚合体。我们采用了某种框架也就意味着做出了技 </p><p>术选型的取舍。在很多种可能的技术组合里确定了一种具体的实现方式，后续的其他工作都会从这些技术出 </p><p>发，也需要遵循这些规则，所以框架本身影响到研发过程里的方方面面。 </p><p>在一个具体的框架之上添加一些基本或可复用的功能，这时候就得到一个介于框架和应 </p><p>用之间的结构，我们一般叫脚手架（Scaffold），可以用来快速的实现类似项目。</p><h4 id="架构的一些概念-模块"><a href="#架构的一些概念-模块" class="headerlink" title="架构的一些概念-模块"></a><strong>架构的一些概念-模块</strong></h4><p>模块（Module） </p><p>模块是业务或系统的按照特定维度的一种切分，同时也可以看做是各种功能按照某种分 </p><p>类聚合的一种形式。例如我们的一个电商系统，可以从业务上划分为用户模块，商品模 </p><p>块，订单模块，支付模块，物流模块，售后模块等。另一方面，我们也可以说用户模块 </p><p>聚合了用户注册、用户验证等业务功能。这样，我们在设计和开发过程中，就可以按照 </p><p>模块的维度去组织，比如每个模块新建一个源码的子项目（subproject）、打包成一个 </p><p>单独的jar包，也可以放到一个项目里用不同的package名称来区分等。模块一般是系 </p><p>统在较大粒度上的解耦切分，仅次于系统或子系统的级别。</p><p><strong>架构的一些概念-组件</strong> </p><p>组件（Component） </p><p>组件是一组可以复用的业务功能的集合，包含一些对象及其行为。组件可以直接被用做 </p><p>业务系统的组成部分，粒度一般小于模块，也是一种功能的聚合形式。比如日志组件、 </p><p>权限组件等。根据组件的形式、行为和用途的不同，我们又可以延伸一些概念： </p><p>• 构件（Composite）：具有层次组合关系的多个组件组合形成的复杂组件形式。比如RCP里一个Window </p><p>里左边嵌套一个TreeView组件、右边添加一个GridView组件，这样就形成了一个Composite构件。 </p><p>• 部件（Widget）：部件主要是有UI界面的构件，比如Windows 7或Mac系统自带的桌面天气小部件等。 </p><p>• 插件（Plugin）：系统运行期间可以即插即用、随时停用卸载的组件，一般有确定的生命周期，比如 </p><p>google Atom编辑器的各种插件、OSGi中的bundle、Eclipse插件（本质上也是OSGi的bundle）等。</p><h4 id="架构的一些概念-服务"><a href="#架构的一些概念-服务" class="headerlink" title="架构的一些概念-服务"></a><strong>架构的一些概念-服务</strong></h4><p>服务（Service） </p><p>结构化信息标准促进组织（Organization for the Advancement of Structured </p><p>Information Standards，简称OASIS，XML和WebService规范就是这个组织提出的） </p><p>把服务定义为： </p><p><em>一种允许访问一个或多个功能的机制，其中访问需要使用规定的接口，并且与服务描述中指定的</em> </p><p><em>约束和策略一致（a mechanism to enable access to one or more capabilities, where the</em> </p><p><em>access is provided using a prescribed interface and is exercised consistent with</em> </p><p><em>constraints and policies as specified by the service description）。</em> </p><p>概括来说，服务是一组对外提供业务处理能力的功能，服务需要使用明确的接口方式 </p><p>（比如WebService或Rest等），服务描述里应该包括约束和策略（比如参数、返回值， </p><p>使用什么通讯协议和数据格式等）。</p><h4 id="架构的一些概念-平台"><a href="#架构的一些概念-平台" class="headerlink" title="架构的一些概念-平台"></a><strong>架构的一些概念-平台</strong></h4><p>平台（Platform） </p><p>一般来说，平台是一个领域或方向上的生态系统，是很多解决方案的集大成者，提供了 </p><p>很多的服务、接口、规范、标准、功能、工具等。例如J2EE平台，包含了企业级应用 </p><p>开发里的各种基于Java语言和JVM虚拟机运行时的技术能力。 </p><p>• 库是工具箱。 </p><p>• 框架是一套通用的解决方案。 </p><p>• 架构是高度抽象的需求，是系统中的不变量。 </p><p>• 平台是所有可能做的事的集合。 </p><p>事实上，服务、平台、架构这几个概念这几年已经被泛化了，什么地方都可以滥用这几 </p><p>个词，随便一个系统都可以说自己是大数据平台，XX业务平台，XXX服务化架构。 </p><p>一个SOA的真实笑话。</p><h4 id="从软件生命周期看架构"><a href="#从软件生命周期看架构" class="headerlink" title="从软件生命周期看架构"></a><strong>从软件生命周期看架构</strong></h4><p>软件生命周期可以概况为3个大的周期：设计期（包括立项、计划、技术选型与方案 等）、实现期（包括开发、测试、发布、实施等）、运行期（或维护期，包括修复bug、 新增功能、多版本维护等）。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210415205515.png" alt="image-20210415205509976"></p><p>1、设计期，软件作为一个成品还不存在，所以我们可以称之为概念形态。此时架构师、 产品经理或需求分析师等人员利用自己的经验能力，对系统的业务需求进行分析、拆解、 抽象，形成业务文档和技术文档，以及技术验证代码等。这个阶段，架构设计工作是重 中之重，其中包括： </p><p>\1. 系统分拆，如何把系统拆解为不同的子系统、模块、业务单元； </p><p>\2. 技术选型，使用什么样的基础技术框架或脚手架； </p><p>\3. 技术验证，确定核心技术难点如何解决，检验能否满足期望指标； </p><p>\4. 接口规范，系统的内部不同部分以何种形式确定接口契约和数据通信； </p><p>\5. 集成方式，系统与外部其他业务系统如何进行集成； </p><p>\6. 技术规范，如何规范开发、测试、部署和运维的技术标准性； </p><p>\7. 部署方案，系统如何进行物理部署，需要多少机器、什么配置，对网络有什么要求； </p><p>\8. 运维方案，系统如何进行技术性运维，如何日常监控、预警报警； </p><p>总结一下：业务为要，架构先行（包括业务架构和技术架构）。</p><p>2、实现期，这个阶段主要是编码与测试，准备部署上线，是软件从代码到最终的生产 系统的过程，我们可以称之为代码形态。此阶段需要考虑的技术类工作包括： </p><p>\1. 确保各项技术规范和技术指标的执行落地，保障高质量的代码； </p><p>\2. 指导研发人员和解决各类技术问题，提升研发团队效率； </p><p>\3. 制定测试的技术性方案和基准，自动化、性能、安全等； </p><p>\4. 配合准备部署环境，运维实施方案落地等； </p><p>实现期的主要任务是大量软件工程师根据设计期的设计编码。大量的人员，大家背景不 </p><p>同，知识储备不同，编程水平和习惯不同，努力程度不同，如何能够让所有工程师都既 </p><p>能够按数量保障项目进度，又能够按质量保障软件品质呢？秘诀就在于：技术标准的精 </p><p>确统一，系统部件的良好拆分，此外最好有适合于此类项目的脚手架，随时能解决各位 </p><p>技术难点问题的救火队。系统部件的良好拆分，保障了任务是可以拆散成一个个的小单 </p><p>元，分发给不同的开发者。技术标准的精确统一，可以实现不同个体的产出物最大程度 </p><p>的一致性。总结为，标准统一，快速开发。</p><p>3、运行期，这个阶段系统上线、验收通过，已经初步稳定，然后进入维护阶段，成为 </p><p>了设计期架构设计草图的一个可用实例，我们可以称之为实例形态。此时需要考虑： </p><p>\1. 发布上线相关基础性工作，包括是否使用持续集成（CI)、自动化发布等技术； </p><p>\2. 运维基础性工作，自动化运维，监控等相关技术； </p><p>进入维护期以后，软件系统日常通过内外部用户反馈的问题和改进意见，不时需要修改 </p><p>代码发布补丁版本或者调整数据以满足用户需要。经过较长一段时间，业务模式和内外 </p><p>部环境发生了比较大的变化以后，系统简单的补丁维护可能就不能满足用户需求，需要 </p><p>大范围的添加新功能和修改旧功能的逻辑流程，此时就可以成立专门的团队，重复上面 </p><p>的步骤，基于现有系统重新做一些改造性的设计重构（设计期），再编码实现（实现 </p><p>期），最终再发布一个较大的版本（运行期）。总结为，基础设施，监控运维。 </p><p>在软件的整个生命周期里，架构师或架构组是一个项目或者产品线的技术负责人，再大 </p><p>一点的组织，比如公司或研发中心级别层面也许还有架构部，架构师、架构组、架构部 </p><p>在不同层面对自己工作涉及到的所有技术问题负责。 </p><p>其实上面罗列的这些工作汇总一下，再加上技术规划与执行落地、技术人才的选拔与培 </p><p>养等，可以作为项目组架构师或者研发团队架构组的工作职责。</p><h2 id="第-27-课-2-系统架构的演化发展"><a href="#第-27-课-2-系统架构的演化发展" class="headerlink" title="第 27 课 2. 系统架构的演化发展"></a>第 27 课 2. 系统架构的演化发展</h2><h3 id="架构发展演化"><a href="#架构发展演化" class="headerlink" title="架构发展演化"></a><strong>架构发展演化</strong></h3><p>从软件架构的整体风格来说，大致目前有如下几个阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416072517.png" alt="image-20210416072517438"></p><h4 id="架构发展演化–以电商为例"><a href="#架构发展演化–以电商为例" class="headerlink" title="架构发展演化–以电商为例"></a><strong>架构发展演化–以电商为例</strong></h4><p>1.0 单体版本~ asp/jsp/php 为代表， </p><p>一般以提升硬件性能来提升系统处理能力 </p><p>![image-20210416072535024](/Users/cutie/Library/Application Support/typora-user-images/image-20210416072535024.png)</p><p>业务系统 数据库 </p><p>用户请求 </p><p>用户请求 </p><p>用户请求</p><p><strong>架构发展演化–以电商为例</strong> </p><p>2.0 垂直架构 ~ 关注于大规模Java应用开发，以分层为软件层面的设计原则， </p><p>大规模的集群部署方式：涉及负载均衡，反向代理，Spring/ORM等框架。 </p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416072549.png" alt="image-20210416072549413"></p><p>负载均衡 数据库 </p><p>用户请求 </p><p>用户请求 </p><p>用户请求 </p><p>业务系统 </p><p>业务系统 </p><p>业务系统</p><p><strong>架构发展演化–以电商为例</strong> </p><p>3.0 SOA/分布式服务化版本，以RPC与前后端分离为代表。 </p><p>引入数据库中间件和复制技术，解决数据库高可用和容量。 </p><p>引入缓存，解决热点读问题。 </p><p>引入全文检索，解决海量的复杂条件查询问题。 </p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416072604.png" alt="image-20210416072603978"></p><p>数据库 </p><p>负载均衡 </p><p>静态资源 </p><p>用户请求 </p><p>用户请求 </p><p>用户请求 </p><p>服务B集群 </p><p>服务A集群 </p><p>服务C集群 </p><p>web应用B </p><p>web应用A </p><p>web应用C </p><p>数据库 </p><p>集群</p><p><strong>架构发展演化–以电商为例</strong> </p><p>4.0 微服务版本：大规模分布式服务化+容器化+治理化。 </p><p>对业务和数据库进行拆分，简化系统复杂度和独立演进。 </p><p>关注与服务治理和监控，系统稳定和可用性。 </p><p>引入分布式缓存，分布式文件系统， </p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416072625.png" alt="image-20210416072625664"></p><p>数据库 </p><p>负载均衡 </p><p>静态资源 </p><p>用户请求 </p><p>用户请求 </p><p>用户请求 </p><p>服务B集群 </p><p>服务A集群 </p><p>服务C集群 </p><p>API网关 </p><p>服务治理 </p><p>数据库 </p><p>数据库 </p><p>集群 </p><p>可观测性 </p><p>分布式事务 </p><p>权限认证 </p><p>流控安全</p><p><strong>架构发展演化–以电商为例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416072640.png" alt="image-20210416072640085"></p><h2 id="第-27-课-3-架构设计形式与方法"><a href="#第-27-课-3-架构设计形式与方法" class="headerlink" title="第 27 课 3. 架构设计形式与方法"></a>第 27 课 3. 架构设计形式与方法</h2><h3 id="架构的形式-以文档和代码呈现"><a href="#架构的形式-以文档和代码呈现" class="headerlink" title="架构的形式: 以文档和代码呈现"></a><strong>架构的形式: 以文档和代码呈现</strong></h3><p>我们一般说的<code>架构既包括架构的设计过程，也包括设计的产出物，一般可以包括各类设计文档、设计图，也可以包括一些技术验证代码、Demo或者其他相关程序。</code>文档的目 的在于准确记录我们的思维产物，在软件尚未实现时，作为指导蓝图，尽量精确的描述 清楚软件。 </p><p>在软件已经实现以后，部署运行的软件实例和代码只能说明软件目前是什么状态的，却 无法告诉我们这个软件系统中间的决策信息。 </p><p>一个软件系统的长期稳定发展，必然需要一个可靠的、随着软件本身的维护不断同步更 新的文档作为每次变更的出发点。这样，我们可以随时沿着架构相关的文档逆流而上， 了解这个软件系统从整体到具体的设计思路。 </p><p>同时文档作为结项或交接的一部分，也是整个软件项目的产出物的一部分，成为公司IT 资产的有机组成部分。</p><p><strong>架构的形式: 以文档和代码呈现</strong> </p><p><code>文档是设计的载体，代码是系统功能实现的载体</code>，技术和业务最终都有很大一部分体现 在代码里。 </p><p>广义上来说，代码和代码里的注释，都可以认为是文档的一部分。社区有一种观点：良 好结构的、可读性强的代码，是最好的“文档”。 </p><p>那么怎么才能写出好的代码呢？关键在于两个词：经验、重构。 </p><p>从代码里，我们可以很直观的了解到，程序做了什么、不能做到什么，以及能做到什么 程度，以及其与相关的文档（包括业务文档和技术文档）是否一致。但是代码不适合作 为唯一的“文档”，只有代码没有其他文档，就像是一部只有结尾没有开头和过程的电影。 我们只能了解到这个系统的一个现在时间点的切面影像。</p><h3 id="如何用文档说清楚架构设计呢？"><a href="#如何用文档说清楚架构设计呢？" class="headerlink" title="如何用文档说清楚架构设计呢？"></a><strong>如何用文档说清楚架构设计呢？</strong></h3><p>为了清晰的描述软件架构设计，我们就引入了一个概念：架构视图。什么是架构视图呢？ </p><p>Philippe Kruchten在其著作《Rational统一过程引论》中写道： </p><p><em>一个架构视图是对于从某一视角或某一点上看到的系统所做的简化描述，描述中涵盖了系统的某一特定方面，而省略了于此方面无关的实体。</em> </p><p>也就是说我们可以使用从不同视角分别描述同一个架构设计，最后把这多个视角的设计 综合到一起，就是这个系统的完整架构设计了。这些不同角度的设计文档，也成为了我 们理解一个系统的基本依据。 </p><p>一个新的问题是：哪些视角可以作为全面描述一个系统架构的最核心视图呢？1995年， Philippe Kruchten在《IEEE Software》上发表了论文《4+1架构视图模型（The 4+1 View Model of Architecture）》，正式提出了使用场景视图、逻辑视图、开发视图、 进程视图、物理视图五个方面来描述架构设计，引起了业界的极大关注，并最终被后来 隶属于IBM的Rational软件公司统一软件开发过程方法论（Rational Unified Process， 简称RUP）所采纳。</p><h3 id="如何用文档说清楚架构设计呢？-1"><a href="#如何用文档说清楚架构设计呢？-1" class="headerlink" title="如何用文档说清楚架构设计呢？"></a><strong>如何用文档说清楚架构设计呢？</strong></h3><p>在4+1视图模型中，不同架构视图承载不同的架构设计决策，支持不同的目标和用途。 </p><p>概括来说，我们可以从场景视图的功能需求、逻辑视图的对象与交互、进程视图的进程 与通信、开发视图的项目开发组织结构、物理视图的网络与机器部署结构等这五个方面 来描述一个系统的架构设计，并形成文档、设计图等设计输出物，用于指导后续的软件 实现、测试、部署与维护等过程。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416073031.png" alt="image-20210416073031402"></p><p>\1. 用例视图（Use Cases View）：也叫场景视图，关注最终用户需求，为整个技术架构的上线文环境，通 </p><p>常用UML用例图和活动图描述。 </p><p>\2. 逻辑视图（Logical view）：主要是整个系统的抽象结构表述，关注系统提供最终用户的功能，不涉及具 </p><p>体的编译即输出和部署，通常在UML中用类图，交互图，时序图来表述，类似与我们采用OOA的对象模 </p><p>型。 </p><p>\3. 开发视图（Development View）：描述软件在开发环境下的静态组织，从程序实现人员的角度透视系统， </p><p>也叫做实现视图（Implementation View）。开发视图关注程序包，不仅包括要编写的源程序，还包括可 </p><p>以直接使用的第三方SDK和现成框架、类库，以及开发的系统将运行于其上的系统软件或中间件, 在UML </p><p>中用组件图，包图来表述。开发视图和逻辑视图之间可能存在一定的映射关系：比如逻辑层一般会映射到 </p><p>多个程序包等。 </p><p>\4. 进程视图（Process view）：进程视图关注系统动态运行时，主要是进程以及相关的并发、同步、通信等 </p><p>问题。进程视图和开发视图的关系：开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运 </p><p>行起来之后会表现为对象、线程、进程，进程视图比较关注的正是这些运行时单元的交互问题，在UML中 </p><p>通常用活动图表述。 </p><p>\5. 物理视图（Physical view ）：物理视图通常也叫做部署视图(Deployment View)，是从系统工程师解读系 </p><p>统，关注软件的物流拓扑结，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求。物理 </p><p>视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位 </p><p>置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。</p><h3 id="更为系统化的架构方法论-TOGAF"><a href="#更为系统化的架构方法论-TOGAF" class="headerlink" title="更为系统化的架构方法论-TOGAF"></a><strong>更为系统化的架构方法论-TOGAF</strong></h3><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416073058.png" alt="image-20210416073058805" style="zoom:33%;"><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210416073116.png" alt="image-20210416073116614" style="zoom:50%;"><h2 id="第-27-课-4-架构的一些实践经验架构设计服务于业务"><a href="#第-27-课-4-架构的一些实践经验架构设计服务于业务" class="headerlink" title="第 27 课 4. 架构的一些实践经验架构设计服务于业务"></a>第 27 课 4. 架构的一些实践经验<strong>架构设计服务于业务</strong></h2><p>正如19世纪的伟大建筑师路易斯•沙利文（Louis Sullivan）倡导的建筑设计著名格言： </p><p>“功能决定形式（Form follows function）”，软件架构首先是要服务于业务功能的。 </p><p>设计一栋大楼不管美不美观、大气不大气，首先需要考虑的是这栋大楼是做什么用得， </p><p>是要开一个百货公司、还是一个跨国集团的总部大楼、还是当地市政府的办公大楼。 </p><p>同理，架构首先也需要对业务负责。而业务也并非都是一成不变的，随着市场环境的变 </p><p>化、用户习惯的变化、竞争格局的变化，业务形态也一直在顺应环境而改变，架构设计 </p><p>也需要考虑系统在未来的一段时间内支撑这种调整。并且在满足了业务需求和一定的前 </p><p>瞻性的基础上，综合考虑成本、周期、效率、速度、风险等因素。</p><h3 id="架构影响研发团队的组织形式"><a href="#架构影响研发团队的组织形式" class="headerlink" title="架构影响研发团队的组织形式"></a><strong>架构影响研发团队的组织形式</strong></h3><p>业务拆分的方法和技术框架的选择必然会影响到研发团队的组织形式。 </p><p>业务拆分的越细致，越有利于我们更好的对项目的各项指标量化计算，更精确的估计工 </p><p>时和成本，从而指导我们每个小组应该分配多少资源，使用什么样的协同和任务确认形 </p><p>式。</p><p>反过来，研发组织的结构和成熟度也会对我们最终所采取的技术架构产生重要的影响。 </p><p>比如一个由3个初级程序员组成的创业小团队不适于采取特别复杂且小众的开发框架。 </p><p>相反地，利用快速开发框架或脚手架把产品设计迅速实现应该是团队的核心诉求，所以 </p><p>某种全栈类的全家桶解决方案才可能是最适合的技术选择。</p><h3 id="架构存在于每一个系统"><a href="#架构存在于每一个系统" class="headerlink" title="架构存在于每一个系统"></a><strong>架构存在于每一个系统</strong></h3><p>每一个已经实现并运行的系统，都是特定架构设计的载体。有些系统对应的架构，有详 </p><p>细的设计文档来描述；有些系统的设计文档，残缺不全，甚至还因为在系统的发展变化 </p><p>的同时，文档没有更新，导致设计文档与实际系统不符；有些系统干脆就没有设计文档。 </p><p>但是这些系统，都是基于一定的架构来创建的。 </p><p>每种架构方式，每个具体系统内所体现的架构设计，都是可以被工程师们理解，进而提 </p><p>炼出来一些架构思想和设计原则，这些思想和原则就是这种架构方式的风格。 </p><p>依据这些风格，我们可以将各种架构方式，进行分门别类，从而进一步讨论每种架构风 </p><p>格的特点。例如在实现期的代码形式中，系统由各个相似的类库作为组件构成，在运行 </p><p>期这些组件又同时在同一个进程中，这时我们可以认为这是一种“组件式单体架构风格”。</p><h3 id="架构需要警惕过渡设计"><a href="#架构需要警惕过渡设计" class="headerlink" title="架构需要警惕过渡设计"></a><strong>架构需要警惕过渡设计</strong></h3><p>矫枉过正，过犹不及。 </p><p>过渡设计，是一个特别常见的问题。 </p><p>比如在做架构设计的时候，想当然把问题想复杂了，然后做了过于复杂化的方案。 </p><p>做技术选型的时候，因为自己熟悉和顺手，选了看起来“高大上”，但是实际上不适合的 </p><p>技术或者组件。</p><h3 id="架构需要不断的发展演进"><a href="#架构需要不断的发展演进" class="headerlink" title="架构需要不断的发展演进"></a><strong>架构需要不断的发展演进</strong></h3><p>随着计算机软硬件的不断发展，软件架构思想也在不断的发展变化。同时软件为其提供 </p><p>业务处理和服务能力的每个具体行业领域也在不断发展变化，业务处理流程、参与角色、 </p><p>业务形式不断的推陈出新。 </p><p>这就要求我们在系统架构设计时，保持终身学习的精神，持续吸收新思想新知识，保持 </p><p>贴近一线业务群体，随时因地制宜，调整架构设计，采取最适合当下场景的解决方案。 </p><p>同时对于存量的旧系统的维护与改造，很多时候无法一次达到目标，可以考虑循序渐进， </p><p>设定几个大的里程碑，逐步推进，最终实现比较理想的架构设计。 </p><p>多年以来多很多老旧系统改造的经历，对我影响最深的就是，循序渐进，终达目标，特 </p><p>别是具体的设计实践中，思路和方法，比结论更重要。一个正确的结论在别处可能就是 </p><p>错的，但是思路和方法确实可以复用的。只有通过不断的迭代更新自己的知识和思想， </p><p>才能一直做出来最适合的架构设计。</p><p><strong>第 27 课总结回顾</strong> </p><p><strong>什么是架构设计</strong> </p><p><strong>架构的演化发展</strong> </p><p><strong>架构的形式方法</strong> </p><p><strong>架构的一些经验</strong></p><p><strong>第 27 课作业实践</strong> </p><p>1、（选做）思考一下自己负责的系统，或者做过的系统，能否描述清楚其架构。 </p><p>2、（选做）考虑一下，如果让你做一个针对双十一，某东某宝半价抢100个IPhone的 </p><p>活动系统，你该如何考虑，从什么地方入手。 </p><p>3、（选做）可以自行学习以下参考书的一两本。 </p><p>推荐架构书籍： </p><p>①《软件架构》Mourad Chabane Oussalah </p><p>②《架构实战-软件架构设计的过程》Peter EeLes </p><p>③《软件系统架构-使用视点和视角与利益相关者合作》Nick Rozanski </p><p>④《企业IT架构转型之道》 </p><p>⑤《大型网站技术架构演进与性能优化》 </p><p>⑥《银行信息系统架构》 </p><p>⑦《商业银行分布式架构实践》</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week13-02 第二十六课 分布式消息--其他MQ介绍与动手写MQ</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week13-02%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF--%E5%85%B6%E4%BB%96MQ%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8A%A8%E6%89%8B%E5%86%99MQ/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week13-02%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF--%E5%85%B6%E4%BB%96MQ%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8A%A8%E6%89%8B%E5%86%99MQ/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 26 课</p><p>分布式消息–其他MQ介绍与动手写MQ</p><p><strong>目录</strong></p><ol><li>RabbitMQ</li></ol><p>2.RocketMQ</p><p>3.Pulsar</p><p>4.EIP/Camel/Spring Integration</p><p>5.动手写MQ</p><p>6.总结回顾与作业实践</p><p>第 26 课</p><ol><li>RabbitMQ<strong>安装</strong></li></ol><p>1、直接安装</p><p>brew install rabbitmq //macos</p><p>apt/yum install rabbitmq-server //linux</p><p>choco install rabbitmq //windows</p><blockquote><p>rabbitmq-plugins enable rabbitmq_management</p></blockquote><p>2、docker安装</p><p>docker pull rabbitmq:management # 注意不带后缀就不会有web控制台</p><p>docker run -itd –name rabbitmq-test -e RABBITMQ_DEFAULT_USER=admin -e</p><p>RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management</p><p>docker exec -it rabbitmq-test /bin/bash</p><blockquote><p>rabbitmqctl list_queues、rabbitmqctl status</p></blockquote><blockquote><p>rabbitmqadmin declare queue name=kk01 -u admin -p admin</p></blockquote><blockquote><p>rabbitmqadmin get queue=kk1 -u admin -p admin</p></blockquote><p><strong>rabbitmq的核心概念</strong></p><p>queue/exchange/routekey/binding</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211454.png" alt="image-20210411211454853"></p><p><strong>spring-amqp操作rabbitmq演示</strong></p><p>示例代码。</p><p>1、spring-amqp 凤凰好了 template</p><p>2、rabbitmq-client直接操作</p><p>第 26 课 2. RocketMQ</p><p><strong>安装</strong></p><p>1、直接安装，从<a href="http://rocketmq.apache.org/dowloading/releases/%E4%B8%8B%E8%BD%BD4.8.0">http://rocketmq.apache.org/dowloading/releases/下载4.8.0</a></p><p>解压，即可。</p><p>nohup sh bin/mqnamesrv &amp;</p><p>nohup sh bin/mqbroker -n localhost:9876 &amp;</p><blockquote><p>export NAMESRV_ADDR=localhost:9876</p></blockquote><blockquote><p>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</p></blockquote><blockquote><p>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</p></blockquote><p>参见：<a href="http://rocketmq.apache.org/docs/quick-start/">http://rocketmq.apache.org/docs/quick-start/</a></p><p>docker search rocketmq</p><p>2、docker安装</p><p>挺麻烦的，参见<a href="https://github.com/apache/rocketmq-docker">https://github.com/apache/rocketmq-docker</a></p><p><strong>RocketMQ介绍</strong></p><p>示例代码。</p><p>总体结构</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211510.png" alt="image-20210411211510122"></p><p><strong>RocketMQ介绍</strong></p><p>1、与Kafka的关系</p><p>2、区别：作为Kafka的重新实现版，没太大本质区别（百事~可口）</p><p>1）纯Java开发</p><p>2）支持延迟投递，消息追溯 ==&gt; 说实话，意义不太大</p><p>3）多个队列使用一个日志文件，所以不存在kafka过多topic问题 ==&gt; 这个仁者见仁</p><p>参见 <a href="http://rocketmq.apache.org/docs/motivation/">http://rocketmq.apache.org/docs/motivation/</a></p><p>1、消息都支持堆积</p><p>2、计算和存储是分离的（和palsar的区别）</p><p>3、broker做的事：消息处理，io操作，</p><p><strong>RocketMQ演示</strong></p><p>示例代码。</p><p>第 26 课 3. Pulsar<strong>安装</strong></p><p>1、下载安装</p><p>通过 <a href="http://pulsar.apache.org/zh-CN/download/">http://pulsar.apache.org/zh-CN/download/</a> 下载2.7.0版本</p><p>解压压缩包，即可。详细文档可以参见：<a href="http://pulsar.apache.org/docs/zh-CN/">http://pulsar.apache.org/docs/zh-CN/</a></p><blockquote><p>bin/pulsar standalone</p></blockquote><blockquote><p>bin/pulsar-client consume topic1 -s “first-subscription”</p></blockquote><blockquote><p>bin/pulsar-client produce topic1 –messages “hello-pulsar”</p></blockquote><p>2、Docker安装运行</p><p>参考 <a href="http://pulsar.apache.org/docs/zh-CN/standalone-docker/">http://pulsar.apache.org/docs/zh-CN/standalone-docker/</a></p><p><strong>Pulsar介绍</strong></p><p>基于topic，支持namespace和多租户</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211528.png" alt="image-20210411211528272"></p><p>多租户，可以配置流控，限流</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211841.png" alt="image-20210411211841274"></p><p><strong>Pulsar介绍</strong></p><p>三种消费模式，支持Partition</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411213334.png" alt="image-20210411213334872"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411213349.png" alt="image-20210411213349043"></p><p><strong>Pulsar介绍</strong></p><p>计算存储分离，高可用集群</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411213412.png" alt="image-20210411213412504"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411213431.png" alt="image-20210411213431400"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411213448.png" alt="image-20210411213448521"></p><p><strong>pulsar演示</strong></p><p>示例代码。</p><p>第 26 课 4. EIP</p><p><strong>再谈EIP</strong></p><p>Enterprise Integration</p><p>集成领域的两大法宝，就是RPC和Messaging</p><p>也是所有SOA/ESB的基础。</p><p>两个开源EIP实现框架，Camel和Spring Integration</p><p><strong>还是管道加过滤器模式</strong></p><p>EIP里，所有的处理，都可以看做是：</p><p>1、数据从一个输入源头出发；</p><p>2、数据在一个管道流动；</p><p>3、经过一些处理节点，数据被过滤器处理，增强，或者转换，或者做个业务处理等等。</p><p>4、最后，数据输出到一个目的地。</p><p><strong>以Camel为例</strong></p><p>做个好玩的demo：</p><p>把ActiveMQ的消息，自动转移到RabbitMQ。</p><p>ActiveMQ → Camel → RabbitMQ</p><p><a href="https://kimmking.blog.csdn.net/article/details/24427383">https://kimmking.blog.csdn.net/article/details/24427383</a></p><p>好处</p><p>1、RabbitMQ和ActiveMQ互相发送消息，但是不用集成，任意数据和mq打通，现在技术往流式发展的原因</p><p>第 26 课 5. 动手写MQ</p><p><strong>第一个版本-内存Queue</strong></p><p>1、基于内存Queue实现生产和消费API（已经完成）</p><p>1）创建内存BlockingQueue，作为底层消息存储</p><p>2）定义Topic，支持多个Topic</p><p>3）定义Producer，支持Send消息</p><p>4）定义Consumer，支持Poll消息</p><p><strong>第二个版本：自定义Queue</strong></p><p>2、去掉内存Queue，设计自定义Queue，实现消息确认和消费offset</p><p>1）自定义内存Message数组模拟Queue。</p><p>2）使用指针记录当前消息写入位置。</p><p>3）对于每个命名消费者，用指针记录消费位置。</p><p>在内存中数据没有删除，会发生OOM</p><p><strong>2小时33分，再看一遍</strong></p><p><strong>第三个版本：基于SpringMVC实现MQServer</strong></p><p>3、拆分broker和client(包括producer和consumer)</p><p>1）将Queue保存到web server端</p><p>2）设计消息读写API接口，确认接口，提交offset接口</p><p>3）producer和consumer通过httpclient访问Queue</p><p>4）实现消息确认，offset提交</p><p>5）实现consumer从offset增量拉取</p><p><strong>第四个版本：功能完善MQ</strong></p><p>4、增加多种策略（各条之间没有关系，可以任意选择实现）</p><p>1）考虑实现消息过期，消息重试，消息定时投递等策略</p><p>2）考虑批量操作，包括读写，可以打包和压缩</p><p>2）考虑消息清理策略，包括定时清理（每天12点清理），按容量清理（保存100w消息，多的话新的丢弃；或者旧的丢弃），LRU（三种清理策略）等</p><p>3）考虑消息持久化，存入数据库，或WAL日志文件，或BookKeeper</p><p>4）考虑将spring mvc替换成netty下的tcp传输协议，rsocket/websocket（复用的http，全双工的）</p><p><strong>第五个版本：体系完善MQ</strong></p><p>5、对接各种技术（各条之间没有关系，可以任意选择实现）</p><p>1）考虑封装 JMS 1.1 接口规范</p><p>2）考虑实现 STOMP 消息规范（发送一条命令，跟上文本响应的报文）</p><p>3）考虑实现消息事务机制与事务管理器</p><p>4）对接Spring</p><p>5）对接Camel或Spring Integration</p><p>6）优化内存和磁盘的使用</p><p><strong>第 26 课总结回顾</strong></p><p><strong>RabbitMQ</strong></p><p><strong>RocketMQ</strong></p><p><strong>Pulsar</strong></p><p><strong>EIP/Camel</strong></p><p><strong>动手做MQ</strong></p><p><strong>第 26 课作业实践</strong></p><p>1、（选做）自己安装和操作RabbitMQ，RocketMQ，Pulsar，以及Camel和Spring Integration。</p><p>2、（必做）思考和设计自定义MQ第二个版本或第三个版本，写代码实现其中至少一</p><p>个功能点，把设计思路和实现代码，提交到github。</p><p>3、（挑战☆☆☆☆☆）完成其他版本的要求。</p><p>Q：kafka和rabbitmq分别适合在哪些场景使用</p><p>RE：Kafka或者Pulsar，适合超大规模的海量消息。</p><p>Q：rocket一个文件，queue消费有的快有点慢，那不还是得随机访问</p><p>RE：rocketmq单机效率低于kafka</p><p>1、单个文件，随机操作</p><p>2、处理的策略上，比kafka更复杂一点</p><p>Q：单个文件是没有partion吗</p><p>RE：所有消息都入 commitlog 一个文件，partition 是在另外的文件里保存的，但仅保存了消息在 commitlog 里的 offset和一些元数据</p><p>Q：camel应用</p><p>RE：esb 底层要么是 camel 要么是spring Integration；esb的骨架</p><p>Q：作业  activemq -&gt; kafka -&gt; rabbitmq -&gt; pulsar -&gt; redis -&gt; mysql -&gt; file.</p><p>RE：ok</p><p>Q：一个MQ涉及到，磁盘，内存，网络io，分区，多副本，一致性</p><p>RE：</p><p>Q：阿里要数据库底层或者MQ原理的人</p><p>RE：</p><p>Q：RPC没有状态，MQ就是一个退化的数据库</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week13-01 第二十五课 分布式消息--Kafka消息中间件</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week13-01%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF--Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week13-01%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF--Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 25 课</p><p>分布式消息–Kafka消息中间件</p><p>1、Kafka概念和入门</p><p>2.Kafka的简单使用*</p><p>3.Kafka的集群配置*</p><p>4.Kafka的高级特性*</p><p>5.总结回顾与作业实践</p><p>第 25 课 1. Kafka概念与入门</p><p><strong>什么是Kafka</strong></p><p>Kafka 是一个消息系统，由 LinkedIn 于2011年设计开发，用作 LinkedIn 的活动流</p><p>（Activity Stream）和运营数据处理管道（Pipeline）的基础。</p><p>Kafka 是一种分布式的，基于发布 / 订阅的消息系统。主要设计目标如下：</p><ol><li>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。</li><li>支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out：支持在线水平扩展。</li></ol><p><strong>Kafka的基本概念</strong></p><ol><li>Broker：Kafka 集群包含一个或多个服务器，这种服务器被称为 broker。  broker，proxy，agent有啥区别？</li><li>Topic：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。</li><li>Partition：Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition。</li><li>Producer：负责发布消息到 Kafka broker。</li><li>Consumer：消息消费者，向 Kafka broker 读取消息的客户端。</li><li>Consumer Group：每个 Consumer 属于一个特定的 Consumer Group（可为每个Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</li></ol><p><strong>单机部署结构</strong></p><p>Kafka 单机消息处理</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210753.png" alt="image-20210411210753804"></p><p><strong>集群部署结构</strong></p><p>Kafka 集群消息处理</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210811.png" alt="image-20210411210811674"></p><p><strong>Topic和Partition</strong></p><p>多Partition支持水平扩展和并行处理，顺序写入提升吞吐性能</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210837.png" alt="image-20210411210837643"></p><p><strong>Partition和Replica</strong></p><p>每个partition可以通过副本因子添加多个副本</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210854.png" alt="image-20210411210854207"></p><p><strong>Topic特性</strong></p><p><strong>1. 通过partition增加可扩展性 == 可以那么做，但是会有抖动</strong></p><p><strong>2. 通过顺序写入达到高吞吐 == 提高io速率</strong></p><p><strong>3. 多副本增加容错性</strong></p><p>第 25 课</p><ol><li>Kafka的简单使用</li></ol><p><strong>单机安装部署</strong></p><p>1、kafka安装</p><p><a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></p><p>下载2.6.0或者2.7.0，解压。</p><p>2、启动kafka：</p><p>命令行下进入kafka目录</p><p>修改配置文件 vim config/server.properties</p><p>打开 listeners=PLAINTEXT://localhost:9092</p><p>./bin/zookeeper-server-start.sh config/zookeeper.properties</p><p>./bin/kafka-server-start.sh config/server.properties</p><p><strong>单机部署测试</strong></p><p>3、命令行操作Kafka</p><p>bin/kafka-topics.sh –zookeeper localhost:2181 –list</p><p>生产者创建topic：</p><p>bin/kafka-topics.sh –zookeeper localhost:2181 –create –topic testk –partitions 4 –</p><p>replication-factor 1</p><p>bin/kafka-topics.sh –zookeeper localhost:2181 –describe –topic testk</p><p>消费者监听：</p><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –from-beginning –</p><p>topic testk</p><p>bin/kafka-console-producer.sh –bootstrap-server localhost:9092 –topic testk</p><p>4、简单性能测试</p><p>bin/kafka-producer-perf-test.sh –topic testk –num-records 100000 –record-size</p><p>1000 –throughput 2000 –producer-props bootstrap.servers=localhost:9092</p><p>bin/kafka-consumer-perf-test.sh —bootstrap-server localhost:9092 –topic testk –</p><p>fetch-size 1048576 –messages 100000 –threads  1</p><p><strong>Java中使用kafka发送接收消息</strong></p><p>基于Kafka Client发送和接收消息–极简生产者</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210917.png" alt="image-20210411210916965"></p><p><strong>Java中使用kafka发送接收消息</strong></p><p>基于Kafka Client发送和接收消息–极简消费者</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210934.png" alt="image-20210411210934488"></p><p>第 25 课</p><ol><li>Kafka的集群配置</li></ol><p><strong>集群安装部署01</strong></p><p>1、现在我们来部署3个节点的集群，首选准备3个配置文件(kafka900x.properties)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210955.png" alt="image-20210411210955282"></p><p><strong>集群安装部署02</strong></p><p>2、清理掉zk上的所有数据，可以删除zk的本地文件或者用ZooInspector操作</p><p>3、启动3个kafka：</p><p>三个命令行下进入kafka目录，分别执行</p><p>./bin/kafka-server-start.sh kafka9001.properties</p><p>./bin/kafka-server-start.sh kafka9002.properties</p><p>./bin/kafka-server-start.sh kafka9003.properties</p><p>完成启动操作。</p><p><strong>集群安装部署03</strong></p><p>4、执行操作测试</p><p>创建带有副本的topic：</p><p>bin/kafka-topics.sh –zookeeper localhost:2181 –create –topic test32 –partitions 3 -</p><p>replication-factor 2</p><p>bin/kafka-console-producer.sh –bootstrap-server localhost:9003 –topic test32</p><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9001 –topic test32 –</p><p>from-beginning</p><p>执行性能测试：</p><p>bin/kafka-producer-perf-test.sh –topic test32 –num-records 100000 –record-size</p><p>1000 –throughput 2000 –producer-props bootstrap.servers=localhost:9002</p><p>bin/kafka-consumer-perf-test.sh –bootstrap-server localhost:9002 –topic test32 –</p><p>fetch-size 1048576 –messages 100000 –threads 1</p><p><strong>集群与多副本的说明</strong></p><p>1、ISR</p><p>2、rebalance</p><p>3、热点分区</p><h2 id="第-25-课-4-Kafka的高级特性"><a href="#第-25-课-4-Kafka的高级特性" class="headerlink" title="第 25 课 4. Kafka的高级特性"></a>第 25 课 4. Kafka的高级特性</h2><p><strong>生产者-执行步骤</strong></p><p>客户端实现序列化，分区，压缩操作</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211021.png" alt="image-20210411211021432"></p><p><strong>生产者-确认模式</strong></p><p>ack=0 : 只发送不管有没有写入到broker</p><p>ack=1：写入到leader就认为成功</p><p>ack=all：写入到最小的复本数则认为成功</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211041.png" alt="image-20210411211041885"></p><p><strong>生产者特性-同步发送</strong></p><p>同步发送</p><p>KafkaProducer kafkaProducer = new KafkaProducer(pro);</p><p>ProducerRecord record = new ProducerRecord(“topic”, “key”, “value”);</p><p>Future future = kafkaProducer.send(record);</p><p>//同步发送方法1</p><p>Object o = future.get();</p><p>//同步发送方法2</p><p>kafkaProducer.flush();</p><p><strong>生产者特性-异步发送</strong></p><p>异步发送</p><p>pro.put(“<a href="http://linger.ms/">linger.ms</a>“, “1”);</p><p>pro.put(“batch.size”, “10240”);</p><p>KafkaProducer kafkaProducer = new KafkaProducer(pro);</p><p>ProducerRecord record = new ProducerRecord(“topic”, “key”, “value”);</p><p>Future future = kafkaProducer.send(record);</p><p>//异步发送方法1</p><p>kafkaProducer.send(record, (metadata, exception) -&gt; {</p><p>if (exception == null) System.out.println(“record = “ + record);</p><p>});</p><p>//异步发送方法2</p><p>kafkaProducer.send(record);</p><p><strong>生产者特性-顺序保证</strong></p><p>顺序保证</p><p>pro.put(“max.in.flight.requests.per.connection”, “1”);</p><p>KafkaProducer kafkaProducer = new KafkaProducer(pro);</p><p>ProducerRecord record = new ProducerRecord(“topic”, “key”, “value”);</p><p>Future future = kafkaProducer.send(record);</p><p>//同步发送</p><p>kafkaProducer.send(record);</p><p>kafkaProducer.flush();</p><p><strong>生产者特性-消息可靠性传递</strong></p><p>pro.put(“enable.idempotence”,”true”); // 此时就会默认把acks设置为all</p><p>pro.put(“<a href="http://transaction.id/">transaction.id</a>“,”tx0001”);</p><p>try {</p><p>kafkaProducer.beginTransaction();</p><p>ProducerRecord record = new ProducerRecord(“topic”, “key”, “value”);</p><p>for (int i = 0; i &lt; 100; i++) {</p><p>kafkaProducer.send(record, (metadata, exception) -&gt; {</p><p>if (exception != null) {</p><p>kafkaProducer.abortTransaction();</p><p>throw new KafkaException(exception.getMessage() + “ , data: “ + record);</p><p>} }); }</p><p>kafkaProducer.commitTransaction();</p><p>} catch (Throwable e) {</p><p>kafkaProducer.abortTransaction();</p><p>}</p><p><strong>消费者-Consumer Group</strong></p><p>消费者与Partition对应关系</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211114.png" alt="image-20210411211114401"></p><p><strong>消费者特性-Offset同步提交</strong></p><p>props.put(“enable.auto.commit”,”false”);</p><p>while (true) {</p><p>//拉取数据</p><p>ConsumerRecords poll = consumer.poll(Duration.ofMillis(100));</p><p>poll.forEach(o -&gt; {</p><p>ConsumerRecord&lt;String, String&gt; record = (ConsumerRecord) o;</p><p>Order order = JSON.parseObject(record.value(), Order.class);</p><p>System.out.println(“order = “ + order);</p><p>});</p><p>consumer.commitSync();</p><p>}</p><p><strong>消费者特性-Offset异步提交</strong></p><p>props.put(“enable.auto.commit”,”false”);</p><p>while (true) {</p><p>//拉取数据</p><p>ConsumerRecords poll = consumer.poll(Duration.ofMillis(100));</p><p>poll.forEach(o -&gt; {</p><p>ConsumerRecord&lt;String, String&gt; record = (ConsumerRecord) o;</p><p>Order order = JSON.parseObject(record.value(), Order.class);</p><p>System.out.println(“order = “ + order);</p><p>});</p><p>consumer.commitAsync();</p><p>}</p><p><strong>消费者特性-Offset自动提交</strong></p><p>props.put(“enable.auto.commit”,”true”);</p><p>props.put(“<a href="http://auto.commit.interval.ms/">auto.commit.interval.ms</a>”,”5000”);</p><p>while (true) {</p><p>//拉取数据</p><p>ConsumerRecords poll = consumer.poll(Duration.ofMillis(100));</p><p>poll.forEach(o -&gt; {</p><p>ConsumerRecord&lt;String, String&gt; record = (ConsumerRecord) o;</p><p>Order order = JSON.parseObject(record.value(), Order.class);</p><p>System.out.println(“order = “ + order);</p><p>});</p><p>}</p><p><strong>消费者特性-Offset Seek</strong></p><p>props.put(“enable.auto.commit”,”true”);</p><p>//订阅topic</p><p>consumer.subscribe(Arrays.asList(“demo-source”), new ConsumerRebalanceListener() {</p><p>@Override</p><p>public void onPartitionsRevoked(Collection<topicpartition> partitions) {</topicpartition></p><p>commitOffsetToDB();</p><p>}</p><p>@Override</p><p>public void onPartitionsAssigned(Collection<topicpartition> partitions) {</topicpartition></p><p>partitions.forEach(topicPartition -&gt; consumer.seek(topicPartition,</p><p>getOffsetFromDB(topicPartition)));</p><p>}</p><p>});</p><p><strong>消费者特性-Offset Seek</strong></p><p>while (true) {</p><p>//拉取数据</p><p>ConsumerRecords poll = consumer.poll(Duration.ofMillis(100));</p><p>poll.forEach(o -&gt; {</p><p>ConsumerRecord&lt;String, String&gt; record = (ConsumerRecord) o;</p><p>processRecord(record);</p><p>saveRecordAndOffsetInDB(record, record.offset());</p><p>});</p><p>}</p><p><strong>第 25 课总结回顾</strong></p><p><strong>Kafka入门</strong></p><p><strong>Kafka简单使用</strong></p><p><strong>Kafka集群部署</strong></p><p><strong>Kafka高级特性</strong></p><p><strong>第 25 课作业实践</strong></p><p>1、（必做）搭建一个3节点Kafka集群，测试功能和性能；实现spring kafka下对kafka集群</p><p>的操作，将代码提交到github。</p><p>2、（选做）安装kafka-manager工具，监控kafka集群状态。</p><p>3、（挑战☆）演练本课提及的各种生产者和消费者特性。</p><p>4、（挑战☆☆☆）Kafka金融领域实战：在证券或者外汇、数字货币类金融核心交易系统里，</p><p>对于订单的处理，大概可以分为收单、定序、撮合、清算等步骤。其中我们一般可以用mq来</p><p>实现订单定序，然后将订单发送给撮合模块。</p><p>1）收单：请实现一个订单的rest接口，能够接收一个订单Order对象；</p><p>2）定序：将Order对象写入到kafka集群的order.usd2cny队列，要求数据有序并且不丢失；</p><p>3）撮合：模拟撮合程序（不需要实现撮合逻辑），从kafka获取order数据，并打印订单信息，</p><p>要求可重放, 顺序消费, 消息仅处理一次。</p><p>Q：一个topic，一般分多少个partition比较合适？</p><p>RE：单个机器上，不建议有多个partition，也不建议有大量的topic，一个topic至少需要【对应】一个partition，因为他们对应这一个数据文件。单个机器上，数据文件打了，就意味着，随机io读写了</p><p><a href="https://www.zhihu.com/question/300144434">https://www.zhihu.com/question/300144434</a></p><p>Q：kafka可视化控制台是啥？</p><p>RE：kafka-manager</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211203.png" alt="image-20210411211203903"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211221.png" alt="image-20210411211221471"></p><p>会</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211235.png" alt="image-20210411211235230"></p><p>这个kafka系列文章非常棒：<a href="https://www.infoq.cn/article/kafka-analysis-part-1/">https://www.infoq.cn/article/kafka-analysis-part-1/</a></p><p><a href="https://github.com/JavaCourse00/JavaCourseCodes/tree/main/09mq/kafka-demo">https://github.com/JavaCourse00/JavaCourseCodes/tree/main/09mq/kafka-demo</a></p><p>mapstuct 比 beanUtils好用</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411211251.png" alt="image-20210411211250984"></p><p>1、顺序这块，同步发送的顺序保障，可以以rest，produder，broker为准</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week12-01 第二十三课 分布式缓存-Redis高可用/Redisson/Hazelcast</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week12-01%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Redis%E9%AB%98%E5%8F%AF%E7%94%A8RedissonHazelcast/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week12-01%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Redis%E9%AB%98%E5%8F%AF%E7%94%A8RedissonHazelcast/</url>
      
        <content type="html"><![CDATA[<p>其他：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411183902.png" alt="image-20210411183902237"></p><p>tcc try成功了就是成功了，相当于资金担保了</p><h1 id="第-23-课"><a href="#第-23-课" class="headerlink" title="第 23 课"></a>第 23 课</h1><h1 id="分布式缓存-Redis高可用-Redisson-Hazelcast"><a href="#分布式缓存-Redis高可用-Redisson-Hazelcast" class="headerlink" title="分布式缓存-Redis高可用/Redisson/Hazelcast"></a>分布式缓存-Redis高可用/Redisson/Hazelcast</h1><p><strong>目录</strong></p><ol><li>Redis集群与高可用</li></ol><p>2.Redisson介绍</p><p>3.Hazelcast介绍</p><p>4.总结回顾与作业实践第</p><h2 id="23-课-1-Redis的集群与高可用"><a href="#23-课-1-Redis的集群与高可用" class="headerlink" title="23 课 1. Redis的集群与高可用"></a>23 课 1. Redis的集群与高可用</h2><p><strong>Redis 主从复制：从单机到多节点</strong></p><p>极简的风格, 从节点执行:</p><blockquote><p>SLAVEOF 127.0.0.1 6379</p></blockquote><p>也可以在配置文件中设置。</p><p>注意：从节点只读、异步复制。无法保证数据同步</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411185425.png" alt="image-20210411185425542"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411185449.png" alt="image-20210411185449912"></p><p><strong>Redis Sentinel 主从切换：走向高可用  ~ MHA</strong></p><p>可以做到监控主从节点的在线状态，并做切换（基于raft协议）。</p><p>两种启动方式：</p><blockquote><p>redis-sentinel sentinel.conf</p></blockquote><blockquote><p>redis-server redis.conf –sentinel</p></blockquote><p>sentinel.conf配置：</p><p>sentinel monitor mymaster 127.0.0.1 6379 2</p><p>sentinel down-after-milliseconds mymaster 60000</p><p>sentinel failover-timeout mymaster 180000</p><p>sentinel parallel-syncs mymaster 1</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204309.png" alt="image-20210411204309577"></p><p>不需要配置从节点，也不需要配置其他sentinel信息</p><p>redis sentinel原理介绍：<a href="http://www.redis.cn/topics/sentinel.html">http://www.redis.cn/topics/sentinel.html</a></p><p>redis复制与高可用配置：<a href="https://www.cnblogs.com/itzhouq/p/redis5.html">https://www.cnblogs.com/itzhouq/p/redis5.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204321.png" alt="image-20210411185505532"></p><p><strong>Redis Cluster：走向分片 ~ 分全自动库分表</strong></p><p>主从复制从容量角度来说，还是单机。</p><p>Redis Cluster通过一致性hash的方式，将数据分散到多个服务器节点：先设计 16384</p><p>个哈希槽，分配到多台redis-server。当需要在 Redis Cluster中存取一个 key时，</p><p>Redis 客户端先对 key 使用 crc16 算法计算一个数值，然后对 16384 取模，这样每个</p><p>key 都会对应一个编号在 0-16383 之间的哈希槽，然后在 此槽对应的节点上操作。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204339.png" alt="image-20210411204339896"></p><blockquote><p>cluster-enabled yes</p></blockquote><p>注意：</p><p>1、节点间使用gossip通信，规模&lt;1000</p><p>2、默认所有槽位可用，才提供服务</p><p>3、一般会配合主从模式使用</p><p>redis cluster介绍：<a href="http://redisdoc.com/topic/cluster-spec.html">http://redisdoc.com/topic/cluster-spec.html</a></p><p>redis cluster原理：<a href="https://www.cnblogs.com/williamjie/p/11132211.html">https://www.cnblogs.com/williamjie/p/11132211.html</a></p><p>redis cluster详细配置：<a href="https://www.cnblogs.com/renpingsheng/p/9813959.html">https://www.cnblogs.com/renpingsheng/p/9813959.html</a></p><p>*<em>Java中配置使用Redis Sentinel **</em></p><p>代码示例 &amp;&amp; 作业</p><p><strong>Java中配置使用Redis Cluster</strong></p><p>代码示例 &amp;&amp; 作业</p><h2 id="第-23-课-2-Redission介绍Redis-的Java分布式组件库-Redission"><a href="#第-23-课-2-Redission介绍Redis-的Java分布式组件库-Redission" class="headerlink" title="第 23 课 2. Redission介绍Redis 的Java分布式组件库-Redission"></a>第 23 课 2. Redission介绍<strong>Redis 的Java分布式组件库-Redission</strong></h2><p>基于Netty NIO，API线程安全。</p><p>亮点：大量丰富的分布式功能特性，比如JUC的线程安全集合和工具的分布式版本，分</p><p>布式的基本数据类型和锁等。</p><p>官网：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><p><strong>Redission</strong></p><p>示例1：</p><p>分布式锁，RLock</p><p>示例2：</p><p>分布式的Map，RMap</p><p>代码演示。</p><h2 id="第-23-课-3-Hazelcast介绍内存网格-Hazelcast"><a href="#第-23-课-3-Hazelcast介绍内存网格-Hazelcast" class="headerlink" title="第 23 课 3. Hazelcast介绍内存网格 - Hazelcast"></a>第 23 课 3. Hazelcast介绍<strong>内存网格 - Hazelcast</strong></h2><p>Hazelcast IMGD(in-memory data grid) 是一个标准的内存网格系统；它具有以下的一</p><p>些基本特性：</p><ol><li>分布式的：数据按照某种策略尽可能均匀的分布在集群的所有节点上。</li><li>高可用：集群的每个节点都是 active 模式，可以提供业务查询和数据修改事务；部分节点不可用，集群依然可以提供业务服务。</li><li>可扩展的：能按照业务需求增加或者减少服务节点。</li><li>面向对象的：数据模型是面向对象和非关系型的。在 java 语言应用程序中引入hazelcast client api是相当简单的。</li><li>低延迟：基于内存的，可以使用堆外内存。</li></ol><p>文档：<a href="https://docs.hazelcast.org/docs/4.1.1/manual/html-single/index.html">https://docs.hazelcast.org/docs/4.1.1/manual/html-single/index.html</a></p><p><strong>内存网格 - Hazelcast 架构</strong></p><p>![image-20210411204410996](/Users/cutie/Library/Application Support/typora-user-images/image-20210411204410996.png)</p><p><strong>内存网格 - Hazelcast 部署模式</strong></p><p>Client-Server模式</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204428.png" alt="image-20210411204427944"></p><p>嵌入（Embedded）模式</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204443.png" alt="image-20210411204443527"></p><p><strong>内存网格 - Hazelcast 数据分区</strong></p><p>以 Map 结构说明如下：</p><p>数据集默认分为 271 个分区；可以通过 hazelcast.partition.count 配置修改。</p><p>所有分区均匀分布在集群的所有节点上；同一个节点不会同时包含一个分区的多个副本(副本总是</p><p>分散的以保证高可用)。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204510.png" alt="image-20210411204510370"></p><p>副本配置:</p><hazelcast><map name="default"><p><backup-count>0</backup-count></p><p><async-backup-count>1</async-backup-count></p></map></hazelcast><p><strong>内存网格 - Hazelcast 集群与高可用</strong></p><p>1、AP，集群自动管理，</p><p>2、扩容和弹性，分区自动rebalance，业务无感知，</p><p>3、相关问题：</p><p><strong>内存网格 - Hazelcast 事务支持</strong></p><p>支持事务操作：</p><p>TransactionContext context = hazelcastInstance.newTransactionContext(options);</p><p>context.beginTransaction();</p><p>try {</p><p>// do other things</p><p>context.commitTransaction();</p><p>} catch (Throwable t) {</p><p>context.rollbackTransaction();</p><p>}</p><p>支持两种事务类型：</p><p>ONE_PHASE: 只有一个提交阶段；在节点宕机等情况下可能导致系统不一致；</p><p>TWO_PHASE: 在提交前增减一个 prepare 阶段；该阶段检查提价冲突，然后将commit log 拷贝到一个本分</p><p>节点；如果本节点宕机，备份节点会完成事务提交动作；</p><p><strong>内存网格 - Hazelcast 数据亲密性</strong></p><p>确保业务相关的数据在同一个集群节点上，避免操作多个数据的业务事务在执行中通过网络请求</p><p>数据，从而实现更低的事务延迟。</p><ol><li>通过 PartitionAware 接口，可以将相关数据定位在相同的节点上；</li></ol><p>public interface PartitionAware<t> {</t></p><p>T getPartitionKey();</p><p>}</p><ol><li>自定义：PartitioningStrategy</li></ol><map name="name-of-the-map"><partition-strategy><p>com.hazelcast.partition.strategy.StringAndPartitionAwarePartitioningStrategy</p></partition-strategy></map><p><strong>内存网格 - Hazelcast 控制台</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204536.png" alt="image-20210411204536876"></p><h2 id="第-23-课-4-总结回顾与作业实践"><a href="#第-23-课-4-总结回顾与作业实践" class="headerlink" title="第 23 课 4.总结回顾与作业实践"></a>第 23 课 4.总结回顾与作业实践</h2><p><strong>第 23 课总结回顾</strong></p><p><strong>Redis的集群与高可用</strong></p><p><strong>Redisson</strong></p><p><strong>Hazelcast</strong></p><p><strong>第 23 课作业实践</strong></p><p>1、（必做）配置redis的主从复制，sentinel高可用，Cluster集群。</p><p>2、（选做）练习示例代码里下列类中的作业题：</p><p>08cache/redis/src/main/java/io/kimmking/cache/RedisApplication.java</p><p>3、（选做☆）练习redission的各种功能；</p><p>4、（选做☆☆）练习hazelcast的各种功能；</p><p>5、（选做☆☆☆）搭建hazelcast 3节点集群，写入100万数据到一个map，模拟和演</p><p>示高可用；</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204619.png" alt="image-20210411204619269"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204639.png" alt="image-20210411204639279"></p><p>线上一般是脚本实现的</p><p>高可用使用哨兵</p><p>![image-20210411204714791](/Users/cutie/Library/Application Support/typora-user-images/image-20210411204714791.png)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204739.png" alt="image-20210411204738933"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204756.png" alt="image-20210411204756715"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204817.png" alt="image-20210411204817676"></p><p>Sentinel在集群中相当于什么？  注册中心</p><p>![image-20210411204855188](/Users/cutie/Library/Application Support/typora-user-images/image-20210411204855188.png)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204912.png" alt="image-20210411204912790"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204937.png" alt="image-20210411204937295"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411204956.png" alt="image-20210411204956749"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week12-02 第二十四课 分布式消息--消息队列基础</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week12-02%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF--%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week12-02%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF--%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 24 课</p><p>分布式消息–消息队列基础</p><p><strong>目录</strong></p><ol><li>系统间通信方式</li></ol><p>2.从队列到消息服务</p><p>3.消息模式与消息协议*</p><p>4.ActiveMQ消息中间件</p><p>5.ActiveMQ使用示例*</p><p>6.总结回顾与作业实践</p><p>第 24 课</p><h2 id="1-系统间通信方式"><a href="#1-系统间通信方式" class="headerlink" title="1. 系统间通信方式"></a>1. 系统间通信方式</h2><p>基于文件</p><p>基于共享内存</p><p>基于IPC</p><p>基于Socket</p><p>基于数据库</p><p>基于RPC</p><p>还有没有其他方式？</p><p>各个模式的缺点：</p><p>文件: 明显不方便，不及时</p><p>Socket：使用麻烦，多数情况下不如RPC</p><p>数据库：不实时，但是经常有人拿数据库来模拟消息队列</p><p>RPC：调用关系复杂，同步处理，压力大的时候无法缓冲</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411205936.png" alt="image-20210411205936870"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411205949.png" alt="image-20210411205949392"></p><p>我们期望有一种通信方式：</p><p>可以实现异步的消息通信</p><p>可以简化参与各方的复杂依赖关系（一个A系统down了，很多系统引用，会影响其他子系统；down了之后，A起来还能继续提供的服务）</p><p>可以在请求量很大的时候，缓冲一下 ~ 类比线程池里的Queue</p><p>某些情况下能保障消息的可靠性，甚至顺序</p><p>这就是MQ，Message Queue/Messaging System  ~ 可以类比快递服务</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210004.png" alt="image-20210411210004250"></p><p>第 24 课</p><h2 id="2-从队列到消息服务"><a href="#2-从队列到消息服务" class="headerlink" title="2. 从队列到消息服务"></a>2. 从队列到消息服务</h2><p><strong>从队列到消息服务</strong></p><p>内存里的Queue</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210018.png" alt="image-20210411210018895"></p><p>Message Queue/Messaging System</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210038.png" alt="image-20210411210038380"></p><p><strong>从队列到消息服务</strong></p><p>跟并发冲突问题类似的场景很多</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210056.png" alt="image-20210411210056908"></p><p><strong>MQ的四大作用</strong></p><p>对比其他通信模式，MQ的优势在于：</p><p>异步通信：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作。</p><p>系统解耦：系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成。</p><p>削峰平谷：压力大的时候，缓冲部分请求消息，类似于背压处理。</p><p>可靠通信：提供多种消息模式、服务质量、顺序保障等。</p><p>第 24 课</p><h2 id="3-消息模式与消息协议"><a href="#3-消息模式与消息协议" class="headerlink" title="3. 消息模式与消息协议*"></a>3. 消息模式与消息协议*</h2><p><strong>消息处理模式</strong></p><p>常见的有两种消息模式：</p><p>点对点：PTP，Point-To-Point ==  对应于Queue</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210115.png" alt="image-20210411210114953"></p><p>发布订阅：PubSub，Publish-Subscribe == 对应于Topic</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210127.png" alt="image-20210411210127850"></p><p><strong>消息处理的保障</strong></p><p>三种QoS（注意：这是消息语义的，不是业务语义的）：</p><p>At most once，至多一次，消息可能丢失但是不会重复发送；</p><p>At least once，至少一次，消息不会丢失，但是可能会重复；</p><p>消息重复有种方法</p><p>1、幂等</p><p>2、业务系统里面去重：roaringbitmap</p><p>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</p><p>消息处理的事务性：</p><p>通过确认机制实现事务性；</p><p>可以被事务管理器管理，甚至可以支持XA。</p><p><strong>消息有序性</strong></p><p>同一个Topic或Queue的消息，保障按顺序投递。</p><p>注意：如果做了消息分区，或者批量预取之类的操作，可能就没有顺序了。</p><p><strong>集成领域圣经</strong></p><p><strong>《企业集成模式》</strong></p><p><strong>可以认为是SOA/ESB/MQ等理论基础</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210146.png" alt="image-20210411210146188"></p><p><strong>消息协议</strong></p><p>STOMP</p><p>JMS*  jdbc，j2ee</p><p>AMQP*  rabbitmq，金融</p><p>MQTT*  ibm，物联网</p><p>XMPP  jabber</p><p>Open Messaging    rocketmq</p><p><strong>JMS（Java Message Service）</strong></p><p>关注于应用层的API协议( ~ 类似JDBC)</p><p>Message结构与Queue概念</p><p>Body\Header\Property【存放自定义的数据】, messages types</p><p>Queue\Topic\TemporaryQueue\TemporaryTopic</p><p>Connection\Session\Producer\Consumer\DurableSubscription</p><p>Messaging行为</p><p>PTP&amp;Pub-Sub</p><p>持久化</p><p>事务机制</p><p>确认机制</p><p>临时队列</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210207.png" alt="image-20210411210207385"></p><p><strong>消息队列的通用结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210226.png" alt="image-20210411210226438"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210244.png" alt="image-20210411210243918"></p><p>客户端应用层：发送和接收消息的API接口</p><p>消息模型层：消息、连接、会话、事务等等</p><p>消息处理层：消息交互逻辑定义、持久化</p><p>网络传输层：序列化协议、传输协议、可靠机制</p><p><strong>安全层 管理层</strong></p><p><strong>开源消息中间件/消息队列</strong></p><p>三代：</p><p>1、ActiveMQ/RabbitMQ  不支持消息堆积</p><p>2、Kafka/RocketMQ 基于磁盘，可以消息堆积，使用WAL技术</p><p>3、Apache Pulsar 加了计算和存储分离，计算复杂的话增加计算节点，底层的数据节点不动，计算和存储节点独立拓展</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210305.png" alt="image-20210411210305509"></p><p>第 24 课</p><h2 id="4-ActiveMQ消息中间件"><a href="#4-ActiveMQ消息中间件" class="headerlink" title="4. ActiveMQ消息中间件"></a>4. ActiveMQ消息中间件</h2><p><strong>ActiveMQ介绍</strong></p><p> 高可靠的、事务性的消息队列</p><p> 当前应用最广泛的开源消息中间件</p><p> 项目开始与2005年CodeHaus、2006年成为Apache项目</p><p>后来与HornetQ合并，新的消息队列叫：Artemis，目前是ActiveMQ的子项目</p><p>功能最全的开源消息队列</p><p><a href="https://activemq.apache.org/">https://activemq.apache.org/</a></p><p><strong>主要功能</strong></p><ol><li>多种语言和协议编写客户端。</li></ol><p>语言: Java, C, C++, C#, Ruby, Perl, Python, PHP等</p><p>应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP</p><ol><li>完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)</li><li>与Spring很好地集成，也支持常见J2EE服务器</li><li>支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>实现了高性能的集群模式</li></ol><p>第 24 课</p><h2 id="5-ActiveMQ使用示例"><a href="#5-ActiveMQ使用示例" class="headerlink" title="5. ActiveMQ使用示例*"></a>5. ActiveMQ使用示例*</h2><p><strong>使用场景</strong></p><p>ActiveMQ的使用场景：</p><p>1、所有需要使用消息队列的地方；</p><p>2、订单处理、消息通知、服务降级等等；</p><p>3、特别地，纯java实现，支持嵌入到应用系统。</p><p><strong>使用演示</strong></p><p>演示一些功能</p><p>第 24 课</p><h2 id="6-总结回顾与作业实践"><a href="#6-总结回顾与作业实践" class="headerlink" title="6. 总结回顾与作业实践"></a>6. 总结回顾与作业实践</h2><p><strong>第 24 课总结回顾</strong></p><p><strong>系统间通信方式</strong></p><p><strong>从队列到消息服务</strong></p><p><strong>消息模式与消息协议</strong></p><p><strong>ActiveMQ消息中间件</strong></p><p><strong>第 24 课作业实践</strong></p><p>1、（必做）搭建ActiveMQ服务，基于JMS，写代码分别实现对于queue和topic的消息</p><p>生产和消费，代码提交到github。</p><p>2、（选做）基于数据库的订单表，模拟消息队列处理订单：</p><p>1）一个程序往表里写新订单，标记状态为未处理(status=0);</p><p>2）另一个程序每隔100ms定时从表里读取所有status=0的订单，打印一下订单数据，</p><p>然后改成完成status=1；</p><p>3）（挑战☆）考虑失败重试策略，考虑多个消费程序如何协作。</p><p>3、（选做）将上述订单处理场景，改成使用ActiveMQ发送消息处理模式。<strong>第 24 课作业实践</strong></p><p>4、（挑战☆☆）搭建ActiveMQ的network集群和master-slave主从结构。</p><p>5、（挑战☆☆☆）基于ActiveMQ的MQTT实现简单的聊天功能或者Android消息推送。</p><p>6、（挑战☆）创建一个RabbitMQ，用Java代码实现简单的AMQP协议操作。</p><p>7、（挑战☆☆）搭建RabbitMQ集群，重新实现前面的订单处理。</p><p>8、（挑战☆☆☆）使用Apache Camel打通上述ActiveMQ集群和RabbitMQ集群，实</p><p>现所有写入到ActiveMQ上的一个队列q24的消息，自动转发到RabbitMQ。</p><p>9、（挑战☆☆☆）压测ActiveMQ和RabbitMQ的性能。</p><p>其他问题记录：</p><p>Q：消费端，有推拉两种，一般监听用的是哪种</p><p>RE：mq服务器端推来的</p><p>Q：mq如何保障措施里消费唯一的原理</p><p>RE：一会讲消息模式就明白了</p><p>Q：消息队列满了怎么优化？</p><p>RE：一会儿讲三代MQ会讲这个问题</p><p>Q：死信不属于消息丢失</p><p>RE：DLQ == Dead Letter Queue，没有丢</p><p>消息处理不了了，丢到死信队列里面；消息一个小时超时， 会丢到死信队列。消息还在，需要人工处理</p><p>我的 Q：消息持久化是如何处理的</p><p>RE：</p><p>Q：重复消息要怎么处理</p><p>RE：消息的QMMS？</p><p>Q：RabbitMQ为什么要做exchange？</p><p>RE：kafka和RocketMq没有，其他mq都有。exchange相当于springmvc，gateway里面的route</p><p>Q：线上MQ版本升级，未消费完的消息如何迁移到新的MQ？</p><p>RE：读出来消息消息写进去，可以使用camel</p><p>Q：MQ选型</p><p>RE：</p><p>Q：死信对垒，是业务语义上自带的还是中间件本身就自带的</p><p>RE：EIP，第一代MQ一般都有DLQ</p><p>Q：topic存在QOS吗</p><p>RE：队列有两种，queue和topic，两者都有</p><p>Q：spring-amqp是用rabbitmq吗</p><p>RE：amqp协议是可移植的通用协议，服务端是RabbitMQ或者ActiveMQ，Qpid都成</p><p>Q：zmq是什么</p><p>RE：zmq人为是一个通信库，不是mq</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p>Q：</p><p>RE：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210405.png" alt="image-20210411210405796"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210427.png" alt="image-20210411210427652"></p><p>性能快，rabbitmq</p><p>大数据场景，收单收集数据，kafka或者rocketmq，</p><p>强事务</p><p>根据业务，简化，代码验证，选型</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210459.png" alt="image-20210411210459201"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411210514.png" alt="image-20210411210514721"></p><p>参考文档：</p><p>JMS介绍：我对JMS的理解和认识: <a href="https://kimmking.blog.csdn.net/article/details/6577021">https://kimmking.blog.csdn.net/article/details/6577021</a> ActiveMQ官网： <a href="https://activemq.apache.org/">https://activemq.apache.org</a> ActiveMQ集群-网络连接模式(network connector)详解: <a href="https://kimmking.blog.csdn.net/article/details/8440150">https://kimmking.blog.csdn.net/article/details/8440150</a> ActiveMQ的集群与高可用: <a href="https://kimmking.blog.csdn.net/article/details/13768367">https://kimmking.blog.csdn.net/article/details/13768367</a></p><p>JMS介绍：我对JMS的理解和认识 <a href="https://kimmking.blog.csdn.net/article/details/6577021">https://kimmking.blog.csdn.net/article/details/6577021</a></p><p>分布式调用如何保证幂等</p><p><a href="https://www.zhihu.com/question/27744795/answer/905254616?utm_source=wechat_session&amp;utm_medium=social&amp;s_r=0">https://www.zhihu.com/question/27744795/answer/905254616?utm_source=wechat_session&amp;utm_medium=social&amp;s_r=0</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week11-02 第二十二课 分布式缓存-redis详解</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week11-02%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-redis%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week11-02%20%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%AF%BE%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-redis%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>其他</p><p>可以测试redis的网站 <a href="http://try.redis.io/">try.redis.io</a></p><p><a href="https://github.com/JavaCourse00/JavaCourseCodes08cache">https://github.com/JavaCourse00/JavaCourseCodes08cache</a></p><p><a href="https://github.com/JavaCourse00/JavaCourseCodes/08cache/cache">https://github.com/JavaCourse00/JavaCourseCodes/08cache/cache</a> 有空可以看看这个demo： 1、先做一个springboot+mybatis的简单demo 2、加上mybatis的二级缓存，用的ehcache 3、加上spring cache，用的ehcache 4、spring cache改成redis 5、redis的默认对象序列化改成jackson</p><p>这么一点点改的,跟我平时布置的作业一个思路。并且我边做作业，边wrk压测，今天详细讲讲这个思路</p><p>Redis 基础手册：<a href="https://www.runoob.com/redis/redis-tutorial.html">https://www.runoob.com/redis/redis-tutorial.html</a> Redis 基础系列（推荐）：<a href="https://www.cnblogs.com/itzhouq/p/redis1.html">https://www.cnblogs.com/itzhouq/p/redis1.html</a> Redis常用参数：<a href="https://www.cnblogs.com/liufukui/p/10448827.html">https://www.cnblogs.com/liufukui/p/10448827.html</a> Spring Cache整合ehcache和Redis：<a href="https://www.cnblogs.com/xiang--liu/p/9720344.html">https://www.cnblogs.com/xiang--liu/p/9720344.html</a> Spring Data Redis：<a href="https://blog.csdn.net/lydms/article/details/105224210">https://blog.csdn.net/lydms/article/details/105224210</a> Redis命中率：<a href="https://www.cnblogs.com/junlinqunxia/p/11244230.html">https://www.cnblogs.com/junlinqunxia/p/11244230.html</a> Redis知识与场景集合（推荐）：<a href="http://c.biancheng.net/view/4560.html">http://c.biancheng.net/view/4560.html</a> Redis内存优化：<a href="https://redis.io/topics/memory-optimization">https://redis.io/topics/memory-optimization</a> Redis数据类型原理与优化（推荐）：<a href="https://www.cnblogs.com/williamjie/p/11288062.html">https://www.cnblogs.com/williamjie/p/11288062.html</a> Redis优化的几个tips：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/55068567">https://zhuanlan.zhihu.com/p/55068567</a></li><li><a href="http://www.jwsblog.com/archives/50.html">http://www.jwsblog.com/archives/50.html</a></li></ul><p>Lettuce详解：</p><ul><li><a href="https://www.cnblogs.com/throwable/p/11601538.html">https://www.cnblogs.com/throwable/p/11601538.html</a></li><li><a href="https://blog.csdn.net/moonpure/article/details/82658788">https://blog.csdn.net/moonpure/article/details/82658788</a></li></ul><p>Redis设计与实现：<a href="http://redisbook.com/">http://redisbook.com/</a></p><p><a href="https://redis.io/">https://redis.io/</a> 英文官网 <a href="http://www.redis.cn/">http://www.redis.cn/</a> 中文官网（大概是官网？）</p><p>位大神请教个问题，如何清除多台服务器上的本地缓存？</p><p>方法1： 1、提供一个rest接口或rpc，curl/call一下， 2、多台机器，轮询curl/call一遍 方法2： 1、基于mq，订阅一个topic， 2、收到消息就清除 方法3： 1、使用集中式缓存，比如redis</p><p>还可以用redis。订阅</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181227.png" alt="image-20210411181227386"></p><h1 id="第-22-课分布式服务-Redis详解"><a href="#第-22-课分布式服务-Redis详解" class="headerlink" title="第 22 课分布式服务-Redis详解"></a>第 22 课分布式服务-Redis详解</h1><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><ol><li>Redis基本功能</li></ol><p>2.Redis六大使用场景</p><p>3.Redis的Java客户端</p><p>4.Redis与Spring整合</p><p>5.Redis高级功能</p><p>6.Redis集群与高可用</p><ol><li>总结回顾与作业实践</li></ol><h2 id="第-22-课-1-Redis基本功能"><a href="#第-22-课-1-Redis基本功能" class="headerlink" title="第 22 课 1. Redis基本功能"></a>第 22 课 1. Redis基本功能</h2><p><strong>Redis安装</strong></p><p>三种方式：</p><ul><li>下载安装、编译源码安装（Windows: 微软提供3.x/Memurai提供5.x）</li><li>brew、apt、yum安装</li><li>docker方式启动</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull redisdocker run -itd --name redis-test -p <span class="token number">6379</span>:6379 redisdocker image inspect redis:latest<span class="token operator">|</span><span class="token function">grep</span> -i versiondocker <span class="token builtin class-name">exec</span> -it redis-test /bin/bash$ redis-cli<span class="token operator">&gt;</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Redis安装-Docker</strong></p><p>Docker 安装与使用演示</p><p>新入门注意的坑：没有redis.conf文件</p><p>如何处理？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -p <span class="token number">6379</span>:6379 --name redis01 -v/etc/redis/redis.conf:/etc/redis/redis.conf -v /etc/redis/data:/data -d redisredis-server /etc/redis/redis.conf --appendonly <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>redis默认有16个库，select 0进行切换，默认是0</p><p>推荐使用docker方式</p><h3 id="Redis性能测试"><a href="#Redis性能测试" class="headerlink" title="Redis性能测试"></a><strong>Redis性能测试</strong></h3><p>可以使用自带的命令 redis-benchmark</p><p>在我启动的docker里（4Core, 2G）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># redis-benchmark -n 100000 -c 32 -t SET,GET,INCR,HSET,LPUSH,MSET -q</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><p>SET: 39463.30 requests per second</p><p>GET: 39872.41 requests per second</p><p>INCR: 39603.96 requests per second</p><p>LPUSH: 38819.88 requests per second</p><p>HSET: 39323.63 requests per second</p><p>MSET (10 keys): 37202.38 requests per second</p><p>更详细的可以参考：redis-benchmark -n 100000 -c 32</p><p><strong>Redis的5种基本数据结构</strong></p><p>1.字符串（string）存储int，String，byte[]</p><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便</p><p>意味着该类型可以接受任何格式的数据，如JPEG图像数据或json对象描述信息等。在</p><p>Redis中字符串类型的value最多可以容纳的数据长度是512M。</p><p>set/get/getset/del/exists/append</p><p>incr/decr/incrby/decrby</p><p>注意：</p><ol><li>字符串append与整数共享</li><li>证书共享：如果能使用整数，就尽量使用整数，限制了redis内存+LRU</li><li>整数经度问题：redis大概能保证16位，17-18位的大整数会丢失精度</li></ol><p>2.散列（hash）存储Map， Pojo Class，</p><p>Redis中的Hash类型可以看成具有String key 和String value的map容器。所以该类型</p><p>非常适合于存储对象的信息。如Username、password和age。如果Hash中包含少量</p><p>的字段，那么该类型的数据也将仅占用很少的磁盘空间。</p><p>hset/hget/hmset/hmget/hgetall/hdel/hincrby</p><p>hexists/hlen/hkeys/hvals</p><p>对应java里面HashMap的方法</p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181417.png" alt="image-20210411181416973" style="zoom: 50%;"><p>3.列表（list）类似java的linkedList</p><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表 一</p><p>样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，</p><p>Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么</p><p>该键也将会被从数据库中删除。</p><p>lpush/rpush/lrange/lpop/rpop</p><p>注意：</p><p>列表是反的，顺序是21abc，下面的最先插入的，弹出</p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181443.png" alt="image-20210411181443218" style="zoom:33%;"><p>4.集合（set）类似java里面的set，set是不重复的list</p><p>在redis中，可以将Set类型看作是没有排序的字符集合，和List类型一样，我们也可以</p><p>在该类型的数值上执行添加、删除和判断某一元素是否存在等操作。这些操作的时间复</p><p>杂度为O(1),即常量时间内完成依次操作。</p><p>和List类型不同的是，Set集合中不允许出现重复的元素。</p><p>sadd/srem/smembers/sismember</p><p>sdiff/sinter/sunion ~集合求差集，求交集，求并集</p><p>5.有序集合（sorted set）</p><p>sortedset和set极为相似，他们都是字符串的集合，都不允许重复的成员出现在一个</p><p>set中。他们之间的主要差别是sortedset中每一个成员都会有一个分数与之关联。redis</p><p>正是通过分数来为集合的成员进行从小到大的排序。sortedset中分数是可以重复的。</p><p>zadd key score member score2 member2… : 将成员以及该成员的分数存放到sortedset中</p><p>zscore key member : 返回指定成员的分数</p><p>zcard key : 获取集合中成员数量</p><p>zrem key member [member…] : 移除集合中指定的成员，可以指定多个成员</p><p>zrange key start end [withscores] : 获取集合中脚注为start-end的成员，[withscores]参数表明返回的成员</p><p>包含其分数</p><p>zrevrange key start stop [withscores] : 按照分数从大到小的顺序返回索引从start到stop之间的所有元素</p><p>（包含两端的元素）</p><p>zremrangebyrank key start stop : 按照排名范围删除元素</p><p><strong>Redis的3种高级数据结构</strong></p><ul><li><p>Bitmaps：setbit/getbit/bitop/bitcount/bitpos</p><p>bitmaps不是一个真实的数据结构。而是String类型上的一组面向bit操作的集合。由于</p><p>strings是二进制安全的blob，并且它们的最大长度是512m，所以bitmaps能最大设置</p><p>2^32个不同的bit。</p></li><li><p>Hyperloglogs：pfadd/pfcount/pfmerge</p><p>在redis的实现中，您使用标准错误小于1％的估计度量结束。这个算法的神奇在于不再</p><p>需要与需要统计的项相对应的内存，取而代之，使用的内存一直恒定不变。最坏的情况</p><p>下只需要12k，就可以计算接近2^64个不同元素的基数。</p></li><li><p>GEO：geoadd/geohash/geopos/geodist/georadius/georadiusbymember</p><p>Redis的GEO特性在 Redis3.2版本中推出，这个功能可以将用户给定的地理位置（经</p><p>度和纬度）信息储存起来，并对这些信息进行操作。这个问题本身就是个坑</p></li></ul><p>![image-20210411181803911](/Users/cutie/Library/Application Support/typora-user-images/image-20210411181803911.png)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181828.png" alt="image-20210411181828061"></p><p>其他：布隆过滤和位图</p><p>bitmap 基数排序</p><p>布隆过滤 bloofilter相当于位和位的组合，有一定的错误，0001001000 ，判断另一个id是否是重复的，0000001000</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181847.png" alt="image-20210411181847478"></p><p>上图第一个和第二个过滤了之后，会误判断第三个已经存在了</p><p>80个数，都在0-99的范围，O(n)；int[100] ~ -1</p><p>for 80,int 5,int[5]=1，没有用任何比较</p><p>计数排序，不用比较，所以O(n)，基于比较的排序，O(n*logN)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181901.png" alt="image-20210411181901082"></p><p>可以对订单数据进行压缩</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181915.png" alt="image-20210411181914983"></p><p><strong>Redis到底 是单线程，还是多线程？</strong></p><p>IO线程：</p><p>redis 6之前（2020年5月前），单线程</p><p>redis 6之后，多线程，NIO模型 —》主要的性能提升点</p><p>内存处理线程：</p><p>单线程 —》高性能的核心</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411181933.png" alt="image-20210411181933256"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182000.png" alt="image-20210411182000581"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182018.png" alt="image-20210411182018751"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182032.png" alt="image-20210411182032737"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182046.png" alt="image-20210411182046337"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182057.png" alt="image-20210411182057365"></p><h2 id="第-22-课-2-Redis六大使用场景"><a href="#第-22-课-2-Redis六大使用场景" class="headerlink" title="第 22 课 2. Redis六大使用场景"></a>第 22 课 2. Redis六大使用场景</h2><p>其他：redis有jdbc驱动插件</p><p>*<em>Redis使用场景-1.业务数据缓存**</em></p><p>经典用法。</p><p>1、通用数据缓存，string，int，list，map等。</p><p>2、实时热数据，最新500条数据。</p><p>3、会话缓存，token缓存等。</p><p><strong>Redis使用场景-2.业务数据处理</strong></p><p>1、非严格一致性要求的数据：评论，点击等。</p><p>2、业务数据去重：订单处理的幂等校验等。【多台机器场景】</p><p>3、业务数据排序：排名，排行榜等。</p><p>*<em>Redis使用场景-3.全局一致计数**</em></p><p>1、全局流控计数</p><p>2、秒杀的库存计算</p><p>3、抢红包</p><p>4、全局ID生成</p><p><strong>Redis使用场景-4.高效统计计数</strong></p><p>1、id去重，记录访问ip等全局bitmap操作</p><p>2、UV、PV等访问量==&gt;非严格一致性要求</p><p><strong>Redis使用场景-5.发布订阅与Stream</strong></p><p>1、Pub-Sub 模拟队列</p><p>subscribe comments</p><p>publish comments java</p><p>2、Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列（MQ，Message Queue）。</p><p>具体可以参考 <a href="https://www.runoob.com/redis/redis-stream.html">https://www.runoob.com/redis/redis-stream.html</a></p><p>*<em>Redis使用场景-6.分布式锁**</em></p><p>1、获取锁 — 原子性操作</p><p>非原子性操作： set lock1 1    expire lock1 30 （秒）</p><p>原子性操作：SET dlock my_random_value NX PX 30000  —&gt;  setnx lock1 1 nx px 30000（毫秒）</p><p>2、释放锁 - 需要使用lua脚本，lua脚本是一个原子性操作，保证事务性【下面代码是lua代码】类似数据库的存储过程</p><p>if redis.call(“get”,KEYS[1]) == ARGV[1] then</p><p>return redis.call(“del”,KEYS[1])</p><p>else</p><p>return 0</p><p>end</p><p>关键点：原子性、互斥、超时</p><h2 id="第-22-课-3-Redis的Java客户端"><a href="#第-22-课-3-Redis的Java客户端" class="headerlink" title="第 22 课 3. Redis的Java客户端"></a>第 22 课 3. Redis的Java客户端</h2><p><strong>Redis 的Java客户端-Jedis</strong></p><p>官方客户端，类似于JDBC，可以看做是对redis命令的包装。</p><p>基于BIO，线程不安全，需要配置连接池管理连接。</p><p><strong>Redis 的Java客户端-Lettuce</strong></p><p>目前主流推荐的驱动，基于Netty NIO，API线程安全。</p><p><strong>Redis 的Java客户端-Redission</strong></p><p>基于Netty NIO，API线程安全。</p><p>亮点：大量丰富的分布式功能特性，比如JUC的线程安全集合和工具的分布式版本，分</p><p>布式的基本数据类型和锁等。</p><p>第 22 课 4. Redis与Spring整合</p><p><strong>Spring Data Redis</strong></p><p>核心是 RedisTemplate(可以配置基于Jedis，Lettuce，Redisson)</p><p>使用方式类似于MongoDBTemplate，JDBCTemplate或JPA</p><p>封装了基本redis命令操作：</p><p><strong>Spring Boot与Redis集成</strong></p><p>引入 spring-boot-starter-data-redis</p><p>配置 spring redis</p><p><strong>Spring Cache与Redis集成</strong></p><p>默认使用全局的CacheManager自动集成</p><p>使用ConcurrentHashMap或ehcache时，不需要考虑序列化问题。</p><p>redis的话，需要：</p><p>1、默认使用java的对象序列化，对象需要实现Serializable</p><p>2、自定义配置，可以修改为其他序列化方式</p><p><strong>MyBatis项目集成cache示例</strong></p><p>1、集成spring boot与mybatis，实现简单单表操作，配置成rest接口</p><p>2、配置ehcache+mybatis集成，实现mybatis二级缓存</p><p>3、配置spring cache+ehcache缓存，实现方法级别缓存</p><p>4、修改spring cache使用redis远程缓存代替ehcache本地缓存</p><p>5、修改spring cache使用jackson json序列化代替java序列化</p><p>6、整个过程中，使用wrk压测rest接口性能，并分析为什么?</p><p>7、尝试调整各种不同的配置和参数，理解cache原理和用法。</p><p>其他留给作为作业</p><p>mybatis一级缓存当前会话有效，mybatis二级缓存全局有效</p><p>网络io，序列换反序列化影响时间</p><p>mysql的buffer，调用mysql，都相当于直接访问内存</p><p>什么时候把业务返回的数据放在缓存里面？</p><p>re：业务很复杂或者这块的数据库操作很复杂，很慢，对系统资源消耗很大</p><p>业务系统复杂的时候，采用微服务是有价值的，系统非常简单的时候，单体才是好办法</p><p>序列化方式修改演示：2：42</p><h2 id="第-22-课-5-Redis高级功能"><a href="#第-22-课-5-Redis高级功能" class="headerlink" title="第 22 课 5. Redis高级功能"></a>第 22 课 5. Redis高级功能</h2><p><strong>Redis 事务</strong></p><p>Redis 事务命令：</p><p>开启事务：multi</p><p>命令入队</p><p>执行事务：exec</p><p>撤销事务：discard</p><p>Watch 实现乐观锁</p><p>watch 一个key，发生变化则事务失败</p><p><strong>Redis Lua ~ open resty = nginx + lua jit</strong></p><p>类似于数据库的存储过程，mongodb的js脚本</p><blockquote><p>直接执行</p></blockquote><p>eval “return’hello java’” 0</p><p>eval “redis.call(‘set’,KEYS[1],ARGV[1])” 1 lua-key lua-value</p><blockquote><p>预编译</p></blockquote><p>script load script脚本片段</p><p>返回一个SHA-1签名 shastring</p><p>evalsha shastring keynum [key1 key2 key3 …] [param1 param2 param3 …]</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182124.png" alt="image-20210411182123929"></p><p><strong>Redis 管道技术</strong></p><p>合并操作批量处理，且不阻塞前序命令：</p><p>% (echo -en “PING\r\n SET pkey redis\r\nGET pkey\r\nINCR visitor\r\nINCR</p><p>visitor\r\nINCR visitor\r\n”; sleep 1) | nc localhost 6379</p><p>输出：</p><p>+PONG</p><p>+OK</p><p>$5</p><p>redis</p><p>:1</p><p>:2</p><p>:3</p><p>对比redis的批量操作命令，这里的命令之间没有任何关系</p><p><strong>Redis 数据备份与恢复–RDB  ~  mysql每个表的文件</strong></p><p>备份</p><p>执行 save 即可在redis数据目录生成数据文件 dump.rdb</p><p>也可以异步执行 bgsave</p><p>恢复</p><p>将备份文件 (dump.rdb) 移动到 redis 数据目录并启动服务即可</p><p>查看文件夹 CONFIG GET dir</p><p>127.0.0.1:6379&gt; CONFIG GET dir</p><ol><li>“dir”</li><li>“/data”</li></ol><p><strong>Redis 数据备份与恢复–AOF  ~ binlog</strong></p><p>备份</p><p>如果 appendonly 配置为 yes，则以 AOF 方式备份 Redis 数据，那么此时 Redis 会按</p><p>照配置，在特定的时候执行追加命令，用以备份数据。</p><p>appendfilename “appendonly.aof”</p><h1 id="appendfsync-always-每个数据都写入磁盘再返回-【保证appendonly-和内存的数据一致，性能影响比较大】"><a href="#appendfsync-always-每个数据都写入磁盘再返回-【保证appendonly-和内存的数据一致，性能影响比较大】" class="headerlink" title="appendfsync always  = 每个数据都写入磁盘再返回 【保证appendonly 和内存的数据一致，性能影响比较大】"></a>appendfsync always  = 每个数据都写入磁盘再返回 【保证appendonly 和内存的数据一致，性能影响比较大】</h1><h1 id="appendfsync-everysec-每秒同步一次到磁盘"><a href="#appendfsync-everysec-每秒同步一次到磁盘" class="headerlink" title="appendfsync everysec  = 每秒同步一次到磁盘"></a>appendfsync everysec  = 每秒同步一次到磁盘</h1><h1 id="appendfsync-no……"><a href="#appendfsync-no……" class="headerlink" title="appendfsync no……"></a>appendfsync no……</h1><p>AOF 文件和 Redis 命令是同步频率的，假设配置为 always，其含义为当 Redis 执行</p><p>命令的时候，则同时同步到 AOF 文件，这样会使得 Redis 同步刷新 AOF 文件，造成</p><p>缓慢。而采用 evarysec 则代表每秒同步一次命令到 AOF 文件。</p><p>恢复</p><p>自动加载</p><p><strong>Redis 性能优化</strong></p><p>核心优化点：</p><p>1、内存优化 ~ 10G-20G</p><p><a href="https://redis.io/topics/memory-optimization">https://redis.io/topics/memory-optimization</a></p><p>hash-max-ziplist-value 64</p><p>zset-max-ziplist-value 64</p><p>2、CPU优化 ~ 注意单线程</p><p>不要阻塞 特别是lua脚本</p><p>谨慎使用范围操作</p><p>SLOWLOG get 10 默认10毫秒，默认只保留最后的128条</p><p><strong>Redis 分区 ~  数据库垂直拆分</strong></p><p>设计规划问题：</p><p>1、容量 ~ 多个业务系统，公用一个redis还是应该分开？</p><p>规划好key，特别是前缀</p><p>2、分区</p><p>如果缓存数据变大了，就可以分区，order ~ 垂直拆分</p><p>业务研发团队，一般看不到redis/tair实际配置的，怎么用？</p><p>1、申请缓存资源，key/token，mall.gouwuche.detail</p><p>2、cache，key=mall.gouwuche.detail</p><p><strong>Redis 使用的一些经验</strong></p><p>1、性能：</p><ol><li>client ~ 线程数（4-8）与连接数（redis ~ 10000）；</li><li>监控系统读写比和缓存命中率（N:1,90%+）；</li></ol><p>2、容量：</p><ol><li>做好容量评估，合理使用缓存资源；监控要注重增量变化</li></ol><p>3、资源管理和分配：</p><ol><li>尽量每个业务集群单独使用自己的Redis，不混用；</li><li>控制Redis资源的申请与使用，规范环境和Key的管理（以一线互联网为例）；</li><li>监控CPU 100%，优化高延迟的操作。</li></ol><p>第 22 课 6. Redis的集群与高可用</p><p><strong>Redis 复制</strong></p><p>TODO <strong>Redis 主从切换：redis-sentinel</strong></p><p>TODO <strong>Java中配置Redis的高可用</strong></p><p>TODO</p><p>第 22 课 7.总结回顾与作业实践</p><p><strong>第 22 课总结回顾</strong></p><p><strong>Redis基本功能</strong></p><p><strong>Redis六大场景</strong></p><p><strong>Java、Spring整合</strong></p><p><strong>Redis高级功能第 22 课作业实践</strong></p><p>1、（选做）练习操作Redis的各种基本数据结构。</p><p>2、（必做）基于Redis封装分布式数据操作：</p><p>1）在Java中实现一个简单的分布式锁；</p><p>2）在Java中实现一个分布式计数器，模拟减库存。</p><p>3、（选做）基于其他各类场景，设计并在示例代码中实现简单demo。</p><p>4、（选做）以redis作为数据库，模拟使用lua脚本实现前面课程的外汇交易事务。</p><p>是否redis分片分区</p><p>数据是分开还是和在一起用？</p><p>redis的key的大小</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182144.png" alt="image-20210411182144266"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182300.png" alt="image-20210411182259941"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182316.png" alt="image-20210411182316038"></p><p>redis的淘汰策略</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182333.png" alt="image-20210411182333705"></p><p>rdb或者aof选择</p><p>大厂比较少使用redis，可能都没有用到持久化，redis的持久化怎么都不靠谱</p><p>淘宝用tair</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182350.png" alt="image-20210411182350431"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411182403.png" alt="image-20210411182403128"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week11-01 分布式缓存-缓存技术</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week11-01%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week11-01%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 21 课</p><p>分布式缓存-缓存技术</p><p>KimmKing</p><p>Apache Dubbo/ShardingSphere PMC<strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.从数据的使用说起</p><p>2.本地缓存</p><p>3.远程缓存</p><p>4.缓存策略</p><p>5.缓存常见问题</p><p>6.总结回顾与作业实践</p><h2 id="第-21-课-1-从数据的使用说起"><a href="#第-21-课-1-从数据的使用说起" class="headerlink" title="第 21 课 1. 从数据的使用说起"></a><strong>第 21 课 1. 从数据的使用说起</strong></h2><p><strong>我们把数据的使用频率和方式分个类</strong></p><ul><li>静态数据：一般不变，类似于字典表</li><li>准静态数据：变化频率很低，部门结构设置，全国行政区划数据等</li><li>中间状态数据：一些计算的可复用中间数据，变量副本，配置中心的本地副本</li><li>热数据：使用频率高</li><li>读写比较大：读的频率 &gt;&gt; 写的频率</li></ul><p>这些数据适合于使用缓存的方式访问</p><p>广义上来说，为了加速数据处理，让业务更快访问的临时存放冗余数据，都是缓存</p><p>狭义上，现在我们一般在分布式系统里把缓存到内存的数据叫做内存缓存</p><p>还有没有其他数据？</p><p><strong>缓存无处不在</strong></p><p>内存 ~ 可以看做是 CPU 和 磁盘之间的缓存</p><p>CPU与内存的处理速度也不一致，出现 L1&amp;L2 Cache</p><p>网络处理，数据库引擎的各种Buffer，都可以看做是缓存</p><p>GUI的Double Buffer（双缓冲），是一个经典的性能优化方法</p><p>缓存的本质：</p><p>系统各级处理速度不匹配，导致利用空间换时间</p><p>缓存是提升系统性能的一个简单有效的办法</p><p><strong>缓存加载时机</strong></p><p>1、启动全量加载 ==&gt; 全局有效，使用简单</p><p>2、懒加载</p><p>同步使用加载 ==&gt;</p><ul><li>先看缓存是否有数据，没有的话从数据库读取</li><li>读取的数据，先放到内存，然后返回给调用方</li></ul><p>延迟异步加载 ==&gt;</p><ul><li>从缓存获取数据，不管是否为空直接返回 ==&gt;</li><li>策略1异步）如果为空，则发起一个异步加载的线程，负责加载数据</li><li>策略2解耦）异步线程负责维护缓存的数据，定期或根据条件触发更新</li></ul><p><strong>缓存的有效性与数据同步</strong></p><p><strong>缓存使用不当导致的问题</strong></p><p>1、系统预热导致启动慢</p><p>试想一下，一个系统启动需要预热半个小时。</p><p>导致系统不能做到快速应对故障宕机等问题。</p><p>2、系统内存资源耗尽</p><p>只加入数据，不能清理旧数据。</p><p>旧数据处理不及时，或者不能有效识别无用数据。</p><h2 id="第-21-课-2-本地缓存"><a href="#第-21-课-2-本地缓存" class="headerlink" title="第 21 课 2. 本地缓存"></a><strong>第 21 课 2. 本地缓存</strong></h2><p><strong>最简单的本地缓存</strong></p><p>private static final Map&lt;String, Object&gt; CACHE = new HashMap();</p><p>CACHE.put(“beijing”, “100001”);</p><p>String cityCode = (String) CACHE.get(“beijing”);</p><p>思考：还缺少什么？如何改进 ？</p><p><strong>Hibernate/MyBatis都有Cache</strong></p><p>一级缓存，session级别。</p><p>二级缓存，sessionFactory级别。</p><p>MyBatis:</p><cache type="org.mybatis.caches.ehcache.LoggingEhcache"><p><property name="memoryStoreEvictionPolicy" value="LRU"></property></p><select id="selectArticleListPage" resultmap="resultUserArticleList" usecache="false">Hibernate: org.hibernate.cache.EhCacheProvider Guava CacheCache&lt;String,String&gt; cache = CacheBuilder.newBuilder().maximumSize(1024).expireAfterWrite(60,TimeUnit.SECONDS).weakValues().build();cache.put(“word”,”Hello Guava Cache”);System.out.println(cache.getIfPresent(“word”));此外，还可以显示清除、统计信息、移除监听器、自动加载等功能。Spring Cache1、基于注解和AOP，使用非常方便2、可以配置Condition和SPEL，非常灵活3、需要注意：绕过Spring的话，注解无效核心功能：@Cacheable、@CachePut、@CacheEvict参考：https://developer.ibm.com/zh/articles/os-cn-spring-cache/第 21 课 3. 远程缓存考虑一下本地缓存有什么缺点?1、在多个集群环境同步？当集群规模增大，缓存的读写放大。2、在JVM中长期占用内存？如果是堆内存，总是会影响GC。3、缓存数据的调度处理，影响执行业务的线程，抢资源。== &gt; 集中处理缓存聪明的你，思考一下：有什么缺点呢?Redis/Memcached 缓存中间件REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。Memcached是以LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的一款开源高性能，分布式内存对象缓存系统。Redis 官网：https://redis.io/Redis 在线测试：http://try.redis.io/Redis 命令参考：http://doc.redisfans.com/《Redis 设计与实现》：http://redisbook.com/Memcached 官网：https://memcached.org/Hazelcast/Ignite 内存网格第 21 课 4. 缓存策略容量资源有限缓存数据容量是必须要考虑的问题思考系统的设计容量、使用容量、峰值，应该是我们做架构设计的一个常识过期策略按FIFO或LRU按固定时间过期按业务时间加权：例如3+5x第 21 课 5. 缓存常见问题缓存穿透问题：大量并发查询不存在的KEY，导致都直接将压力透传到数据库。分析：为什么会多次透传呢？不存在一直为空。需要注意让缓存能够区分KEY不存在和查询到一个空值。解决办法：1、缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY。2、完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。3、Bloom过滤或RoaringBitmap 判断KEY是否存在。缓存击穿问题：某个KEY失效的时候，正好有大量并发请求访问这个KEY。分析：解决办法：1、KEY的更新操作添加全局互斥锁。2、完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。3、缓存雪崩问题：当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数据库压力过大升值宕机。分析：一般来说，由于更新策略、或者数据热点、缓存服务宕机等原因，可能会导致缓存数据同一个时间点大规模不可用，或者都更新。所以，需要我们的更新策略要在时间上合适，数据要均匀分散，缓存服务器要多台高可用。解决办法：1、更新策略在时间上做到比较均匀。2、使用的热数据尽量分散到不同的机器上。3、多台机器做主从复制或者多副本，实现高可用。4、实现熔断限流机制，对系统进行负载能力控制。第 21 课 6.总结回顾与作业实践第 21 课总结回顾从数据库到缓存本地与远程缓存缓存策略与使用缓存常见的问题第 21 课作业实践1、（选做）平安夜，无作业。2、（必做）记得给你周围的亲朋好友，准备礼物。3、（选做）Merry X’mas &amp; Happy New Year.2021，找到唯一。在这个艰难的世界上，每天进步一点点，坚守头顶的星空和心中的信念，成为更好的自己。</select></cache>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week10-02 分布式服务-Spring Cloud与微服务架构</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week10-02%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-Spring%20Cloud%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week10-02%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-Spring%20Cloud%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 20 课</p><p>分布式服务-Spring Cloud与微服务架构</p><p>KimmKing</p><p>Apache Dubbo/ShardingSphere PMC<strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><ol><li>微服务架构发展历程*</li></ol><p>2.微服务架构应用场景*</p><p>3.微服务架构最佳实践*</p><p>4.Spring Cloud技术体系*</p><p>5.微服务相关框架与工具</p><p>6.总结回顾与作业实践</p><h2 id="第-20-课-1-微服务架构发展历程"><a href="#第-20-课-1-微服务架构发展历程" class="headerlink" title="第 20 课 1. 微服务架构发展历程"></a>第 20 课 1. 微服务架构发展历程</h2><p><strong>微服务发展历程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175818.png" alt="image-20210411175818403"></p><p>1999-2008</p><p>电子化信息化</p><p>2008-2014</p><p>网络化移动化</p><p>2014至今</p><p>数字化智能化</p><p><strong>不管是互联网，还是银行、证券、保险，业务越来越复杂，数据越来越多。</strong></p><p><strong>系统对性能、稳定性，一致性，可用性，扩展性，可维护性，要求越来越高。</strong></p><p><strong>微服务发展历程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175832.png" alt="image-20210411175832522"></p><p><strong>简单单体模式是最简单的架</strong></p><p><strong>构风格，所有的代码全都在</strong></p><p><strong>一个项目中。这样研发团队</strong></p><p><strong>的任何一个人都可以随时修</strong></p><p><strong>改任意的一段代码，或者增</strong></p><p><strong>加一些新的代码。</strong></p><p><strong>面向服务架构（SOA）是</strong></p><p><strong>一种建设企业IT生态系统的</strong></p><p><strong>架构指导思想。SOA的关</strong></p><p><strong>注点是服务。服务最基本</strong></p><p><strong>的业务功能单元，由平台</strong></p><p><strong>中立性的接口契约来定义。</strong></p><p><strong>分层是一个典型的对复杂系</strong></p><p><strong>统（不仅仅是软件）进行结</strong></p><p><strong>构化思考和抽象聚合的通用</strong></p><p><strong>性办法，也符合金字塔原理。</strong></p><p><strong>MVC是一个非常常见的3层</strong></p><p><strong>（3-Tier）结构架构模式。</strong></p><p><strong>微服务架构风格，以实现一</strong></p><p><strong>组微服务的方式来开发一个</strong></p><p><strong>独立的应用系统的方法。其</strong></p><p><strong>中每个小微服务都运行在自</strong></p><p><strong>己的进程中，一般采用</strong></p><p><strong>HTTP资源API这样轻量的机</strong></p><p><strong>制相互通信。</strong></p><p>单体架构 垂直架构 SOA架构 微服务架构</p><p><strong>微服务发展历程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175857.png" alt="image-20210411175857688"></p><p><strong>2011年</strong></p><p><strong>1 2 3 4 5</strong></p><p><strong>2012年3月James Lewis</strong></p><p><strong>关于微服务原则的演讲</strong></p><p><strong>2012年11月Fred George提</strong></p><p><strong>出“微服务架构”概念</strong></p><p><strong>2011年5月威尼斯会</strong></p><p><strong>议提出“微服务”</strong></p><p><strong>2014年3月Martin Flowler全</strong></p><p><strong>面介绍了微服务架构</strong></p><p><strong>2016年4月JonasBonér提</strong></p><p><strong>出“响应式微服务架构”</strong></p><p><strong>现在</strong></p><p>6</p><p><strong>服务网格</strong></p><p><strong>微服务架构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175930.png" alt="image-20210411175930309"></p><p><strong>微服务架构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175947.png" alt="image-20210411175947246"></p><p><strong>微服务架构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180003.png" alt="image-20210411180003045"></p><p><strong>微服务发展历程–1.响应式微服务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180017.png" alt="image-20210411180017651"></p><p><strong>自治性 异步性 伸缩性 弹性</strong></p><p><strong><em>响应式编程是一个专注于数据流和变化传递的异步编程范式。 - 维基百科\</em></strong></p><p><strong>响应式宣言</strong></p><p>即时响应性 可恢复性 弹性 消息驱动</p><p><strong>微服务发展历程–2.服务网格与云原生</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180033.png" alt="image-20210411180033430"></p><p><strong>将服务间的网络通信层及其控制策略下沉到基础设施，就形成了所谓的“服务网格”技术。</strong></p><p><strong>通过微服务、容器化、持续交付、Devops等技术，组成了所谓的“元原生”体系。</strong></p><p><strong>微服务发展历程–3.数据库网格</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180050.png" alt="image-20210411180050007"></p><p><strong>Level 3：Sharding-Proxy中间件（3.x+）</strong></p><p><strong>Level 2：Sharding-JDBC框架（1.x+）</strong></p><p><strong>Level 1：MySQL数据库提供的能力</strong></p><p><strong>Level 4：Sharding-Scaling（4.x+）</strong></p><p><strong>Level 5：Sharding-Sidecar（5.x+）</strong></p><p><strong>Level 6：Sharding-Engine（6.x+）</strong></p><p><strong>We’re</strong></p><p><strong>Here</strong></p><p><strong>Now</strong></p><p><strong>微服务发展历程–4.单元化架构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180107.png" alt="image-20210411180107687"></p><p><strong>以单元为组织架构，以单元化部署为调度单位。</strong></p><p><strong>每个单元，是一个五脏俱全的缩小版整站，它是全能的，因为部署了所有应用；但它不是全量的，因为只能操作</strong></p><p><strong>一部分数据。能够单元化的系统，很容易在多机房中部署，因为可以轻易地把几个单元部署在一个机房，而把另</strong></p><p><strong>外几个部署在其他机房。通过在业务入口处设置一个流量调配器，可以调整业务流量在单元之间的比例。</strong></p><p><strong>微服务发展历程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180124.png" alt="image-20210411180124267"></p><p>微服务</p><p>MicroServices</p><p>服务网格</p><p>ServiceMesh</p><p>数据库网格</p><p>DatabaseMesh</p><p>云原生</p><p>Cloud-Native</p><p><strong>单元化架构</strong></p><p><strong>Cell Architecture</strong></p><h2 id="第-20-课-2-微服务架构应用场景"><a href="#第-20-课-2-微服务架构应用场景" class="headerlink" title="第 20 课 2. 微服务架构应用场景"></a>第 20 课 2. 微服务架构应用场景</h2><p><strong>什么时候用微服务呢？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180140.png" alt="image-20210411180140631"></p><p><strong>微服务应用在复杂度低的情况下，生产力反而比单体架构低</strong></p><p><strong>在复杂度高的地方，情况恰恰相反</strong></p><p><strong>随着复杂度升高，单体架构的生产力快速下降，而微服务相对平稳，</strong></p><p><strong>为什么？什么时候用微服务呢？</strong></p><p>大规模复杂业务系统的架构升级与中台建设</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180159.png" alt="image-20210411180159060"></p><p><strong>怎么应用微服务架构-I6I</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180216.png" alt="image-20210411180216350"></p><p><strong>调研I 分析A 规划P 组织O</strong></p><p><strong>改进I 治理G 部署D 拆分S 实施阶段</strong></p><p><strong>准备阶段</strong></p><h2 id="第-20-课-3-微服务架构最佳实践"><a href="#第-20-课-3-微服务架构最佳实践" class="headerlink" title="第 20 课 3. 微服务架构最佳实践"></a>第 20 课 3. 微服务架构最佳实践</h2><p><strong>六大最佳实践</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180230.png" alt="image-20210411180230404"></p><p><strong>遗留系统改造</strong></p><p><strong>恰当粒度拆分</strong></p><p><strong>扩展立方体</strong></p><p><strong>自动化管理</strong></p><p><strong>分布式事务</strong></p><p><strong>完善监控体系</strong></p><p><strong>最佳实践-01</strong></p><p><strong>改造前 改造后</strong></p><p><strong>①功能剥离、数据解耦</strong></p><p><strong>②自然演进、逐步拆分</strong></p><p><strong>③小步快跑、快速迭代</strong></p><p><strong>④灰度发布、谨慎试错</strong></p><p><strong>⑤提质量线、还技术债</strong></p><p><strong>最佳实践-02</strong></p><p><strong>拆分原则：</strong></p><p><strong>1.高内聚低耦合</strong></p><p><strong>2.不同阶段拆分要点不同</strong></p><p><strong>最佳实践-03</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180354.png" alt="image-20210411180354529"></p><p><strong>扩展立方体：</strong></p><p><strong>1. 水平复制：复制系统</strong></p><p><strong>2.功能解耦：拆分业务</strong></p><p><strong>3.数据分区：切分数据</strong></p><p><strong>单元化架构的基础</strong></p><p><strong>+特性开关 +容错设计</strong></p><p><strong>最佳实践-04</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180411.png" alt="image-20210411180410941"></p><p><strong>自动化测试</strong></p><p><strong>自动化部署</strong></p><p><strong>自动化运维</strong></p><p><strong>降低服务拆分带来的复杂性</strong></p><p><strong>提升测试、部署、运维效率</strong></p><p><strong>最佳实践-05</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180431.png" alt="image-20210411180430970"></p><p><strong>幂等/去重/补偿</strong></p><p><strong>慎用分布式事务！</strong></p><p><strong>最佳实践-06</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180450.png" alt="image-20210411180450386"></p><p><strong>监控与运维：</strong></p><p><strong>1.业务监控</strong></p><p><strong>2.系统监控</strong></p><p><strong>3.容量规划</strong></p><p><strong>4.报警预警</strong></p><p><strong>5.运维流程</strong></p><p><strong>6.故障处理</strong></p><p><strong>稳定性建设</strong></p><p><strong>+Devops +SRE</strong></p><h2 id="第-20-课-4-Spring-Cloud技术体系"><a href="#第-20-课-4-Spring-Cloud技术体系" class="headerlink" title="第 20 课 4. Spring Cloud技术体系"></a>第 20 课 4. Spring Cloud技术体系</h2><p><strong>Spring Cloud</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180508.png" alt="image-20210411180508365"></p><p><strong>Spring Cloud</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180526.png" alt="image-20210411180526660"></p><p>跟并发冲突问题类似的场景很多</p><p><strong>Spring Cloud</strong></p><p>Config/Eureka/Consul</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180550.png" alt="image-20210411180550280"></p><p><strong>Spring Cloud</strong></p><p>Zuul/Zuul2/Spring Cloud Gateway- Feign/Ribbon</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180609.png" alt="image-20210411180609622"></p><p><strong>Spring Cloud</strong></p><p>Feign的核心功能就是，作为HTTP Client访问REST服务接口。</p><p>优势在于：</p><p>1、全都基于注解，简单方便</p><p>2、跟XXTemplate一样，内置了简化操作，OOP</p><p>3、跟其他组件，ribbon，hytrix联合使用</p><p>Ribbon是用于云环境的一个客户端内部通信（IPC）库。</p><p>特性：</p><p>1、负载均衡</p><p>2、容错</p><p>3、多协议支持(HTTP, TCP, UDP)，特别是异步和反应式下</p><p>4、缓存和批处理</p><p><strong>Spring Cloud</strong></p><p>Hytrix/Alibaba Sentinel</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180628.png" alt="image-20210411180628651"></p><h2 id="第-20-课-5-微服务相关框架与工具"><a href="#第-20-课-5-微服务相关框架与工具" class="headerlink" title="第 20 课 5.微服务相关框架与工具"></a>第 20 课 5.微服务相关框架与工具</h2><p><strong>相关工具-APM</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180643.png" alt="image-20210411180643631"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180700.png" alt="image-20210411180700341"></p><p>APM：应用性能监控</p><p>Apache Skywalking</p><p>Pinpoint</p><p>Zipkin</p><p>Jaeger</p><p>监控</p><p>ELK</p><p>promethus+Grafana</p><p>MQ+时序数据库</p><p>(InfluxDB/openTSDB等)</p><p><strong>相关工具-APM：Apache Skywalking</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180718.png" alt="image-20210411180718897"></p><p><strong>相关工具-APM</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180739.png" alt="image-20210411180739594"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180754.png" alt="image-20210411180754031"></p><p><strong>相关工具-权限控制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180809.png" alt="image-20210411180809344"></p><p>最核心的3A（其他：资源管理、安全加密等）：</p><p>Authc: Authentication</p><p>Authz: Authorization</p><p>Audit</p><p>CAS+SSO(TGT、ST)</p><p>JWT/Token, OAuth2.0</p><p>SpringSecurity, Apache Shiro</p><p><strong>相关工具-数据处理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180829.png" alt="image-20210411180829564"></p><p>1、读写分离与高可用HA：</p><p>2、分库分表Sharding：</p><p>3、分布式事务DTX：</p><p>4、数据迁移Migration：</p><p>5、数据集群扩容Scaling：</p><p>6、数据操作审计Audit：</p><p><strong>M1 M2 S2</strong></p><p><strong>Sharding-Proxy</strong></p><p><strong>Business</strong></p><p><strong>Machine A</strong></p><p><strong>Sharding-JDBC</strong></p><p><strong>Machine B</strong></p><p><strong>Business</strong></p><p><strong>Sharding-JDBC</strong></p><p><strong>Sharding-Scaling</strong></p><p><strong>MySQL Client</strong></p><p><strong>PostgreSQL Client</strong></p><p><strong>S1</strong></p><p><strong>Core</strong></p><p><strong>Parse</strong></p><p><strong>Sharding</strong></p><p><strong>Transaction</strong></p><p><strong>Encryption</strong></p><p><strong>Shadow</strong></p><p><strong>Orchestration</strong></p><p><strong>OpenTracing</strong></p><p><strong>TrafficControl</strong></p><p><strong>OnlineChange</strong></p><p><strong>Metrics</strong></p><p><strong>Sharding-UI</strong></p><p><strong>D</strong></p><p><strong>B</strong></p><p><strong>Cl</strong></p><p><strong>u</strong></p><p><strong>s</strong></p><p><strong>t</strong></p><p><strong>e</strong></p><p><strong>r</strong></p><p><strong><em>\</em>相关工具-网关与通信**</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411180846.png" alt="image-20210411180846245"></p><p>1、流量网关与WAF(Nginx/OR/Kong/Apisix)</p><p>2、业务网关(Zuul/Zuul2/SCG)</p><p>3、REST与其他协议之争（websocket/actor/rsocket/mq…）</p><p><strong>Zuul2</strong></p><h2 id="第-20-课-6-总结回顾与作业实践"><a href="#第-20-课-6-总结回顾与作业实践" class="headerlink" title="第 20 课 6.总结回顾与作业实践"></a>第 20 课 6.总结回顾与作业实践</h2><p><strong>第 20 课总结回顾</strong></p><p><strong>微服务架构发展历程</strong></p><p><strong>微服务使用场景与最佳实践</strong></p><p><strong>Spring Cloud技术体系</strong></p><p><strong>微服务相关技术与工具</strong></p><p><strong>第 20 课作业实践</strong></p><p>1、（选做）进度快的，把前几次课的选做题做做。</p><p>2、（选做）进度慢的，把前几次课的必做题做做。</p><p>3、（选做）学霸和课代表，，考虑多做做挑战题。</p><p>缓冲一周，下周再战。</p><p>据说元旦放假，注意劳逸结合，一张一弛，，我们可以组团带崔老师打王者。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week10-01 分布式服务-深入分布式服务化</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week10-01%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%8C%96/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week10-01%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 19 课</p><p>分布式服务-深入分布式服务化</p><p>KimmKing</p><p>Apache Dubbo/ShardingSphere PMC<strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><ol><li>分布式服务治理*</li></ol><p>2.配置/注册/元数据中心*</p><p>3.服务的注册与发现*</p><p>4.服务的集群与路由*</p><p>5.服务的过滤与流控</p><p>6.总结回顾与作业实践</p><h2 id="第-19-课-1-分布式服务治理"><a href="#第-19-课-1-分布式服务治理" class="headerlink" title="第 19 课 1. 分布式服务治理"></a>第 19 课 1. 分布式服务治理</h2><p><strong>从RPC走向服务化-&gt;微服务架构</strong></p><p>还有没有其他要考虑的点？</p><p>具体的分布式业务场景里，除了能够调用远程方法，我们还需要考虑什么？</p><p>1、多个相同服务如何管理？ ==&gt; 集群/分组/版本 =&gt; 分布式与集群</p><p>2、服务的注册发现机制？ ==&gt; 注册中心/注册/发现</p><p>3、如何负载均衡，路由等集群功能？ ==&gt; 路由/负载均衡</p><p>4、熔断，限流等治理能力。 ==&gt; 过滤/流控</p><p>5、心跳，重试等策略。</p><p>6、高可用、监控、性能等等。</p><p><strong>RPC与分布式服务化的区别</strong></p><p>RPC：技术概念</p><p>》以RPC来讲，我们前面的自定义RPC功能已经差不多了。</p><p>》可以再考虑一下性能优化，使用spring-boot等封装易用性。</p><p>分布式服务化：服务是业务语义，偏向于业务与系统的集成</p><p>》以分布式服务化框架的角度来看，我们还差前面的这些非功能性需求能力。</p><p>》具体使用时，另外一个重点是如何设计分布式的业务服务。</p><p>注意 ：服务 != 接口，服务可以用接口或接口文档之类的语言描述。</p><p>JHWH</p><p><strong>分布式服务化与SOA/ESB的区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175539.png" alt="image-20210411175539704"></p><p>SOA/ESB：代理调用，直接增强</p><p>A系统</p><p>B系统</p><p>C系统</p><p>ESB</p><p>X系统</p><p>Y系统</p><p>服务汇聚到ESB： Z系统</p><p>1、暴露和调用</p><p>2、增强和中介</p><p>3、统计和监控</p><p><strong>分布式服务化与SOA/ESB的区别</strong></p><p>分布式服务化作为SOA的另一种选择，以不同方式把ESB的一些功能重做了一遍</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175554.png" alt="image-20210411175554578"></p><p><strong>分布式服务化与SOA/ESB的区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175610.png" alt="image-20210411175610387"></p><p>分布式服务化：直连调用，侧边增强</p><p>A系统</p><p>B系统</p><p>C系统</p><p>配置与注册发现</p><p>X系统</p><p>Y系统</p><p>Z系统</p><p><strong>分布式服务化与SOA/ESB的区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175629.png" alt="image-20210411175629867"></p><p>上面的配置/注册发现等就演化成了代替ESB容器的新组件：配置中心、注册中心等。</p><p>然后呢？原本的增强能力放到哪儿呢？</p><p>A系统</p><p>配置中心</p><p>注册中心</p><p>X系统</p><p><strong>分布式服务化与SOA/ESB的区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175642.png" alt="image-20210411175642282"></p><p>RPC之上的增强能力根据特点：</p><p>1、有状态的部分，放到xx中心</p><p>2、无状态的部分，放到应用侧（具体来说是框架和配置部分，尽量不影响业务代码）</p><p>A系统</p><p>配置中心</p><p>注册中心</p><p>元数据中心</p><p>X系统</p><p>框架治理模块 框架治理模块</p><p>RPC模块 RPC模块</p><h2 id="第-19-课-2-配置-注册-元数据中心"><a href="#第-19-课-2-配置-注册-元数据中心" class="headerlink" title="第 19 课 2. 配置/注册/元数据中心"></a>第 19 课 2. 配置/注册/元数据中心</h2><p><strong>配置、注册、元数据，有何异同？</strong></p><p>配置中心（ConfigCenter）：管理系统需要的配置参数信息</p><p>注册中心（RegistryCenter）：管理系统的服务注册、提供发现和协调能力</p><p>元数据中心（MetadataCenter）：管理各个节点使用的元数据信息</p><p>相同点：都需要保存和读取数据/状态，变更通知</p><p>不同点：配置是全局非业务参数，注册中心是运行期临时状态，元数据是业务模型</p><p><strong>为什么会需要配置中心？</strong></p><p>想想看：</p><p>1、大规模集群下，如何管理配置信息，特别是批量更新问题。</p><p>2、大公司和金融行业，一般要求开发、测试、运维分离（物理隔离）。</p><p>3、运行期的一些开关控制，总不能不断重启？？</p><p>Zookeeper、etcd、Nacos、Apollo。。。</p><p><strong>为什么会需要注册中心？</strong></p><p>有什么办法，让消费者能动态知道生产者集群的状态变化？</p><p>1、hello.htm -&gt; ok</p><p>2、DNS？VIP？</p><p>3、主动报告+心跳</p><p>这些信息很重要，后续的集群管控，分布式服务治理，都要靠这个全局状态。</p><p><strong>为什么会需要元数据中心？</strong></p><p>一般情况下，没有问题也不大。</p><p>有了更好。</p><p>元数据中心，定义了所有业务服务的模型。</p><p><strong>如何实现XX中心？</strong></p><p>最核心的两个要素：</p><p>1、需要有存取数据的能力，特别是临时数据的能力。</p><p>2、需要有数据变化的实时通知机制，全量 或 增量。</p><p>主流的基座，一般都可以使用namespace的概念，用来在顶层隔离不同环境。</p><p>zk没有，但是我们一般用第一个根节点作为namespace。</p><p><strong>如何实现XX中心？</strong></p><p>以某开源软件为例，设计的XX中心与基座</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175659.png" alt="image-20210411175659063"></p><h2 id="第-19-课-3-服务的注册与发现"><a href="#第-19-课-3-服务的注册与发现" class="headerlink" title="第 19 课 3. 服务的注册与发现"></a>第 19 课 3. 服务的注册与发现</h2><p><strong>服务注册</strong></p><p>服务提供者启动时，</p><p>将自己注册到注册中心（比如zk实现）的临时节点。</p><p>停止或者宕机时，临时节点消失。</p><p><strong>服务注册</strong></p><p>注册的数据格式</p><p>节点key，代表当前服务（或者服务+版本）</p><p>多个子节点，每一个为一个提供者的描述信息</p><p><strong>服务发现</strong></p><p>服务消费者启动时，</p><p>从注册中心代表服务的主节点拿到多个代表提供者的临时节点列表，并本地缓存</p><p>（why？？？）。</p><p>根据router和loadbalance算法从其中的某一个执行调用。</p><p>如果可用的提供者集合发生变化时，注册中心通知消费者刷新本地缓存的列表。</p><p>例如zk可以使用curator作为客户端操作。</p><h2 id="第-19-课-4-服务的集群与路由"><a href="#第-19-课-4-服务的集群与路由" class="headerlink" title="第 19 课 4. 服务的集群与路由"></a>第 19 课 4. 服务的集群与路由</h2><p><strong>服务集群</strong></p><p>多个服务提供者都提供了同样的服务，这时应该如何处理？</p><blockquote><blockquote><p>大家回忆一下，我们提到了多少种处理方式。</p></blockquote></blockquote><p>对于完全相同能力的多个服务，我们希望他们能一切协同工作，分摊处理流量。</p><p>路由</p><p>负载均衡<strong>服务路由（Service Route）</strong></p><p>跟网关的路由一样</p><p>1、比如基于IP段的过滤，</p><p>2、再比如服务都带上tag，用tag匹配这次调用范围。</p><p><strong>服务负载均衡（Service LoadBalance）</strong></p><p>跟Nginx的负载均衡一样。</p><p>多个不同策略，原理不同，目的基本一致（尽量均匀）：</p><p>1、Random（带权重）</p><p>2、RoundRobin（轮询）</p><p>3、LeastActive（快的多给）</p><p>4、ConsistentHashLoadBalance（同样参数请求到一个提供者）</p><h2 id="第-19-课-5-服务的过滤与流控"><a href="#第-19-课-5-服务的过滤与流控" class="headerlink" title="第 19 课 5.服务的过滤与流控"></a>第 19 课 5.服务的过滤与流控</h2><p><strong>服务过滤</strong></p><p>所有的复杂处理，都可以抽象为管道+过滤器模式（Channel+Filter）</p><p>这个机制是一个超级bug的存在，</p><p>可以用来实现额外的增强处理（类似AOP），也可以中断当前处理流程，返回特定数据。</p><p>对比考虑一下，我们NIO网关时的filter，servlet的filter等。</p><p><strong>为什么需要服务流控（Flow Control）</strong></p><p>稳定性工程：</p><p>1、我们逐渐意识到一个问题：系统会故障是正常现象，就像人会生病</p><p>2、那么在系统出现问题时，直接不服务，还是保持部分服务能力呢？</p><p>系统的容量有限。</p><p>保持部分服务能力是最佳选择，然后在问题解决后恢复正常状态。</p><p>响应式编程里，这就是所谓的回弹性（Resilient）。</p><p>需要流控的本质原因是，输入请求大于处理能力。</p><p><strong>服务流控</strong></p><p>流控有三个级别：</p><p>1、限流（内部线程数，外部调用数或数据量）</p><p>2、服务降级（去掉不必要的业务逻辑，只保留核心逻辑）</p><p>3、过载保护（系统短时间不提供新的业务处理服务，积压处理完后再恢复输入请求）</p><h2 id="第-19-课-6-总结回顾与作业实践"><a href="#第-19-课-6-总结回顾与作业实践" class="headerlink" title="第 19 课 6.总结回顾与作业实践"></a>第 19 课 6.总结回顾与作业实践</h2><p><strong>第 19 课总结回顾</strong></p><p><strong>分布式服务治理</strong></p><p><strong>配置/注册/元数据中心</strong></p><p><strong>服务的注册与发现</strong></p><p><strong>服务的集群与路由</strong></p><p><strong>服务的过滤与流控</strong></p><p><strong>第 19 课作业实践</strong></p><p>1、（选做）rpcfx1.1: 给自定义RPC实现简单的分组(group)和版本(version)。</p><p>2、（选做）rpcfx2.0: 给自定义RPC实现：</p><p>1）基于zookeeper的注册中心，消费者和生产者可以根据注册中心查找可用服务进行</p><p>调用(直接选择列表里的最后一个)。</p><p>2）当有生产者启动或者下线时，通过zookeeper通知并更新各个消费者，使得各个消</p><p>费者可以调用新生产者或者不调用下线生产者。</p><p>3、（挑战☆）在2.0的基础上继续增强rpcfx实现：</p><p>1）3.0: 实现基于zookeeper的配置中心，消费者和生产者可以根据配置中心配置参数</p><p>（分组，版本，线程池大小等）。</p><p>2）3.1：实现基于zookeeper的元数据中心，将服务描述元数据保存到元数据中心。</p><p>3）3.2：实现基于etcd/nacos/apollo等基座的配置/注册/元数据中心。</p><p><strong>第 19 课作业实践</strong></p><p>4、（挑战☆☆）在3.2的基础上继续增强rpcfx实现：</p><p>1）4.0：实现基于tag的简单路由；</p><p>2）4.1：实现基于Weight/ConsistentHash的负载均衡;</p><p>3）4.2：实现基于IP黑名单的简单流控；</p><p>4）4.3：完善RPC框架里的超时处理，增加重试参数；</p><p>5、（挑战☆☆☆）在4.3的基础上继续增强rpcfx实现：</p><p>1）5.0：实现利用HTTP头跨进程传递Context参数（隐式传参）；</p><p>2）5.1：实现消费端mock一个指定对象的功能（Mock功能）；</p><p>3）5.2：实现消费端可以通过一个泛化接口调用不同服务（泛化调用）；</p><p>4）5.3：实现基于Weight/ConsistentHash的负载均衡;</p><p>5）5.4：实现基于单位时间调用次数的流控，可以基于令牌桶等算法；</p><p>5、（挑战☆☆☆☆）</p><p>6.0：压测，并分析调优5.4版本。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week09-01 分布式服务-RPC与分布式服务化</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week09-01%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-RPC%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%8C%96/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week09-01%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-RPC%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 17 课</p><p>分布式服务-RPC与分布式服务化</p><p>KimmKing</p><p>Apache Dubbo/ShardingSphere PMC<strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><ol><li>RPC基本原理*</li></ol><p>2.RPC技术框架*</p><p>3.如何设计一个RPC</p><p>4.从RPC到分布式服务化</p><p>5.总结回顾与作业实践</p><h2 id="1-RPC基本原理"><a href="#1-RPC基本原理" class="headerlink" title="1. RPC基本原理"></a>1. RPC基本原理</h2><p><strong>RPC是什么</strong></p><p>RPC是远程过程调用（Remote Procedure Call）的缩写形式。</p><p>RPC的概念与技术早在1981年由Nelson提出。</p><p>1984年，Birrell和Nelson把其用于支持异构型分布式系统间的通讯。Birrell的RPC 模</p><p>型引入存根进程( stub) 作为远程的本地代理，调用RPC运行时库来传输网络中的调用。</p><p>Stub和RPC runtime屏蔽了网络调用所涉及的许多细节，特别是，参数的编码/译码及</p><p>网络通讯是由stub和RPC runtime完成的，因此这一模式被各类RPC所采用。</p><p><strong>RPC是什么</strong></p><p>什么叫RPC呢？</p><p>简单来说，就是“像调用本地方法一样调用远程方法”。</p><p>UserService service = new UserService();</p><p>User user = service.findById(1);</p><p>UserService service = Rpcfx.create(UserService.class, url);</p><p>User user = service.findById(1);</p><p>如何能做到本地方法调用时转换成远程？</p><p><strong>RPC原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175046.png" alt="image-20210411175046509"></p><p>RPC的简化版原理如下图。</p><p>核心是代理机制。</p><p>1.本地代理存根: Stub</p><p>2.本地序列化反序列化</p><p>3.网络通信</p><p>4.远程序列化反序列化</p><p>5.远程服务存根: Skeleton</p><p>6.调用实际业务服务</p><p>7.原路返回服务结果</p><p>8.返回给本地调用方</p><p>注意处理异常。</p><p><strong>RPC原理–1.设计</strong></p><p>RPC是基于接口的远程服务调用。</p><p>本地应用程序 与 远程应用程序，分别需要共享什么信息，角色有什么不同？</p><p>共享：POJO实体类定义，接口定义。</p><p>REST/PB下，真的不需要嘛？另一种选择：WSDL/WADL/IDL</p><p>远程-&gt;服务提供者，本地-&gt;服务消费者。</p><p><strong>RPC原理–2.代理</strong></p><p>RPC是基于接口的远程服务调用。</p><p>Java下，代理可以选择动态代理，或者AOP实现</p><p>C#直接有远程代理</p><p>Flex可以使用动态方法和熟悉</p><p><strong>RPC原理–3.序列化</strong></p><p>序列化和反序列化的选择：</p><p>1、语言原生的序列化，RMI，Remoting</p><p>2、二进制平台无关，Hessian，avro，kyro，fst等</p><p>3、文本，JSON、XML等</p><p><strong>RPC原理–4.网络传输</strong></p><p>最常见的传输方式：</p><p>TCP/SSL</p><p>HTTP/HTTPS</p><h2 id="2-RPC技术框架"><a href="#2-RPC技术框架" class="headerlink" title="2. RPC技术框架"></a>2. RPC技术框架</h2><p><strong>RPC技术框架</strong></p><p>很多语言都内置了RPC技术。</p><p>Java RMI</p><p>.NET Remoting</p><p>远古时期，就有很多尝试，</p><p>Corba（Common ObjectRequest Broker Architecture）公共对象请求代理体系结</p><p>构，OMG组织在1991年提出的公用对象请求代理程序结构的技术规范。底层结构是基</p><p>于面向对象模型的，由OMG接口描述语言(OMG Interface Definition Language，</p><p>OMG IDL)、对象请求代理(Objec tRequest Broker，ORB)和IIOP标准协议（Internet</p><p>Inter­ ORB Protocol，也称网络ORB交换协议）3个关键模块组成。</p><p>COM（Component Object Model，组件对象模型）是微软公司于1993年提出的一</p><p>种组件技术，它是一种平台无关、语言中立、位置透明、支持网络的中间件技术。很多</p><p>老一辈程序员心目中的神书《COM本质论》。</p><p><strong>常见的RPC技术</strong></p><p>Corba/RMI/.NET Remoting</p><p>JSON RPC, XML RPC，WebService(Axis2, CXF)</p><p>Hessian, Thrift, Protocol Buffer, gRPC</p><p><strong>常见的RPC技术</strong></p><p>Hessian</p><h2 id="3-如何设计一个RPC框架"><a href="#3-如何设计一个RPC框架" class="headerlink" title="3. 如何设计一个RPC框架"></a>3. 如何设计一个RPC框架</h2><p><strong>假如我们自己设计一个RPC框架</strong></p><p>从哪些方面考虑？</p><p>基于共享接口还是IDL?</p><p>动态代理 or AOP？</p><p>序列化用什么？文本 or 二进制？</p><p>基于TCP还是HTTP?</p><p>还有没有要考虑的？</p><p><strong>RPC原理–1.设计</strong></p><p>RPC是基于接口的远程服务调用。</p><p>本地应用程序 与 远程应用程序，分别需要共享什么信息，角色有什么不同？</p><p>共享：POJO实体类定义，接口定义。</p><p>REST/PB下，真的不需要嘛？另一种选择：WSDL/WADL/IDL</p><p>远程-&gt;服务提供者，本地-&gt;服务消费者。</p><p><strong>RPC原理–2.代理</strong></p><p>RPC是基于接口的远程服务调用。</p><p>Java下，代理可以选择动态代理，或者AOP实现</p><p>C#直接有远程代理</p><p>Flex可以使用动态方法和熟悉<strong>RPC原理–3.序列化</strong></p><p>序列化和反序列化的选择：</p><p>1、语言原生的序列化，RMI，Remoting</p><p>2、二进制平台无关，Hessian，avro，kyro，fst等</p><p>3、文本，JSON、XML等</p><p><strong>RPC原理–4.网络传输</strong></p><p>最常见的传输方式：</p><p>TCP/SSL</p><p>HTTP/HTTPS</p><h2 id="4-从RPC到分布式服务化"><a href="#4-从RPC到分布式服务化" class="headerlink" title="4. 从RPC到分布式服务化"></a>4. 从RPC到分布式服务化</h2><p><strong>从RPC走向服务化-&gt;微服务架构</strong></p><p>具体的分布式业务场景里，除了能够调用远程方法，我们还需要考虑什么？</p><p>1、多个相同服务如何管理？</p><p>2、服务的注册发现机制？</p><p>3、如何负载均衡，路由等集群功能？</p><p>4、熔断，限流等治理能力。</p><p>5、重试等策略</p><p>6、高可用、监控、性能等等。</p><p><strong>从RPC走向服务化</strong></p><p>一个典型的分布式服务化架构</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175113.png" alt="image-20210411175113370"></p><h2 id="5-总结回顾与作业实践"><a href="#5-总结回顾与作业实践" class="headerlink" title="5.总结回顾与作业实践"></a>5.总结回顾与作业实践</h2><p><strong>第 17 课总结回顾</strong></p><p><strong>RPC技术原理</strong></p><p><strong>RPC技术框架</strong></p><p><strong>RPC框架设计</strong></p><p><strong>分布式服务化</strong></p><p><strong>第 17 课作业实践</strong></p><p>1、（选做）实现简单的Protocol Buffer/Thrift/gRPC(选任一个)远程调用demo。</p><p>2、（选做）实现简单的WebService-Axis2/CXF远程调用demo。</p><p>3、（必做）改造自定义RPC的程序，提交到github：</p><p>1）尝试将服务端写死查找接口实现类变成泛型和反射</p><p>2）尝试将客户端动态代理改成AOP</p><p>3）尝试使用Netty+HTTP作为client端传输方式</p><p>4、（选做☆☆）升级自定义RPC的程序：</p><p>1）尝试使用压测并分析优化RPC性能</p><p>2）尝试使用Netty+TCP作为两端传输方式</p><p>3）尝试自定义二进制序列化</p><p>4）尝试压测改进后的RPC并分析优化，有问题欢迎群里讨论</p><p>5）尝试将fastjson改成xstream</p><p>6）尝试使用字节码生成方式代替服务端反射</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week09-02 分布式服务-Dubbo技术详解</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week09-02%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-Dubbo%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week09-02%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1-Dubbo%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 18 课</p><p>分布式服务-Dubbo技术详解</p><p>KimmKing</p><p>Apache Dubbo/ShardingSphere PMC<strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><ol><li>Dubbo框架介绍*</li></ol><p>2.Dubbo技术原理*</p><p>3.Dubbo应用场景*</p><p>4.Dubbo最佳实践*</p><p>5.总结回顾与作业实践</p><h2 id="第-18-课-1-Dubbo框架介绍"><a href="#第-18-课-1-Dubbo框架介绍" class="headerlink" title="第 18 课 1. Dubbo框架介绍*"></a>第 18 课 1. Dubbo框架介绍*</h2><p><strong>Dubbo的发展历史</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175218.png" alt="image-20210411175218733"></p><p>开源期(2011-2013，横空出世)：Dubbo是阿里巴巴B2B开发的，2011年开源。</p><p>沉寂期(2013-2017，潜龙在渊)：2013年到2017年，dubbo的维护程度很低。</p><p>复兴期(2017-2019，朝花夕拾)：2017年8月份重启维护，2018年2月加入Apache孵化</p><p>器，2019年5月顺利毕业。</p><p><strong>Dubbo的发展历史</strong></p><p>Dubbo产生于阿里巴巴B2B的实际业务需要。</p><p>淘系的HSF，随着B2B退市，团队分流，导致Dubbo停滞。</p><p>2013年以后，国内Dubbo存量用户一直最多，增量Spring Cloud后来居上。</p><p>类似IE浏览器与Chrome浏览器。</p><p>当当、京东等公司的服务化都是基于Dubbo实现的，四大行都有使用。</p><p><strong>Dubbo的主要功能</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175234.png" alt="image-20210411175234674"></p><p>Apache Dubbo 是一款高性能、轻量级的开源 Java 服务框架</p><p>六大核心能力：</p><p>面向接口代理的高性能RPC调用，智能容错和负载均衡，服务自动注册和发现，高度可</p><p>扩展能力，运行期流量调度，可视化的服务治理与运维。</p><p><strong>Dubbo的主要功能</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175251.png" alt="image-20210411175251445"></p><p>基础功能：RPC调用</p><p>多协议（序列化、传输、RPC）</p><p>服务注册发现</p><p>配置、元数据管理</p><p>框架分层设计，可任意组装和扩展。</p><p><strong>Dubbo的主要功能</strong></p><p>扩展功能：集群、高可用、管控</p><p>集群，负载均衡</p><p>治理，路由，</p><p>控制台，管理与监控</p><p>灵活扩展+简单易用，是Dubbo成功的秘诀。</p><h2 id="2-Dubbo技术原理"><a href="#2-Dubbo技术原理" class="headerlink" title="2. Dubbo技术原理*"></a>2. Dubbo技术原理*</h2><p><strong>整体架构整体架构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175311.png" alt="image-20210411175311751"></p><ol><li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li></ol><p>2.proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以ServiceProxy 为中心，扩展接口为 ProxyFactory</p><p>3.registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为RegistryFactory, Registry, RegistryService</p><p>4.cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</p><p>5.monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为MonitorFactory, Monitor, MonitorService</p><p><strong>整体架构</strong></p><ol><li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为Protocol, Invoker, Exporter</li><li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li></ol><p>8.transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为Channel, Transporter, Client, Server, Codec</p><p>9.serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput,ObjectOutput, ThreadPool</p><p><strong>框架设计</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175334.png" alt="image-20210411175334940"></p><p><strong>SPI的应用</strong></p><p>SPI 与 API</p><p>ServiceLoader机制</p><p>META-INF/dubbo/接口全限定名，文件内容为实现类（ShardingSphere使用）</p><p>其他两个类似的机制：Callback与EventBus</p><p>Dubbo的SPI扩展，最关键的SPI：Protocol</p><p>xxx=com.alibaba.xxx.XxxProtocol</p><p>启动时装配，并缓存到ExtensionLoader中。</p><p><strong>服务如何暴露</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175354.png" alt="image-20210411175354790"></p><p>以InjvmProtocol为例，</p><p>InjvmProtocol</p><p>InjvmExporter</p><p>XX Invoker</p><p>注意：服务都是使用 URL 表示：</p><p>dubbo://192.168.0.1:20880/com.linyang.test.service.LogService?anyhost=true&amp;application</p><p>=log&amp;default.proxy=javassist&amp;default.retries=0&amp;default.timeout=30000&amp;default.version=L</p><p>ATEST&amp;dubbo=2.5.3&amp;interface=com.xxx.test.service.LogService&amp;methods=modify,create</p><p>&amp;pid=2747&amp;side=provider&amp;threads=100×tamp=1525835283678</p><p><strong>服务如何引用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411175425.png" alt="image-20210411175425278"></p><p>ServiceReference</p><p>ReferenceConfig</p><p>createProxy 中 创建 Invoker</p><p><strong>集群与路由</strong></p><p>Cluster</p><ul><li>Router ： 选取此次调用可以提供服务的invoker集合</li><li>LoadBalance：从上述集合选取一个作为最终调用者</li></ul><p>Random，RoundRobin，</p><p><strong>泛化引用</strong></p><p>GenericService</p><p>当我们知道接口、方法和参数，不用存根方式，而是用反射方式调用任何服务。</p><p>方法1：</p><p>&lt;dubbo:reference id=”barService” interface=”com.foo.BarService” generic=”true” /&gt;</p><p>GenericService barService = (GenericService) applicationContext.getBean(“barService”);</p><p>Object result = barService.$invoke(“sayHello”, new String[] { “java.lang.String” }, new Object[]</p><p>{ “World” });</p><p>方法2：</p><p>ReferenceConfig<genericservice> reference = new ReferenceConfig<genericservice>();</genericservice></genericservice></p><p>reference.setInterface(“com.xxx.XxxService”);</p><p>reference.setVersion(“1.0.0”);</p><p>reference.setGeneric(true);</p><p>GenericService genericService = reference.get();</p><p><strong>隐式传参</strong></p><p>Context模式</p><p>RpcContext.getContext().setAttachment(“index”, “1”);</p><p>此参数可以传播到RPC调用的整个过程。</p><p>大家觉得是如何实现的？</p><p><strong>mock</strong></p><p>Mock</p><p>&lt;dubbo.reference id=”helloService” interface=”xxx.HelloService” mock=”true”</p><p>timeout=”1000” check=”false”&gt;</p><p>需要实现一个 HelloServiceMock类</p><h2 id="第-18-课-3-Dubbo应用场景"><a href="#第-18-课-3-Dubbo应用场景" class="headerlink" title="第 18 课 3. Dubbo应用场景"></a>第 18 课 3. Dubbo应用场景</h2><p><strong>分布式服务化改造</strong></p><p>业务系统规模复杂，垂直拆分改造</p><p>数据相关改造</p><p>服务设计</p><p>不同团队的配合</p><p>开发、测试运维<strong>开放平台</strong></p><p>平台发展的两个模式：开放模式、容器模式。</p><p>将公司的业务能力开发出来，形成开发平台，对外输出业务或技术能力。</p><p><strong>直接作为前端使用的后端（BFF）</strong></p><p>直接作为BFF给前端（Web或Mobile）提供服务。</p><p>一般不太建议这种用法。</p><p><strong>通过服务化建设中台</strong></p><p>将公司的所有业务服务能力，包装成API，形成所谓的业务中台。</p><p>前端业务服务，各个业务线，通过调用中台的业务服务，灵活组织自己的业务。</p><p>从而实现服务的服用能力，以及对于业务变化的快速响应。</p><h2 id="第-18-课-4-Dubbo最佳实践"><a href="#第-18-课-4-Dubbo最佳实践" class="headerlink" title="第 18 课 4. Dubbo最佳实践"></a>第 18 课 4. Dubbo最佳实践</h2><p><strong>开发分包</strong></p><p>建议将服务接口、服务模型、服务异常等均放在 API 包中，因为服务模型和异常也是</p><p>API 的一部分，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则</p><p>(CRP)。</p><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否</p><p>则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，</p><p>会给后期维护带来不便。</p><p><strong>环境隔离与分组</strong></p><p>怎么做多环境的隔离？</p><p>1、部署多套？</p><p>2、多注册中心机制</p><p>3、group机制</p><p>4、版本机制</p><p>服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼</p><p>容，枚举类型新增字段也不兼容，需通过变更版本号升级。</p><p><strong>参数配置</strong></p><p>通用参数以 consumer 端为准，如果consumer端没有设置，使用provider数值</p><p>建议在 Provider 端配置的 Consumer 端属性有：</p><p>timeout：方法调用的超时时间</p><p>retries：失败重试次数，缺省是 2 2</p><p>loadbalance：负载均衡算法 3，缺省是随机 random。</p><p>actives：消费者端的最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新</p><p>调用会阻塞直到超时，可以配置在方法或服务上。</p><p>建议在 Provider 端配置的 Provider 端属性有：</p><p>threads：服务线程池大小</p><p>executes：一个服务提供者并行执行请求上限，即当 Provider 对一个服务的并发调用达到上限</p><p>后，新调用会阻塞，此时 Consumer 可能会超时。可以配置在方法或服务上。</p><p><strong>容器化部署</strong></p><p>注册的IP问题，两个解决办法：</p><p>1、docker使用宿主机网络</p><p>docker xxx -net xxxxx</p><p>2、docker参数指定注册的IP和端口, -e</p><p>DUBBO_IP_TO_REGISTRY — 注册到注册中心的IP地址</p><p>DUBBO_PORT_TO_REGISTRY — 注册到注册中心的端口</p><p>DUBBO_IP_TO_BIND — 监听IP地址</p><p>DUBBO_PORT_TO_BIND — 监听端口</p><p><strong>运维与监控</strong></p><p>Admin功能较简单，大规模使用需要定制开发，整合自己公司的运维监控系统。</p><p>可观测性：tracing、metrics、logging</p><p>APM</p><p>Promethus+Grafana</p><p><strong>分布式事务</strong></p><p>柔性事务，SAGA、TCC、AT</p><p>Seata</p><p>hmily</p><p>不支持 XA</p><p><strong>重试与幂等</strong></p><p>服务调用失败默认重试2次，如果接口不是幂等的，会造成业务重复处理。</p><p>如何设计幂等接口？</p><p>1、去重</p><p>2、类似乐观锁机制</p><h2 id="第-18-课-5-总结回顾与作业实践"><a href="#第-18-课-5-总结回顾与作业实践" class="headerlink" title="第 18 课 5.总结回顾与作业实践"></a>第 18 课 5.总结回顾与作业实践</h2><p><strong>第 18 课总结回顾</strong></p><p><strong>Dubbo框架介绍</strong></p><p><strong>Dubbo技术原理</strong></p><p><strong>Dubbo应用场景</strong></p><p><strong>Dubbo最佳实践第</strong></p><p><strong>18 课作业实践</strong></p><p>1、（选做）按课程第二部分练习各个技术点的应用。</p><p>2、（选做）按dubbo-samples项目的各个demo学习具体功能使用。</p><p>3、（必做）结合dubbo+hmily，实现一个TCC外汇交易处理，代码提交到github：</p><p>1）用户A的美元账户和人民币账户都在A库，使用1美元兑换7人民币；</p><p>2）用户B的美元账户和人民币账户都在B库，使用7人民币兑换1美元；</p><p>3）设计账户表，冻结资产表，实现上述两个本地事务的分布式事务。</p><p>4、（挑战☆☆）尝试扩展Dubbo</p><p>1）基于上次作业的自定义序列化，实现Dubbo的序列化扩展；</p><p>2）基于上次作业的自定义RPC，实现Dubbo的RPC扩展；</p><p>3）在Dubbo的filter机制上，实现REST权限控制，可参考dubbox；</p><p>4）实现一个自定义Dubbo的Cluster/Loadbalance扩展，如果一分钟内调用某个服务/</p><p>提供者超过10次，则拒绝提供服务直到下一分钟；</p><p>5）整合Dubbo+Sentinel，实现限流功能；</p><p>6）整合Dubbo与Skywalking，实现全链路性能监控。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week08-02 超越分库分表-分布式事务</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week08-02%20%E8%B6%85%E8%B6%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week08-02%20%E8%B6%85%E8%B6%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 16 课</p><p>超越分库分表-分布式事务</p><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.分布式事务*</p><p>2.XA 分布式事务*</p><p>3.BASE 柔性事务*</p><p>4.TCC/AT 以及相关框架*</p><p>5.ShardingSphere 对分布式事务的支持</p><p>6.总结回顾与作业实践</p><h2 id="1-分布式事务高可用性"><a href="#1-分布式事务高可用性" class="headerlink" title="1. 分布式事务高可用性"></a>1. 分布式事务高可用性</h2><p>主从切换</p><p>读写压力</p><p>故障转移</p><p>多机集群 主从复制</p><p>容量问题 数据库拆分 分库分表</p><p>一致性问题 分布式事务 XA/柔性事务</p><p><strong>为什么需要分布式事务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171643.png" alt="image-20210411171643613"></p><p><strong>为什么需要分布式事务</strong></p><p>业务系统的复杂度提升，数据量的增加，比如导致出现分布式事务。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174205.png" alt="image-20210411174205053"></p><p><strong>什么叫分布式事务</strong></p><p>本地事务A</p><p>insert</p><p>update</p><p>分布式条件下，多个节点操作的整体事务一致性。</p><p>特别是在微服务场景下，业务 A 和业务 B 关联，事务 A 成功，事务 B 失败，由于跨系统，就会导致不被感知。此时从整体来看，数据是不一致的。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174219.png" alt="image-20210411174219861"></p><p>此时，业务系统只能拿到不完全的 A 服务数据，缺失 B 服务的数据。</p><p>本地事务B</p><p>insert</p><p>update</p><p><strong>如何实现分布式下的一致性</strong></p><p>典型情况下是两个思路：</p><p>1、理想状态：直接想单机数据库事务一样，多个数据库自动通过某种协调机制，实现了跨数据库节点的一致性。</p><p>使用场景：要求严格的一致性，比如金融交易类业务。</p><p>2、一般情况：可以容忍一段时间的数据不一致，最终通过超时终止，调度补偿，等等方式，实现数据的最终状态一致性。</p><p>使用场景：准实时或非实时的处理，比如 T+1 的各类操作，或者电商类操作。</p><p><strong>如何实现分布式下的一致性</strong></p><p>1、强一致 : XA</p><p>2、弱一致 :</p><ol><li>不用事务，业务侧补偿冲正</li><li>所谓的柔性事务，使用一套事务框架保证最终一致的事务</li></ol><h2 id="2-XA-分布式事务"><a href="#2-XA-分布式事务" class="headerlink" title="2. XA 分布式事务"></a>2. XA 分布式事务</h2><p><strong>XA 分布式事务协议</strong></p><p>基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA 分布式事务。</p><p>XA 整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。</p><p><strong>X/Open，即现在的 open group，是一个独立的组织，主要负责制定各种行</strong></p><p><strong>业技术标准。X/Open 组织主要由各大知名公司或者厂商进行支持，这些组</strong></p><p><strong>织不光遵循 X/Open 组织定义的行业技术标准，也参与到标准的制定。</strong></p><p><strong>XA 分布式事务协议</strong></p><p><strong>X/Open DTP 模型与 XA 规范</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174234.png" alt="image-20210411174234770"></p><p><strong>应用程序(Application Program ，简称AP)：用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作。</strong></p><p><strong>资源管理器(Resource Manager，简称RM)：如数据库、文件系统等，并提供访问资源的方式</strong></p><p><strong>事务管理器(Transaction Manager ，简称TM)：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。</strong></p><p><strong>XA 分布式事务协议</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174252.png" alt="image-20210411174252277"></p><p>XA 接口</p><p>xa_start ：负责开启或者恢复一个事务分支</p><p>xa_end： 负责取消当前线程与事务分支的关联</p><p>xa_prepare：询问 RM 是否准备好提交事务分支</p><p>xa_commit：通知 RM 提交事务分支</p><p>xa_rollback： 通知 RM 回滚事务分支</p><p>xa_recover : 需要恢复的 XA 事务</p><p>思考：为什么 XA 事务又叫两阶段事务？<strong>14</strong></p><p><strong>XA 分布式事务协议</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174308.png" alt="image-20210411174307933"></p><p><strong>MySQL 从5.0.3开始支持 InnoDB 引擎的 XA 分布式事务，MySQL Connector/J 从5.0.0版本开始支持 XA。</strong></p><p><strong>在 DTP 模型中，MySQL 属于资源管理器(RM)。分布式事务中存在多个 RM，由事务管理器 TM 来统一进行协调。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174322.png" alt="image-20210411174322435"></p><p><strong>XA 分布式事务协议</strong></p><p>MySQL XA 事务状态</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174341.png" alt="image-20210411174341610"></p><p><strong>XA 分布式事务协议</strong></p><p>完整的 XA 事务处理过程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174358.png" alt="image-20210411174358526"></p><p><strong>XA 分布式事务协议</strong></p><p>单个 MySQL 的内部操作</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174415.png" alt="image-20210411174415206"></p><p><strong>XA 分布式事务协议</strong></p><p>思考一个问题：XA 过程中，事务失败怎么办？</p><p>1、业务 SQL 执行过程，某个 RM 崩溃怎么处理？</p><p>2、全部 prepare 后，某个 RM 崩溃怎么处理？</p><p>3、commit 时，某个 RM 崩溃怎么办？</p><p><strong>XA 分布式事务协议</strong></p><p>5.7对 MySQL XA 的优化/bug 修复</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174440.png" alt="image-20210411174440051"></p><p><strong>XA 分布式事务协议</strong></p><p>主流支持 XA 的框架，比较推荐 Atomikos 和 narayana</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174458.png" alt="image-20210411174457934"></p><p><strong>XA 分布式事务协议</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174517.png" alt="image-20210411174517466"></p><p>注意：XA 默认不会改变隔离级别</p><p>一般情况下，不需要调高隔离级别</p><p>成熟的XA框架需要考虑TM的高可用性</p><p>极端情况下，一定有事务失败问题，需要监控和人工处理</p><h2 id="3-BASE-柔性事务"><a href="#3-BASE-柔性事务" class="headerlink" title="3. BASE 柔性事务"></a>3. BASE 柔性事务</h2><p><strong>BASE 柔性事务</strong></p><p>本地事务 -&gt; XA(2PC) -&gt; BASE</p><p>如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称为柔性事务。</p><p>BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。</p><p>基本可用（Basically Available）保证分布式事务参与方不一定同时在线。</p><p>柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。</p><p>而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升。</p><p><strong>BASE 柔性事务</strong></p><p>本地事务 -&gt; XA(2PC) -&gt; BASE</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174533.png" alt="image-20210411174533743"></p><p><strong>BASE 柔性事务</strong></p><p>BASE 柔性事务常见模式</p><p>1、TCC</p><p>通过手动补偿处理</p><p>2、AT</p><p>通过自动补偿处理</p><h2 id="4-TCC-AT-以及相关框架"><a href="#4-TCC-AT-以及相关框架" class="headerlink" title="4. TCC/AT 以及相关框架"></a>4. TCC/AT 以及相关框架</h2><p><strong>什么是 TCC</strong></p><p>BASE 柔性事务 TCC</p><p>TCC 模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有服务业务的 Try 状态来操作，如果都成功，则进行 Confirm 操作，如果任意一个 Try 发生错误，则全部 Cancel。</p><p>TCC 使用要求就是业务接口都必须实现三段逻辑：</p><p>1.准备操作 Try：完成所有业务检查，预留必须的业务资源。</p><p>2.确认操作 Confirm：真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。</p><p>3.取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</p><p><strong>什么是 TCC</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174551.png" alt="image-20210411174551806"></p><p>TCC 不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务，不同于AT的是就是需要自行定义各个阶段的逻辑，对业务有侵入。</p><p><strong>什么是 TCC</strong></p><p>TCC 需要注意的几个问题：</p><p>1、允许空回滚</p><p>2、防悬挂控制</p><p>3、幂等设计</p><p><strong>什么是 SAGA</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174611.png" alt="image-20210411174611297"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174628.png" alt="image-20210411174628103"></p><p>Saga 模式没有 try 阶段，直接提交事务。</p><p>复杂情况下，对回滚操作的设计要求较高。</p><p><strong>什么是 AT</strong></p><p>AT 模式就是两阶段提交，自动生成反向 SQL</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174708.png" alt="image-20210411174708516"></p><p><strong>柔性事务下隔离级别</strong></p><p>事务特性</p><p>原子性（Atomicity）：正常情况下保证。</p><p>一致性（Consistency），在某个时间点，会出现 A 库和 B 库的数据违反一致性要求的情况，但是最终是一致的。</p><p>隔离性（Isolation），在某个时间点，A 事务能够读到B事务部分提交的结果。</p><p>持久性（Durability），和本地事务一样，只要 commit 则数据被持久。</p><p>隔离级别</p><p>一般情况下都是读已提交（全局锁）、读未提交（无全局锁）。</p><p><strong>Seata</strong></p><p>Seata-TCC/AT 柔性事务</p><p>Seata 是阿里集团和蚂蚁金服联合打造的分布式事务框架。 其 AT 事务的目标是在微服务架构下，提供增量的事务 ACID 语意，让开发者像使用本地事务一样，使用分布式事务，核心理念同 Apache ShardingSphere 一脉相承。</p><p>Seata AT 事务模型包含TM (事务管理器)，RM (资源管理器) 和 TC (事务协调器)。 TC 是一个独立部署的服务，TM 和 RM 以 jar 包的方式同业务应用一同部署，它们同 TC 建立长连接，在整个事务生命周期内，保持远程通信。 TM 是全局事务的发起方，负责全局事务的开启，提交和回滚。 RM 是全局事务的参与者，负责分支事务的执行结果上报，并且通过 TC 的协调进行分支事务的提交和回滚。</p><p><strong>Seata</strong></p><p>Seata 管理的分布式事务的典型生命周期：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174726.png" alt="image-20210411174726359"></p><p>TM 要求 TC 开始一个全新的全局事务。</p><p>TC 生成一个代表该全局事务的 XID。</p><p>XID 贯穿于微服务的整个调用链。</p><p>TM 要求 TC 提交或回滚 XID 对应全局事务。</p><p>TC 驱动 XID 对应的全局事务下的所有分支事务完成提交或回滚。</p><p><strong>Seata - TCC</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174744.png" alt="image-20210411174744865"></p><p><strong>Seata - AT 原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174758.png" alt="image-20210411174758581"></p><p><strong>两阶段提交协议的演变：</strong></p><p><strong>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</strong></p><p><strong>二阶段：</strong></p><p><strong>提交异步化，非常快速地完成。</strong></p><p><strong>回滚通过一阶段的回滚日志进行反向补偿。</strong></p><p><strong>Seata - AT 原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174819.png" alt="image-20210411174819782"></p><p><strong>通过全局锁的方式，实现读写隔离。</strong></p><p><strong>1、本地锁控制本地操作；</strong></p><p><strong>2、全局锁控制全局提交。</strong></p><p><strong>hmily</strong></p><p>Hmily 是一个高性能分布式事务框架，开源于2017年，目前有 2800 个 Star，基于</p><p>TCC 原理实现，使用 Java 语言开发（JDK1.8+），天然支持 Dubbo、SpringCloud、Motan 等微服务框架的分布式事务。</p><p><strong>hmily 功能</strong></p><p>支持嵌套事务(Nested transaction support)等复杂场景</p><p>支持 RPC 事务恢复，超时异常恢复等，具有高稳定性</p><p>基于异步 Confirm 和 Cancel 设计，相比其他方式具有更高性能</p><p>基于 SPI 和 API 机制设计，定制性强，具有高扩展性</p><p>本地事务的多种存储支持 : redis/mongodb/zookeeper/file/mysql</p><p>事务日志的多种序列化支持 ：java/hessian/kryo/protostuff</p><p>基于高性能组件 disruptor 的异步日志性能良好</p><p>实现了 SpringBoot-Starter，开箱即用，集成方便</p><p>采用 Aspect AOP 切面思想与 Spring 无缝集成，天然支持集群</p><p>实现了基于 VUE 的 UI 界面，方便监控和管理</p><p><strong>hmily</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174836.png" alt="image-20210411174836287"></p><p>MainService：事务发起者（业务服务）</p><p>TxManage：事务协调者</p><p>ActorService：事务参与者（多个业务服务）</p><p>Try：事务执行</p><p>Confirm：事务确认</p><p>Cancel：事务回滚</p><p>Redo 日志 ：可以选择任意一种进行存储</p><p><strong>hmily</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174854.png" alt="image-20210411174854133"></p><h2 id="5-ShardingSphere-对分布式事务的支持"><a href="#5-ShardingSphere-对分布式事务的支持" class="headerlink" title="5. ShardingSphere 对分布式事务的支持"></a>5. ShardingSphere 对分布式事务的支持</h2><p><strong>ShardingSphere 对分布式事务的支持</strong></p><p>由于应用的场景不同，需要开发者能够合理的在性能与功能之间权衡各种分布式事务。</p><p>强一致的事务与柔性事务的 API 和功能并不完全相同，在它们之间并不能做到自由的透明切换。在开发决策阶段，就不得不在强一致的事务和柔性事务之间抉择，使得设计和开发成本被大幅增加。基于 XA 的强一致事务使用相对简单，但是无法很好的应对互联网的高并发或复杂系统的长事务场</p><p>景；柔性事务则需要开发者对应用进行改造，接入成本非常高，并且需要开发者自行实现资源锁定和反向补偿。</p><p>整合现有的成熟事务方案，为本地事务、两阶段事务和柔性事务提供统一的分布式事务接口，并弥补当前方案的不足，提供一站式的分布式事务解决方案是 Apache ShardingSphere 分布式事务模块的主要设计目标。</p><p><strong>ShardingSphere 对分布式事务的支持</strong></p><p>ShardingSphere 支持 XA 事务的常见几个开源实现</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174914.png" alt="image-20210411174914188"></p><p><strong>ShardingSphere 对分布式事务的支持</strong></p><p>ShardingSphere 支持 Seata 的柔性事务。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411174931.png" alt="image-20210411174931031"></p><p><strong>ShardingSphere 对分布式事务的支持</strong></p><p>ShardingSphere 的分布式事务模块。</p><p>6.总结回顾与作业实践</p><p><strong>第 16 课总结回顾</strong></p><p><strong>分布式事务协议 XA</strong></p><p><strong>BASE 柔性事务</strong></p><p><strong>分布式事务 TCC/AT</strong></p><p><strong>ShardingSphere</strong></p><p><strong>对分布式事务的支持</strong></p><p><strong>第 16 课作业实践</strong></p><p>1、（选做）列举常见的分布式事务，简单分析其使用场景和优缺点。</p><p>2、（必做）基于 hmily TCC 或 ShardingSphere 的 Atomikos XA 实现一个简单的分布</p><p>式事务应用 demo（二选一），提交到 Github。</p><p>3、（选做）基于 ShardingSphere narayana XA 实现一个简单的分布式事务 demo。</p><p>4、（选做）基于 seata 框架实现 TCC 或 AT 模式的分布式事务 demo。</p><p>5、（选做☆）设计实现一个简单的 XA 分布式事务框架 demo，只需要能管理和调用2</p><p>个 MySQL 的本地事务即可，不需要考虑全局事务的持久化和恢复、高可用等。</p><p>6、（选做☆）设计实现一个 TCC 分布式事务框架的简单 Demo，需要实现事务管理器，</p><p>不需要实现全局事务的持久化和恢复、高可用等。</p><p>7、（选做☆）设计实现一个 AT 分布式事务框架的简单 Demo，仅需要支持根据主键 id</p><p>进行的单个删改操作的 SQL 或插入操作的事务。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week08-01 超越分库分表-数据库拆分与分库分表</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week08-01%20%E8%B6%85%E8%B6%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86%E4%B8%8E%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week08-01%20%E8%B6%85%E8%B6%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86%E4%B8%8E%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 15 课</p><p>超越分库分表-数据库拆分与分库分表</p><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.为什么要做数据库拆分*</p><p>2.数据库垂直拆分*</p><p>3.数据库水平拆分*</p><p>4.相关的框架和中间件*</p><p>5.如何做数据迁移</p><p>6.总结回顾与作业实践</p><h2 id="1-为什么要做数据库拆分"><a href="#1-为什么要做数据库拆分" class="headerlink" title="1. 为什么要做数据库拆分"></a>1. 为什么要做数据库拆分</h2><p>高可用性 MHA/MGR/Orchestrator</p><p>读写压力</p><p>故障转移</p><p>多机集群 主从复制</p><p>容量问题 数据库拆分 分库分表</p><p>一致性问题 分布式事务 XA/柔性事务</p><p><strong>单机 MySQL 的技术演进</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171011.png" alt="image-20210411171011083"></p><p><strong>单机数据库已经无法适应互联网的发展</strong></p><p>业务飞速发展导致了数据规模的急速膨胀，单机数据库已经无法适应互联网业务的发展</p><p>传统的将数据集中存储至单一数据节点的解决方案，在容量、性能、可用性和运维成本这三方面已经难于满足</p><p>互联网的海量数据场景。我们在单库单表数据量超过一定容量水位的情况下，索引树层级增加，磁盘 IO 也很</p><p>可能出现压力，会导致很多问题。</p><p>从性能方面来说，由于关系型数据库大多采用 B+树类型的索引，在数据量超过阈值的情况下，索引深度的增</p><p>加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；同时，高并发访问请求也使得集中式数据库</p><p>成为系统的最大瓶颈。</p><p>从可用性的方面来讲，服务化的无状态型，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在</p><p>数据库之上。而单一的数据节点，或者简单的主从架构，已经越来越难以承担。从运维成本方面考虑，当一个</p><p>数据库实例中的数据达到阈值以上，数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。</p><p>主从复制是否能解决这个容量问题？</p><p><strong>几个例子</strong></p><p>1、无法执行 DDL，比如添加一列，或者增加索引，都会直接影响线上业务，导致长时</p><p>间的数据库无响应。</p><p>2、无法备份，与上面类似，备份会自动先 lock 数据库的所有表，然后导出数据，量大了就没法执行了。</p><p>3、影响性能与稳定性，系统越来越慢，随时可能会出现主库延迟高，主从延迟很高，且不可控，对业务系统有极大的破坏性影响。</p><p><strong>从读写分离到数据库拆分</strong></p><p>主从结构解决了高可用，读扩展，但是单机容量不变，单机写性能无法解决。</p><p>提升容量–&gt;分库分表，分布式，多个数据库，作为数据分片的集群提供服务。</p><p>降低单个节点的写压力。</p><p>提升整个系统的数据容量上限。</p><p>还有没有其他办法？</p><p><strong>扩展立方体</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171038.png" alt="image-20210411171038557"></p><p><strong>X 轴：通过 clone 整个系统复制，集群</strong></p><p><strong>Y 轴：通过解耦不同功能复制，业务拆分</strong></p><p><strong>Z 轴：通过拆分不同</strong></p><p><strong>数据扩展，数据分片数据库/数据的扩展</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171051.png" alt="image-20210411171051377"></p><p>业务分类数据 分布式服务化、微服务</p><p>全部数据</p><p>垂直分库分表</p><p>数据复制 主从结构、备份与高可用</p><p>任意数据 水平分库分表 分布式结构、任意扩容</p><h2 id="2-数据库垂直拆分"><a href="#2-数据库垂直拆分" class="headerlink" title="2. 数据库垂直拆分"></a>2. 数据库垂直拆分</h2><p><strong>垂直拆分以淘宝的服务化为例</strong></p><p>下面的图错了吧。。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171106.png" alt="image-20210411171106636"></p><p><strong>垂直分库分表 =&gt; 分布式服务化 =&gt; 微服务架构</strong></p><p><strong>以淘宝系统架构为例 说明。</strong></p><p><strong>1、服务不能复用</strong></p><p><strong>2、连接数不够</strong></p><p><strong>拆库</strong></p><p><strong>垂直拆分（拆库）：将一个数据库，拆分成多个提供不同业务数据处理能力的数据库。</strong></p><p><strong>例如拆分所有订单的数据和产品的数据，变成两个独立的库，这种方式对业务系统有极大的影</strong></p><p><strong>响，因为数据结构本身发生了变化，SQL 和关联关系也必随之发生了改变。原来一个复杂 SQL</strong></p><p><strong>直接把一批订单和相关的产品都查了出来，现在这个 SQL 不能用了，得改写 SQL 和程序。先</strong></p><p><strong>查询订单库数据，拿到这批订单对应的所有产品 id，再根据产品 id 集合去产品库查询所有的</strong></p><p><strong>产品信息，最后再业务代码里进行组装。</strong></p><p><strong>拆表</strong></p><p><strong>垂直拆分（拆表）：如果单表数据量过大，还可能需要对单表进行拆分。</strong></p><p><strong>比如一个 200 列的订单主表，拆分成十几个子表：订单表、订单详情表、订单收件信息表、订</strong></p><p><strong>单支付表、订单产品快照表等等。这个对业务系统的影响有时候可能会大到跟新作一个系统差</strong></p><p><strong>不多。对于一个高并发的线上生产系统进行改造，就像是给心脑血管做手术，动的愈多，越核</strong></p><p><strong>心，出现大故障的风险越高。所以，我们一般情况下，尽量少用这种办法。</strong></p><p><strong>垂直拆分的优缺点</strong></p><p><strong>1、单库（单表）变小，便于管理和维护</strong></p><p><strong>2、对性能和容量有提升作用</strong></p><p><strong>3、改造后，系统和数据复杂度降低</strong></p><p><strong>4、可以作为微服务改造的基础</strong></p><p><strong>1、库变多，管理变复杂</strong></p><p><strong>2、对业务系统有较强的侵入性</strong></p><p><strong>3、改造过程复杂，容易出故障</strong></p><p><strong>4、拆分到一定程度就无法继续拆分</strong></p><p>注意拆库和拆表的区别？</p><p><strong>垂直拆分的一般做法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171227.png" alt="image-20210411171226959"></p><p><strong>1、梳理清楚拆分范围和影响范围</strong></p><p><strong>2、检查评估和重新影响到的服务</strong></p><p><strong>3、准备新的数据库集群复制数据</strong></p><p><strong>4、修改系统配置并发布新版上线</strong></p><p><strong>注意：</strong></p><p><strong>1、先拆分系统，还是先拆分数据库？</strong></p><p><strong>2、先拆分多大范围？</strong></p><h2 id="3-数据库水平拆分"><a href="#3-数据库水平拆分" class="headerlink" title="3. 数据库水平拆分"></a>3. 数据库水平拆分</h2><p><strong>什么是水平拆分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171240.png" alt="image-20210411171240862"></p><p><strong>水平分库分表</strong></p><p><strong>分为，分库、分表、分库分表三类</strong></p><p><strong>有什么区别？</strong></p><p><strong>数据库水平拆分</strong></p><p><strong>水平拆分（按主键分库分表）：水平拆分就是直接对数据进行分片，有分库和分表两个具体方</strong></p><p><strong>式，但是都只是降低单个节点数据量，但不改变数据本身的结构。这样对业务系统本身的代码</strong></p><p><strong>逻辑来说，就不需要做特别大的改动，甚至可以基于一些中间件做到透明。</strong></p><p><strong>比如把一个 10 亿条记录的订单单库单表（orderDB 库 t_order 表）。我们按照用户 id 除以</strong></p><p><strong>32 取模，把单库拆分成 32 个库orderDB_00..31；再按订单 id 除以 32 取模，每个库里再拆</strong></p><p><strong>分成 32 个表t_order_00..31。这样一共是 1024 个子表，单个表的数据量就只是 10 万条了</strong></p><p><strong>。</strong></p><p><strong>一个查询如果能够直接路由到某个具体的字表，比如orderDB05.t_order_10 ，那么查询效率</strong></p><p><strong>就会高很多。</strong></p><p><strong>数据库水平拆分</strong></p><p><strong>水平拆分（按时间分库分表）：很多时候，我们的数据是有时间属性的，所以自然可以按照时</strong></p><p><strong>间维度来拆分。比如当前数据表和历史数据表，甚至按季度，按月，按天来划分不同的表。这</strong></p><p><strong>样我们按照时间维度来查询数据时，就可以直接定位到当前的这个子表。更详细的分析参考下</strong></p><p><strong>一个小节。</strong></p><p><strong>强制按条件指定分库分表：比如配置好某些用户的数据进入单独的库表，其他数据默认处理。</strong></p><p><strong>自定义方式分库分表：指定某些条件的数据进入到某些库或表。</strong></p><p><strong>数据库水平拆分</strong></p><p><strong>思考一个问题：</strong></p><p><strong>为什么有些 DBA 不建议分表，只建议分库？</strong></p><p><strong>（一些中间件，也只支持分库，不能分表）</strong></p><p><strong>分库还是分表，如何选择</strong></p><p><strong>一般情况下，如果数据本身的读写压力较大，磁盘 IO 已经成为瓶颈，那么分库比分表要好。分库将数据分散到不同的数据库实例，使用不同的磁盘，从而可以并行提升整个集群的并行数据处理能力。相反的情况下，可以尽量多考虑分表，降低单表的数据量，从而减少单表操作的时间，同时也能在单个数据库上使用并行操作多个表来增加处理能力。</strong></p><p><strong>数据库水平拆分</strong></p><p><strong>分库分表有什么优缺点：</strong></p><p><strong>1、解决容量问题</strong></p><p><strong>2、比垂直拆分对系统影响小</strong></p><p><strong>3、部分提升性能和稳定性</strong></p><p><strong>1、集群规模大，管理复杂</strong></p><p><strong>2、复杂 SQL 支持问题（业务侵入性、性能）</strong></p><p><strong>3、数据迁移问题</strong></p><p><strong>4、一致性问题</strong></p><p><strong>分库分表演示</strong></p><p><strong>以 ShardingSphere-Proxy 为例。</strong></p><p><strong>按用户分库，按订单分表（为什么这么做）。</strong></p><p><strong>思考一下，分库分表条件写成：</strong></p><p><strong>分库 user_id % 2</strong></p><p><strong>分表 user_id % 2</strong></p><p><strong>会发生什么 ？</strong></p><p><strong>数据的分类管理</strong></p><p><strong>通过分类处理提升数据管理能力</strong></p><p><strong>随着我们对业务系统、对数据本身的进一步了解，我们就会发现，很多数据对质量的要求是不同的。</strong></p><p><strong>比如，订单数据，肯定一致性要求最高，不能丢数据。而日志数据和一些计算的中间数据，我们则是可以不要那么高的一致性，丢了不要了，或者从别的地方找回来。</strong></p><p><strong>同样地，我们对于同样一张表里的订单数据，也可以采用不同策略，无效订单如果比较多，我们可以定期的清除或者转移（一些交易系统里有 80%以上是的机器下单然后取消的无意义订单，没有人会去查询它，所以可以清理）。</strong></p><p><strong>数据的分类管理</strong></p><p><strong>如果没有无效订单，那么我们也可以考虑：</strong></p><p><strong>1. 最近一周下单但是未支付的订单，被查询和支付的可能性较大，再长时间的订单，我们可</strong></p><p><strong>以直接取消掉。</strong></p><p><strong>2. 最近 3 个月下单的数据，被在线重复查询和系统统计的可能性最大。</strong></p><p><strong>3. 超过 3 个月、3 年以内的数据，查询的可能性非常小，我们可以不提供在线查询。</strong></p><p><strong>4. 3 年以上的数据，我们可以直接不提供任何方式的查询。</strong></p><p><strong>数据的分类管理</strong></p><p><strong>这样的话，我们就可以采取一定的手段去优化系统：</strong></p><p><strong>1. 定义一周内下单但未支付的数据为热数据，同时放到数据库和内存；</strong></p><p><strong>2. 定义三个月内的数据为温数据，放到数据库，提供正常的查询操作；</strong></p><p><strong>3. 定义 3 个月到 3 年的数据，为冷数据，从数据库删除，归档到一些便宜的磁盘，用压缩的</strong></p><p><strong>方式（比如 MySQL 的 tokuDB 引擎，可以压缩到几十分之一）存储，用户需要邮件或者提</strong></p><p><strong>交工单来查询，我们导出后发给用户；</strong></p><p><strong>4. 定义 3 年以上的数据为冰数据，备份到磁带之类的介质上，不提供任何查询操作。</strong></p><p><strong>我们可以看到，上面都是针对一些具体场景，来分析和给出解决办法。那么通过在各种不同的</strong></p><p><strong>场景下，都对现有的技术和手段进行一些补充，我们就会逐渐得到一个复杂的技术体系。</strong></p><h2 id="4-框架和中间件"><a href="#4-框架和中间件" class="headerlink" title="4. 框架和中间件"></a>4. 框架和中间件</h2><p><strong>框架和中间件</strong></p><p><strong>Java 框架层面：</strong></p><p><strong>TDDL</strong></p><p><strong>Apache ShardingSphere-JDBC</strong></p><p><strong>中间件层面：</strong></p><p><strong>DRDS（商业闭源）</strong></p><p><strong>Apache ShardingSphere-Proxy</strong></p><p><strong>MyCat/DBLE</strong></p><p><strong>Cobar</strong></p><p><strong>Vitness</strong></p><p><strong>KingShard</strong></p><p><strong>数据库中间件的技术演进</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171259.png" alt="image-20210411171259449"></p><p><strong>摩尔定律失效</strong></p><p><strong>分布式崛起</strong></p><p><strong>数据库中间件的技术演进</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171313.png" alt="image-20210411171313805"></p><p><strong>数据库中间件的技术演进</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171328.png" alt="image-20210411171328227"></p><p><strong>数据库中间件 ShardingSphere</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171349.png" alt="image-20210411171349661"></p><p><strong>Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，</strong></p><p><strong>它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款相互独立，却又能够混合部署配合使用</strong></p><p><strong>的产品组成。 它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于</strong></p><p><strong>如 Java 同构、异构语言、云原生等各种多样化的应用场景。</strong></p><p><strong>数据库中间件 ShardingSphere</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171404.png" alt="image-20210411171404232"></p><p><strong>框架 ShardingSphere-JDBC</strong></p><p><strong>直接在业务代码使用。</strong></p><p><strong>支持常见的数据库和 JDBC。</strong></p><p><strong>Java only。</strong></p><p><strong>数据库中间件 ShardingSphere</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171458.png" alt="image-20210411171458575"></p><p><strong>中间件 ShardingSphere-Proxy</strong></p><p><strong>作为中间件，独立部署，对业务端透明。</strong></p><p><strong>目前支持 MySQL 和 PostgreSQL。</strong></p><p><strong>任何语言平台的系统都可以接入，可以使</strong></p><p><strong>用 mysql 命令或者 IDE 操作。</strong></p><p><strong>对业务系统侵入性小。</strong></p><h2 id="5-如何做数据迁移"><a href="#5-如何做数据迁移" class="headerlink" title="5. 如何做数据迁移"></a>5. 如何做数据迁移</h2><p><strong>数据迁移是重要的一环</strong></p><p>设计新系统容易，但是我们处理的都是老系统和历史诗句</p><p>怎么能更平滑的迁移旧数据到新的数据库和系统</p><p>特别是在异构的数据库结构情况下</p><p>达到数据准确，迁移速度快，减少停机，对业务影响小</p><p>迁移是最容易出故障的一个点</p><p><strong>数据迁移的方式：全量</strong></p><p>全量数据导出和导入</p><p>1、业务系统停机，</p><p>2、数据库迁移，校验一致性，</p><p>3、然后业务系统升级，接入新数据库。</p><p>直接复制的话，可以 dump 后全量导入（如果是）异构数据，需要用程序来处理</p><p>优点：</p><p>缺点：</p><p><strong>数据迁移的方式：全量+增量</strong></p><p>依赖于数据本身的时间戳</p><p>1、先同步数据到最近的某个时间戳</p><p>2、然后在发布升级时停机维护，</p><p>3、再同步最后一段时间（通常是一天）的变化数据。</p><p>4、最后升级业务系统，接入新数据库。</p><p>优点：</p><p>缺点：</p><p><strong>数据迁移的方式：binlog+全量+增量</strong></p><p>通过主库或者从库的 binlog 来解析和重新构造数据，实现复制。</p><p>一般需要中间件等工具的支持。</p><p>可以实现多线程，断点续传，全量历史和增量数据同步。</p><p>继而可以做到：</p><p>1、实现自定义复杂异构数据结构；</p><p>2、实现自动扩容和缩容，比如分库分表到单库单表，单库单表到分库分表，分4个库表到分64个库表。</p><p>优点：</p><p>缺点：</p><p><strong>数据库中间件 ShardingSphere</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171515.png" alt="image-20210411171515224"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411171529.png" alt="image-20210411171529206"></p><p><strong>迁移工具 ShardingSphere-scaling</strong></p><p><strong>支持数据全量和增量同步。</strong></p><p><strong>支持断点续传和多线程数据同步。</strong></p><p><strong>支持数据库异构复制和动态扩容。</strong></p><p><strong>具有 UI 界面，可视化配置。分库分表演示</strong></p><p>以 ShardingSphere-Scaling 为例。</p><p>演示数据异构复制和迁移。</p><p>分库分表的 逻辑数据库（多个库表） -&gt; 单库单表（master） -&gt; 单库单表（slave）7.总结回顾与作业实践</p><p><strong>第 15 节课总结回顾</strong></p><p><strong>为什么要做数据库拆分</strong></p><p><strong>数据库水平/垂直拆分</strong></p><p><strong>相关的框架和中间件</strong></p><p>如何做数据迁移</p><p><strong>第 15 节课作业实践</strong></p><p>1、（选做）分析前面作业设计的表，是否可以做垂直拆分。</p><p>2、（必做）设计对前面的订单表数据进行水平分库分表，拆分2个库，每个库16张表。</p><p>并在新结构在演示常见的增删改查操作。代码、sql 和配置文件，上传到 Github。</p><p>3、（选做）模拟1000万的订单单表数据，迁移到上面作业2的分库分表中。</p><p>4、（选做）重新搭建一套4个库各64个表的分库分表，将作业2中的数据迁移到新分库。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week07-02 超越分库分表-高可用与读写分离</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week07-02%20%E8%B6%85%E8%B6%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week07-02%20%E8%B6%85%E8%B6%8A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 14 课</p><p>超越分库分表-高可用与读写分离</p><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.从单机到集群</p><p>2.MySQL 主从复制*</p><p>3.MySQL 读写分离*</p><p>4.MySQL 高可用*</p><p>5.总结回顾与作业实践</p><h2 id="1-从单机到集群"><a href="#1-从单机到集群" class="headerlink" title="1. 从单机到集群"></a>1. 从单机到集群</h2><p><strong>单机 MySQL 数据库的几个问题</strong></p><p>随着数据量的增大，读写并发的增加，系统可用性要求的提升，单机 MySQL 面临：</p><p>1、容量有限，难以扩容</p><p>2、读写压力，QPS 过大，特别是分析类需求会影响到业务事务</p><p>3、可用性不足，宕机问题</p><p>还有没有其他问题？</p><p><strong>单机 MySQL 的技术演进</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170258.png" alt="image-20210411170258545"></p><p>高可用性 MHA/MGR/Orchestrator</p><p>读写压力</p><p>故障转移</p><p>多机集群 主从复制</p><p>容量问题 数据库拆分 分库分表</p><p>一致性问题 分布式事务 XA/柔性事务</p><h2 id="2-MySQL-主从复制"><a href="#2-MySQL-主从复制" class="headerlink" title="2. MySQL 主从复制"></a>2. MySQL 主从复制</h2><p><strong>主从复制原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170311.png" alt="image-20210411170311808"></p><p>核心是</p><p>1、主库写 binlog</p><p>2、从库 relay log</p><p>2000年，MySQL 3.23.15版本引入了复制</p><p>2002年，MySQL 4.0.2版本分离 IO 和 SQL 线程，引入了 relay log</p><p>2010年，MySQL 5.5版本引入半同步复制</p><p>2016年，MySQL 在5.7.17中引入 InnoDB Group Replication</p><p><strong>主从复制原理</strong></p><p>Binlog 格式</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170329.png" alt="image-20210411170329761"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170406.png" alt="image-20210411170406357"></p><p>ROW</p><p>Statement</p><p>Mixed</p><p><strong>主从复制原理</strong></p><p>异步复制：传统主从复制–2000年，MySQL 3.23.15版本引入了 Replication</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170423.png" alt="image-20210411170423585"></p><p><strong>主从复制原理</strong></p><p>半同步复制：需要启用插件</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170448.png" alt="image-20210411170448505"></p><p><strong>主从复制原理</strong></p><p>组复制：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170504.png" alt="image-20210411170504507"></p><p><strong>主从复制演示</strong></p><p>1、本地启动两个 MySQL</p><p>2、注意配置文件（思考几种安装、启动方式）</p><p>4、演示数据复制操作，创建表和写入、修改数据</p><p>还有没有其他问题？</p><p><strong>主从复制的局限性</strong></p><p>1、主从延迟问题</p><p>2、应用侧需要配合读写分离框架</p><p>3、不解决高可用问题</p><h2 id="3-MySQL-读写分离"><a href="#3-MySQL-读写分离" class="headerlink" title="3. MySQL 读写分离"></a>3. MySQL 读写分离</h2><p><strong>主从复制在业务系统里的应用</strong></p><p>借助于主从复制，我们现在有了多个 MySQL 服务器示例。</p><p>如果借助这个新的集群，改进我们的业务系统数据处理能力？</p><p>== &gt; 配置多个数据源，实现读写分离</p><p><strong>读写分离动态切换数据源版本1.0</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170521.png" alt="image-20210411170521583"></p><p>1、基于 Spring/Spring Boot，配置多个数据源(例如2个，master 和 slave)</p><p>2、根据具体的 Service 方法是否会操作数据，注入不同的数据源,1.0版本</p><p>3、改进一下1.1：基于操作 AbstractRoutingDataSource 和自定义注解 readOnly 之</p><p>类的，简化自动切换数据源</p><p>4、改进二下1.2：支持配置多个从库；</p><p>5、改进三下1.3：支持多个从库的负载均衡。</p><p>今天的作业之一。</p><p><strong>读写分离数据库框架版本2.0</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170538.png" alt="image-20210411170538890"></p><p>1、分析前一版本“动态切换数据源”有什么问题？</p><p>1）侵入性还是较强</p><p>2）降低侵入性会导致”写完读”不一致问题</p><p>2、改进方式，ShardingSphere-jdbc 的 Master-Slave 功能</p><p>1）SQL 解析和事务管理，自动实现读写分离</p><p>2）解决”写完读”不一致的问题</p><p>今天作业之一：使用 ShardingSphere-jdbc 5.0.0-alpha 实现读写分离配置。</p><p><strong>读写分离数据库中间件版本3.0</strong></p><p>1、分析前一版本“框架版本”有什么问题？</p><p>1）对业务系统还是有侵入</p><p>2）对已存在的旧系统改造不友好</p><p>2、改进方式，MyCat/ShardingSphere-Proxy 的 Master-Slave 功能</p><p>1）需要部署一个中间件，规则配置在中间件</p><p>2）模拟一个 MySQL 服务器，对业务系统无侵入</p><p>今天作业之一：使用 ShardingSphere-proxy 5.0.0-alpha 实现读写分离配置。</p><h2 id="4-MySQL-高可用"><a href="#4-MySQL-高可用" class="headerlink" title="4. MySQL 高可用"></a>4. MySQL 高可用</h2><p><strong>为什么要高可用</strong></p><p>1、读写分离，提升读的处理能力</p><p>2、故障转移，提供 failover 能力</p><p>加上业务侧连接池的心跳重试，实现断线重连，业务不间断，降低 RTO 和 RPO。</p><p><strong>高可用定义</strong></p><p>高可用意味着，更少的不可服务时间。一般用SLA/SLO衡量。</p><p>1年 = 365天 = 8760小时</p><p>99 = 8760 * 1% = 8760 * 0.01 = 87.6小时</p><p>99.9 = 8760 * 0.1% = 8760 * 0.001 = 8.76小时</p><p>99.99 = 8760 * 0.0001 = 0.876小时 = 0.876 * 60 = 52.6分钟</p><p>99.999 = 8760 * 0.00001 = 0.0876小时 = 0.0876 * 60 = 5.26分钟</p><p>后面的分布式课程讲稳定性，注意关系和区别。</p><p>你维护的系统有几个9？99.95%算是几个9？</p><p><strong>为什么要高可用</strong></p><p>什么是 failover，故障转移，灾难恢复</p><p>容灾：热备与冷备</p><p>对于主从来说，简单讲就是主挂了，某一个从，变成主，</p><p>整个集群来看，正常对外提供服务</p><p>常见的一些策略：</p><p>1、多个实例不在一个主机/机架上</p><p>2、跨机房和可用区部署</p><p>3、两地三中心容灾高可用方案</p><p><strong>MySQL 高可用0：主从手动切换</strong></p><p>如果主节点挂掉，将某个从改成主；</p><p>重新配置其他从节点。</p><p>修改应用数据源配置。</p><blockquote><blockquote><p>有什么问题？</p></blockquote></blockquote><ol><li>可能数据不一致。</li><li>需要人工干预。</li><li>代码和配置的侵入性。</li></ol><p><strong>MySQL 高可用1：主从手动切换</strong></p><p>用 LVS+Keepalived 实现多个节点的探活+请求路由。</p><p>配置 VIP 或 DNS 实现配置不变更。</p><blockquote><blockquote><p>有什么问题？</p></blockquote></blockquote><ol><li>手工处理主从切换</li><li>大量的配置和脚本定义</li></ol><p><strong>MySQL 高可用2：MHA</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170603.png" alt="image-20210411170603614"></p><p>MHA（Master High Availability）目前在 MySQL 高可用方面是一个相对成熟的解决方</p><p>案，它由日本 DeNA 公司的 youshimaton（现就职于 Facebook 公司）开发，是一套</p><p>优秀的作为 MySQL 高可用性环境下故障切换和主从提升的高可用软件。</p><p>基于 Perl 语言开发，一般能在30s内实现主从切换。</p><p>切换时，直接通过 SSH 复制主节点的日志。</p><blockquote><blockquote><p>有什么问题？</p></blockquote></blockquote><ol><li>需要配置 SSH 信息</li><li>至少3台</li></ol><p>*<em>MySQL 高可用3：MGR **</em></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170633.png" alt="image-20210411170633165"></p><p>如果主节点挂掉，将自动选择某个从改成主；</p><p>无需人工干预，基于组复制，保证数据一致性。</p><blockquote><blockquote><p>有什么问题？</p></blockquote></blockquote><ol><li>外部获得状态变更需要读取数据库。</li><li>外部需要使用 LVS/VIP 配置。</li></ol><p>*<em>MySQL 高可用3：MGR **</em></p><p>MGR 特点</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170709.png" alt="image-20210411170709507"></p><p>*<em>MySQL 高可用3：MGR **</em></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170728.png" alt="image-20210411170728207"></p><p>*<em>MySQL 高可用3：MGR **</em></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170742.png" alt="image-20210411170742013"></p><p>*<em>MySQL 高可用3：MGR **</em></p><p>MGR 演示。</p><p><strong>MySQL 高可用4：MySQL Cluster</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170757.png" alt="image-20210411170757280"></p><p><strong>MySQL 高可用4：MySQL Cluster</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170822.png" alt="image-20210411170822160"></p><p><strong>MySQL 高可用5：Orchestrator</strong></p><p>如果主节点挂掉，将某个从改成主；</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170839.png" alt="image-20210411170839377"></p><p><strong>MySQL 高可用5：Orchestrator</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170901.png" alt="image-20210411170901092"></p><p>基于 Go 语言开发，实现了中间件本身的高可用(?!)</p><p>优势：</p><p>能直接在 UI 界面</p><p>拖拽改变主从关系5.总结回顾与作业实践</p><p><strong>第 14 节课总结回顾</strong></p><p><strong>单机数据库技术演进</strong></p><p><strong>MySQL 主从复制</strong></p><p><strong>MySQL 读写分离</strong></p><p><strong>MySQL 高可用</strong></p><p><strong>第14节课作业实践</strong></p><p>1、（选做）配置一遍异步复制，半同步复制、组复制。</p><p>2、（必做）读写分离-动态切换数据源版本1.0</p><p>3、（必做）读写分离-数据库框架版本2.0</p><p>4、（选做）读写分离-数据库中间件版本3.0</p><p>5、（选做）配置 MHA，模拟 master 宕机</p><p>6、（选做）配置 MGR，模拟 master 宕机</p><p>7、（选做）配置 Orchestrator，模拟 master 宕机，演练 UI 调整拓扑结构</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week07-01 性能与 SQL 优化（2）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week07-01%20%E6%80%A7%E8%83%BD%E4%B8%8E%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%882%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week07-01%20%E6%80%A7%E8%83%BD%E4%B8%8E%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 13 课</p><p>性能与 SQL 优化（2）</p><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.MySQL 事务与锁*</p><p>2.DB 与 SQL 优化*</p><p>3.常见场景分析*</p><p>4.总结回顾与作业实践</p><h2 id="1-MySQL-事务与锁"><a href="#1-MySQL-事务与锁" class="headerlink" title="1. MySQL 事务与锁"></a>1. MySQL 事务与锁</h2><p><strong>MySQL 事务</strong></p><p><strong>性能 vs. 可靠性</strong></p><p>事务可靠性模型 ACID:</p><p>Atomicity: 原子性, 一次事务中的操作要么全部成功, 要么全部失败。</p><p>Consistency: 一致性, 跨表、跨行、跨事务, 数据库始终保持一致状态。</p><p>Isolation: 隔离性, 可见性, 保护事务不会互相干扰, 包含4种隔离级别。</p><p>Durability:, 持久性, 事务提交成功后,不会丢数据。如电源故障, 系统崩溃。</p><p>InnoDB:双写缓冲区、故障恢复、操作系统、fsync() 、磁盘存储、缓存、UPS、网络、备份策略 ……</p><p><strong>MySQL 事务</strong></p><p><strong>表级锁</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165124.png" alt="image-20210411165124246"></p><p><strong>意向锁: 表明事务稍后要进行哪种类型的锁定</strong></p><p><strong>共享意向锁(IS): 打算在某些行上设置共享锁</strong></p><p><strong>排他意向锁(IX): 打算对某些行设置排他锁</strong></p><p><strong>Insert 意向锁: Insert 操作设置的间隙锁</strong></p><p><strong>其他</strong></p><p><strong>自增锁(AUTO-IN)</strong></p><p><strong>LOCK TABLES/DDL</strong></p><p>锁类型的兼容性</p><p>X IX S IS</p><p>X 冲突 冲突 冲突 冲突</p><p>IX 冲突 兼容 冲突 兼容</p><p>S 冲突 冲突 兼容 兼容</p><p>IS 冲突 兼容 兼容 兼容</p><p><strong>SHOW ENGINE INNODB STATUS;</strong></p><p><strong>上锁前需要先上意向锁!</strong></p><p>共享锁(S)</p><p>排他锁(X)</p><p><strong>MySQL 事务</strong></p><p><strong>行级锁(InnoDB)</strong></p><p>记录锁(Record): 始终锁定索引记录，注意隐藏的聚簇索引;</p><p>间隙锁(Gap):</p><p>临键锁(Next-Key): 记录锁+间隙锁的组合; 可“锁定”表中不存在记录</p><p>谓词锁(Predicat): 空间索引</p><p><strong>死锁:</strong></p><p>阻塞与互相等待</p><p>增删改、锁定读</p><p>死锁检测与自动回滚</p><p>锁粒度与程序设计</p><p><strong>MySQL 事务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165138.png" alt="image-20210411165138170"></p><p><strong>《SQL:1992标准》规定了四种事务隔离级别(Isolation):</strong></p><p><strong>读未提交: READ UNCOMMITTED</strong></p><p><strong>读已提交: READ COMMITTED</strong></p><p><strong>可重复读: REPEATABLE READ</strong></p><p><strong>可串行化: SERIALIZABLE</strong></p><p><strong>事务隔离是数据库的基础特征。</strong></p><p><strong>MySQL:</strong></p><p><strong>可以设置全局的默认隔离级别</strong></p><p><strong>可以单独设置会话的隔离级别</strong></p><p><strong>InnoDB 实现与标准之间的差异</strong></p><p><strong>隔离级别</strong></p><p><strong>并发性</strong></p><p><strong>可靠性</strong></p><p><strong>一致性</strong></p><p><strong>可重复性</strong></p><p><strong>MySQL 事务</strong></p><p><strong>读未提交: READ UNCOMMITTED</strong></p><p><strong>很少使用</strong></p><p><strong>不能保证一致性</strong></p><p><strong>脏读(dirty read) : 使用到从未被确认的数据(例如: 早期版本、回滚)</strong></p><p><strong>锁:</strong></p><p><strong>以非锁定方式执行</strong></p><p><strong>可能的问题: 脏读、幻读、不可重复读</strong></p><p><strong>MySQL 事务</strong></p><p><strong>读已提交: READ COMMITTED</strong></p><p><strong>每次查询都会设置和读取自己的新快照。</strong></p><p><strong>仅支持基于行的 bin-log</strong></p><p><strong>UPDATE 优化: 半一致读(semi-consistent read)</strong></p><p><strong>不可重复读: 不加锁的情况下, 其他事务 UPDATE 或 DELETE 会对查询结果有影响</strong></p><p><strong>幻读(Phantom): 加锁后, 不锁定间隙, 其他事务可以 INSERT。</strong></p><p><strong>锁:</strong></p><p><strong>锁定索引记录, 而不锁定记录之间的间隙</strong></p><p><strong>可能的问题: 幻读、不可重复读</strong></p><p><strong>MySQL 事务</strong></p><p><strong>可重复读: REPEATABLE READ</strong></p><p><strong>InnoDB 的默认隔离级别</strong></p><p><strong>使用事务第一次读取时创建的快照</strong></p><p><strong>多版本技术</strong></p><p><strong>锁:</strong></p><p><strong>使用唯一索引的唯一查询条件时, 只锁定查找到的索引记录, 不锁定间隙。</strong></p><p><strong>其他查询条件, 会锁定扫描到的索引范围, 通过间隙锁或临键锁来阻止其他会话在这个范围中插入值。</strong></p><p><strong>可能的问题: InnoDB 不能保证没有幻读, 需要加锁</strong></p><p><strong>MySQL 事务</strong></p><p><strong>串行化: SERIALIZABLE</strong></p><p><strong>最严格的级别，事务串行执行，资源消耗最大；</strong></p><p><strong>问题回顾:</strong></p><p><strong>脏读(dirty read) : 使用到从未被确认的数据(例如: 早期版本、回滚)</strong></p><p><strong>不可重复读: 不加锁的情况下, 其他事务 update 或 delete 会对结果集有影响</strong></p><p><strong>幻读(Phantom): 加锁之后, 相同的查询语句, 在不同的时间点执行时, 产生不同的结果集</strong></p><p><strong>怎么解决?</strong></p><p><strong>提高隔离级别、使用间隙锁或临键锁</strong></p><p><strong>MySQL 事务</strong></p><p><strong>undo log: 撤消日志</strong></p><p><strong>保证事务的原子性</strong></p><p><strong>用处: 事务回滚, 一致性读、崩溃恢复。</strong></p><p><strong>记录事务回滚时所需的撤消操作</strong></p><p><strong>一条 INSERT 语句，对应一条 DELETE 的 undo log</strong></p><p><strong>每个 UPDATE 语句，对应一条相反 UPDATE 的 undo log</strong></p><p><strong>保存位置:</strong></p><p><strong>system tablespace (MySQL 5.7默认)</strong></p><p><strong>undo tablespaces (MySQL 8.0默认)</strong></p><p><strong>回滚段(rollback segment)</strong></p><p><strong>MySQL 事务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165156.png" alt="image-20210411165156182"></p><p><strong>redo log: 重做日志</strong></p><p><strong>确保事务的持久性，防止事务提交后数据未刷新到磁盘就掉电或崩溃。</strong></p><p><strong>事务执行过程中写入 redo log,记录事务对数据页做了哪些修改。</strong></p><p><strong>提升性能: WAL(Write-Ahead Logging) 技术, 先写日志, 再写磁盘。</strong></p><p><strong>日志文件: ib_logfile0, ib_logfile1</strong></p><p><strong>日志缓冲: innodb_log_buffer_size</strong></p><p><strong>强刷: fsync()</strong></p><p><strong>MySQL 事务</strong></p><p><strong>MVCC: 多版本并发控制</strong></p><p><strong>使 InnoDB 支持一致性读: READ COMMITTED 和 REPEATABLE READ 。</strong></p><p><strong>让查询不被阻塞、无需等待被其他事务持有的锁，这种技术手段可以增加并发性能。</strong></p><p><strong>InnoDB 保留被修改行的旧版本。</strong></p><p><strong>查询正在被其他事务更新的数据时，会读取更新之前的版本。</strong></p><p><strong>每行数据都存在一个版本号, 每次更新时都更新该版本</strong></p><p><strong>这种技术在数据库领域的使用并不普遍。 某些数据库, 以及某些 MySQL 存储引擎都不支持。</strong></p><p><strong>聚簇索引的更新 = 替换更新</strong></p><p><strong>二级索引的更新 = 删除+新建</strong></p><p><strong>MySQL 事务</strong></p><p><strong>MVCC 实现机制</strong></p><p><strong>隐藏列</strong></p><p><strong>事务链表， 保存还未提交的事务，事务提交则会从链表中摘除</strong></p><p><strong>Read view: 每个 SQL 一个, 包括 rw_trx_ids, low_limit_id, up_limit_id, low_limit_no 等</strong></p><p><strong>回滚段: 通过 undo log 动态构建旧版本数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165211.png" alt="image-20210411165211505"></p><p>隐藏列: DB_TRX_ID DB_ROLL_PTR DB_ROW_ID</p><p>长度: 6-byte 7-byte 6-byte</p><p>说明:</p><p>指示最后插</p><p>入或更新该</p><p>行的事务 ID</p><p>回滚指针。指向</p><p>回滚段中写入的</p><p>undo log 记录</p><p>聚簇 row ID/聚簇索引</p><p><strong>MySQL 事务</strong></p><p>演示事务与锁</p><h2 id="2-DB-与-SQL-优化"><a href="#2-DB-与-SQL-优化" class="headerlink" title="2.DB 与 SQL 优化"></a>2.DB 与 SQL 优化</h2><p><strong>从一个简单例子讲起从</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165245.png" alt="image-20210411165245138"></p><p><strong>一个简单例子讲起</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165300.png" alt="image-20210411165300449"></p><p><strong>说说 SQL 优化</strong></p><p>如何发现需要优化的 SQL?</p><p>你了解的 SQL 优化方法有哪些?</p><p>SQL 优化有哪些好处?</p><p><strong>模拟一个需求：版本1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165325.png" alt="image-20210411165325269"></p><p><strong>模拟一个需求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165342.png" alt="image-20210411165341946"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165401.png" alt="image-20210411165401071"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165416.png" alt="image-20210411165416201"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165437.png" alt="image-20210411165437896"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165452.png" alt="image-20210411165452678"></p><p><strong>继续深入。。。需求升级到版本2</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165512.png" alt="image-20210411165512188"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165533.png" alt="image-20210411165533217"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165548.png" alt="image-20210411165548378"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165603.png" alt="image-20210411165603304"></p><p><strong>继续深入。。。版本3</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165621.png" alt="image-20210411165620977"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165635.png" alt="image-20210411165635059"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165654.png" alt="image-20210411165654628"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165717.png" alt="image-20210411165717922"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165734.png" alt="image-20210411165733939"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165750.png" alt="image-20210411165750901"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165804.png" alt="image-20210411165804585"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165819.png" alt="image-20210411165819383"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165837.png" alt="image-20210411165837423"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165852.png" alt="image-20210411165851989"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165907.png" alt="image-20210411165906992"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165923.png" alt="image-20210411165922937"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165937.png" alt="image-20210411165937766"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411165954.png" alt="image-20210411165954641"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170012.png" alt="image-20210411170012462"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170028.png" alt="image-20210411170028453"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170043.png" alt="image-20210411170043593"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170103.png" alt="image-20210411170103673"></p><p><strong>继续深入。。。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411170118.png" alt="image-20210411170118389"></p><p><strong>总结1：写入优化</strong></p><p><strong>大批量写入的优化</strong></p><p><strong>PreparedStatement 减少 SQL 解析</strong></p><p><strong>Multiple Values/Add Batch 减少交互</strong></p><p><strong>Load Data，直接导入</strong></p><p><strong>索引和约束问题</strong></p><p><strong>总结2：数据更新</strong></p><p><strong>数据的范围更新</strong></p><p><strong>注意 GAP Lock 的问题</strong></p><p><strong>导致锁范围扩大</strong></p><p><strong>总结3：模糊查询</strong></p><p><strong>Like 的问题</strong></p><p><strong>前缀匹配</strong></p><p><strong>否则不走索引</strong></p><p><strong>全文检索，</strong></p><p><strong>solr/ES</strong></p><p><strong>总结4：连接查询</strong></p><p><strong>连接查询优化</strong></p><p><strong>驱动表的选择问题</strong></p><p><strong>避免笛卡尔积</strong></p><p><strong>总结5：索引失效</strong></p><p><strong>索引失效的情况汇总</strong></p><p><strong>NULL，not，not in，函数等</strong></p><p><strong>减少使用 or，可以用 union（注意 union all 的区别），以及前面提到的like</strong></p><p><strong>大数据量下，放弃所有条件组合都走索引的幻想，出门左拐“全文检索”</strong></p><p><strong>必要时可以使用 force index 来强制查询走某个索引</strong></p><p><strong>总结6：查询 SQL 到底怎么设计？</strong></p><p><strong>查询数据量和查询次数的平衡</strong></p><p><strong>避免不必须的大量重复数据传输</strong></p><p><strong>避免使用临时文件排序或临时表</strong></p><p><strong>分析类需求，可以用汇总表</strong></p><h2 id="3-常见场景分析"><a href="#3-常见场景分析" class="headerlink" title="3.常见场景分析"></a>3.常见场景分析</h2><p><strong>怎么实现主键 ID</strong></p><p>自增</p><p>sequence</p><p>模拟 seq</p><p>UUID</p><p>时间戳/随机数</p><p>snowflake</p><p>还有没有其他办法？</p><p><strong>高效分页</strong></p><p>分页：count/pageSize/pageNum, 带条件的查询语句</p><p>常见实现-分页插件：使用查询 SQL，嵌套一个 count，性能的坑？</p><p>改进一下1，重写 count</p><p>大数量级分页的问题，limit 100000,20</p><p>改进一下2，反序</p><p>继续改进3，技术向：带 id，</p><p>继续改进4，需求向：非精确分页</p><p>所有条件组合？ 索引？</p><p>还能不能继续改进？</p><p><strong>乐观锁与悲观锁</strong></p><p>select * from xxx for update</p><p>update xxx</p><p>commit；</p><p>意味着什么？</p><p>select * from xxx</p><p>update xxx where value=oldValue</p><p>为什么叫乐观锁</p><p>有什么区别？</p><h2 id="4-总结回顾与作业实践"><a href="#4-总结回顾与作业实践" class="headerlink" title="4.总结回顾与作业实践"></a>4.总结回顾与作业实践</h2><p><strong>第 9 节课总结回顾</strong></p><p><strong>MySQL 事务与锁</strong></p><p><strong>DB 与 SQL 优化</strong></p><p><strong>常见场景分析</strong></p><p><strong>第13节课作业实践</strong></p><p>1、（选做）用今天课上学习的知识，分析自己系统的 SQL 和表结构</p><p>2、（必做）按自己设计的表结构，插入100万订单模拟数据，测试不同方式的插入效率。</p><p>3、（选做）按自己设计的表结构，插入1000万订单模拟数据，测试不同方式的插入效率。</p><p>4、（选做）使用不同的索引或组合，测试不同方式查询效率。</p><p>5、（选做）调整测试数据，使得数据尽量均匀，模拟1年时间内的交易，计算一年的销售报</p><p>表：销售总额，订单数，客单价，每月销售量，前十的商品等等（可以自己设计更多指标）。</p><p>6、（选做）尝试自己做一个 ID 生成器（可以模拟 Seq 或 Snowflake）。</p><p>7、（选做）尝试实现或改造一个非精确分页的程序。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week05-02 Java相关框架（2）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week05-02%20Java%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%882%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week05-02%20Java%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 10 课</p><h1 id="Java相关框架（2）"><a href="#Java相关框架（2）" class="headerlink" title="Java相关框架（2）"></a>Java相关框架（2）</h1><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.从 Spring 到 Spring Boot</p><p>2.Spring Boot 核心原理*</p><p>3.Spring Boot Starter 详解*</p><p>4.JDBC 与数据库连接池*</p><p>5.ORM-Hibernate/MyBatis*</p><p>6.Spring 集成 ORM/JPA*</p><p>7.Spring Boot 集成 ORM/JPA</p><p>8.第 10 课总结回顾与作业实践</p><h2 id="1-从-Spring-到-Spring-Boot"><a href="#1-从-Spring-到-Spring-Boot" class="headerlink" title="1. 从 Spring 到 Spring Boot"></a>1. 从 Spring 到 Spring Boot</h2><p><strong>Spring 变得越来越复杂</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155958.png" alt="image-20210411155958227"></p><p>配置的发展方向：</p><p>XML–全局</p><p>注解–类</p><p>配置类–方法</p><p>Spring 4 以上的新特性，走向 Spring Boot</p><p>功能，使用方式太复杂，怎么办？</p><p><strong>Spring Boot 的出发点</strong></p><p>Spring 臃肿以后的必然选择。</p><p>一切都是为了简化。</p><p>让开发变简单：</p><p>让配置变简单：</p><p>让运行变简单：</p><p>怎么变简单？关键词：整合</p><p>就像是 SSH、SSM，国产的 SpringSide</p><p>基于什么变简单：约定大于配置。</p><p>限定性框架和非限定性框架？</p><p><strong>Spring Boot 如何做到简化</strong></p><p>为什么能做到简化：</p><p>1、Spring 本身技术的成熟与完善，各方面第三方组件的成熟集成</p><p>2、Spring 团队在去 web 容器化等方面的努力</p><p>3、基于 MAVEN 与 POM 的 Java 生态体系，整合 POM 模板成为可能</p><p>4、避免大量 maven 导入和各种版本冲突</p><p>Spring Boot 是 Spring 的一套快速配置脚手架，关注于自动配置，配置驱动。</p><p>什么是脚手架？</p><p><strong>什么是 Spring Boot</strong></p><p>Spring Boot 使创建独立运行、生产级别的 Spring 应用变得容易，你可以直接运行它。</p><p>我们对 Spring 平台和第三方库采用限定性视角，以此让大家能在最小的成本下上手。</p><p>大部分 Spring Boot 应用仅仅需要最少量的配置。</p><p>功能特性</p><ol><li>创建独立运行的 Spring 应用</li><li>直接嵌入 Tomcat 或 Jetty，Undertow，无需部署 WAR 包</li><li>提供限定性的 starter 依赖简化配置（就是脚手架）</li><li>在必要时自动化配置 Spring 和其他三方依赖库</li><li>提供生产 production-ready 特性，例如指标度量，健康检查，外部配置等</li><li>完全零代码生产和不需要 XML 配置</li></ol><p><strong>快速构建基础 maven 项目</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160014.png" alt="image-20210411160014167"></p><p><a href="https://start.spring.io/">https://start.spring.io/</a></p><h2 id="2-Spring-Boot-核心原理"><a href="#2-Spring-Boot-核心原理" class="headerlink" title="2.Spring Boot 核心原理*"></a>2.Spring Boot 核心原理*</h2><p><strong>Spring Boot 两大核心原理</strong></p><p>1、自动化配置：简化配置核心</p><p>基于 Configuration，EnableXX，Condition</p><p>2、spring-boot-starter：脚手架核心</p><p>整合各种第三方类库，协同工具</p><p><strong>Spring Boot 两大核心原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160041.png" alt="image-20210411160041922"></p><p>application.yaml Configuration Bean</p><p>前缀 一组配置 Starter 组件</p><p><strong>为什么要约定大于配置</strong></p><p>为什么要约定大于配置？</p><p>举例来说，JVM 有1000多个参数，但是我们不需要一个参数，就能 java Hello。</p><p>优势在于，开箱即用：</p><p>一、Maven 的目录结构：默认有 resources 文件夹存放配置文件。默认打包方式为 jar。</p><p>二、默认的配置文件：application.properties 或 application.yml 文件</p><p>三、默认通过 spring.profiles.active 属性来决定运行环境时的配置文件。</p><p>四、EnableAutoConfiguration 默认对于依赖的 starter 进行自动装载。</p><p>五、spring-boot-start-web 中默认包含 spring-mvc 相关依赖以及内置的 web容器，使得</p><p>构建一个 web 应用更加简单。</p><p>什么是脚手架？</p><p><strong>自动化配置原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160059.png" alt="image-20210411160059038"></p><p>自动化配置</p><p>什么是脚手架？</p><p><strong>Spring Boot 自动配置注解</strong></p><p>@SpringBootApplication</p><p>SpringBoot 应用标注在某个类上说明这个类是 SpringBoot 的主配置类，SpringBoot 就会运行</p><p>这个类的 main 方法来启动 SpringBoot 项目。</p><p>@SpringBootConfiguration</p><p>@EnableAutoConfiguration</p><p>@AutoConfigurationPackage</p><p>@Import({AutoConfigurationImportSelector.class})</p><p>加载所有 META-INF/spring.factories 中存在的配置类（类似 SpringMVC 中加载所有 converter）</p><p>核心启动入口</p><p><strong>条件化自动配置</strong></p><p>@ConditionalOnBean</p><p>@ConditionalOnClass</p><p>@ConditionalOnMissingBean</p><p>@ConditionalOnProperty</p><p>@ConditionalOnResource</p><p>@ConditionalOnSingleCandidate</p><p>@ConditionalOnWebApplication</p><p>运行时灵活组装，避免冲突</p><h2 id="3-Spring-Boot-Starter-详解"><a href="#3-Spring-Boot-Starter-详解" class="headerlink" title="3.Spring Boot Starter 详解*"></a>3.Spring Boot Starter 详解*</h2><p><strong>以一个实际项目讲解 Starter</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160114.png" alt="image-20210411160114028"></p><p>1、spring.provides</p><p>2、spring.factories</p><p>3、additional–metadata</p><p>4、自定义 Configuration 类</p><p><strong>以一个实际项目讲解 Starter</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160129.png" alt="image-20210411160129462"></p><h2 id="4-JDBC-与数据库连接池"><a href="#4-JDBC-与数据库连接池" class="headerlink" title="4.JDBC 与数据库连接池"></a>4.JDBC 与数据库连接池</h2><p><strong>JDBC</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160157.png" alt="image-20210411160157839"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160209.png" alt="image-20210411160209704"></p><p>JDBC 定义了数据库交互接口：</p><p>DriverManager</p><p>Connection</p><p>Statement</p><p>ResultSet</p><p>后来又加了DataSource–Pool</p><p><strong>JDBC 是 Java 里操作数据库的核心</strong></p><p>Java 操作数据库的各种类库，都可以看做是在 JDBC 上做的增强实现</p><p>为什么可以这么做？</p><p>加上 XA 事务–XAConnection</p><p>从连接池获取–PooledConnection</p><p>MySQL 驱动 JDBC 接口–Connection</p><p><strong>数据库连接池</strong></p><p>C3P0</p><p>DBCP–Apache CommonPool</p><p>Druid</p><p>Hikari</p><p>连接池需要哪些功能，如何实现？</p><h2 id="5-ORM-Hibernate-MyBatis"><a href="#5-ORM-Hibernate-MyBatis" class="headerlink" title="5.ORM-Hibernate/MyBatis"></a>5.ORM-Hibernate/MyBatis</h2><p><strong>Hibernate</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160224.png" alt="image-20210411160224173"></p><p>ORM（Object-Relational Mapping） 表示对象关</p><p>系映射。</p><p>Hibernate 是一个开源的对象关系映射框架，它对</p><p>JDBC 进行了非常轻量级的对象封装，它将 POJO 与</p><p>数据库表建立映射关系，是一个全自动的 orm 框架</p><p>，hibernate 可以自动生成 SQL 语句，自动执行，</p><p>使得 Java 程序员可以使用面向对象的思维来操纵数</p><p>据库。</p><p>Hibernate 里需要定义实体类和 hbm 映射关系文件</p><p>（IDE 一般有工具生成）。</p><p>Hibernate 里可以使用 HQL、Criteria、Native SQL</p><p>三种方式操作数据库。</p><p>也可以作为 JPA 适配实现，使用 JPA 接口操作。</p><p><strong>MyBatis</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160247.png" alt="image-20210411160247221"></p><p>MyBatis 是一款优秀的持久层框架，</p><p>它支持定制化 SQL、存储过程以及高</p><p>级映射。MyBatis 避免了几乎所有的</p><p>JDBC 代码和手动设置参数以及获取结</p><p>果集。MyBatis 可以使用简单的 XML</p><p>或注解来配置和映射原生信息，将接</p><p>口和 Java 的 POJOs(Plain Old Java</p><p>Objects,普通的 Java 对象)映射成数</p><p>据库中的记录。</p><p><strong>MyBatis-半自动化 ORM</strong></p><p>1、需要使用映射文件 mapper.xml 定义 map规则和 SQL</p><p>2、需要定义 mapper/DAO，基于 xml 规则，操作数据库</p><p>可以使用工具生成基础的 mapper.xml 和 mapper/DAO</p><p>一个经验就是，继承生成的 mapper，而不是覆盖掉</p><p>也可以直接在 mapper 上用注解方式配置 SQL</p><p><strong>MyBatis 与 Hibernate 比较</strong></p><p>MyBatis 与 Hibernate 的区别与联系？</p><p>Mybatis 优点：原生 SQL（XML 语法），直观，对 DBA 友好</p><p>Hibernate 优点：简单场景不用写 SQL（HQL、Cretiria、SQL）</p><p>Mybatis 缺点：繁琐，可以用 MyBatis-generator、MyBatis-Plus 之类的插件</p><p>Hibernate 缺点：对 DBA 不友好</p><p><strong>考虑为什么大公司都用 MyBatis</strong>？</p><h2 id="6-Spring-集成-ORM-与-JPA"><a href="#6-Spring-集成-ORM-与-JPA" class="headerlink" title="6.Spring 集成 ORM 与 JPA*"></a>6.Spring 集成 ORM 与 JPA*</h2><p><strong>JPA</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160301.png" alt="image-20210411160301704"></p><p>JPA 的全称是 Java Persistence API，</p><p>即 Java 持久化 API，是一套基于 ORM 的规范，</p><p>内部是由一系列的接口和抽象类构成。</p><p>JPA 通过 JDK 5.0 注解描述对象-关系表映射关系</p><p>，并将运行期的实体对象持久化到数据库中。</p><p>核心 EntityManager</p><p><strong>Spring JDBC 与 ORM</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160313.png" alt="image-20210411160313714"></p><p>JDBC Spring JDBC</p><p>JPA</p><p>DataSource</p><p>EntityManager Spring ORM</p><p>Spring Data with NoSQL ?</p><p><strong>Spring 管理事务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160325.png" alt="image-20210411160325624"></p><p>JDBC 层，数据库访问层，怎么操作事务？编程式事务管理</p><p>Spring 怎么做到无侵入实现事务？声明式事务管理：事务管理器+AOP</p><p><strong>Spring 管理事务</strong></p><p>Spring 声明式事务配置参考</p><p>事务的传播性：</p><p>@Transactional(propagation=Propagation.REQUIRED)</p><p>事务的隔离级别：</p><p>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</p><p>读取未提交数据(会出现脏读, 不可重复读) 基本不使用</p><p>只读：</p><p>@Transactional(readOnly=true)</p><p>该属性用于设置当前事务是否为只读事务，设置为 true 表示只读，false 则表示可读写，默认值为 false。</p><p>事务的超时性：</p><p>@Transactional(timeout=30)</p><p>回滚：</p><p>指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)</p><p>指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})</p><p><strong>Spring 集成 MyBatis</strong></p><p>演示操作 Spring 与 Mybatis ：</p><p>Mybatis 用法展示</p><p>User 表</p><p>XML/Mapper</p><p><strong>Spring 集成 Hibernate/JPA</strong></p><p>演示操作 Spring 与 Hibernate/JPA：</p><p>Hibernate/JPA 用法展示</p><p>User 实体类</p><p>注解</p><h2 id="7-Spring-Boot-集成-ORM-与-JPA"><a href="#7-Spring-Boot-集成-ORM-与-JPA" class="headerlink" title="7.Spring Boot 集成 ORM 与 JPA*"></a>7.Spring Boot 集成 ORM 与 JPA*</h2><p><strong>Spring Boot 集成J PA/Hibernate</strong></p><p>演示操作 Spring Boot 与 MyBatis：</p><p>准备环境与配置依赖</p><p>Configuration 与配置文件</p><p>Pojo、Mapper 与服务类</p><p>启动类</p><p>访问测试</p><p><strong>Spring Boot 集成 MyBatis</strong></p><p>演示操作 Spring Boot 与 MyBatis：</p><p>准备环境与配置依赖</p><p>Configuration 与配置文件</p><p>Pojo、Mapper 与服务类</p><p>启动类</p><p>访问测试</p><p><strong>Spring/Spring Boot 使用 ORM 的经验</strong></p><p>1、本地事务（事务的设计与坑）</p><p>2、多数据源（配置、静态制定、动态切换）</p><p>3、线程池配置（大小、重连）</p><p>4、ORM 内的复杂 SQL，级联查询</p><p>5、ORM 辅助工具和插件</p><h2 id="8-总结回顾与作业实践"><a href="#8-总结回顾与作业实践" class="headerlink" title="8.总结回顾与作业实践"></a>8.总结回顾与作业实践</h2><p><strong>第 10 节课总结回顾</strong></p><p><strong>Spring Boot</strong></p><p><strong>Hibernate</strong></p><p><strong>MyBatis</strong></p><p><strong>Spring+ORM</strong></p><p><strong>第10节课作业实践</strong></p><ol><li>（选做）总结一下，单例的各种写法，比较它们的优劣。</li><li>（选做）maven/spring 的 profile 机制，都有什么用法？</li><li>（必做）给前面课程提供的 Student/Klass/School 实现自动配置和 Starter。</li><li>（选做）总结 Hibernate 与 MyBatis 的各方面异同点。</li><li>（选做）学习 MyBatis-generator 的用法和原理，学会自定义 TypeHandler 处理复杂类型。</li><li>（必做）研究一下 JDBC 接口和数据库连接池，掌握它们的设计和用法：</li></ol><p>1）使用 JDBC 原生接口，实现数据库的增删改查操作。</p><p>2）使用事务，PrepareStatement 方式，批处理方式，改进上述操作。</p><p>3）配置 Hikari 连接池，改进上述操作。提交代码到 Github。</p><p>附加题（可以后面上完数据库的课再考虑做）：</p><ol><li>(挑战)基于 AOP 和自定义注解，实现 @MyCache(60) 对于指定方法返回值缓存60秒。</li><li>(挑战)自定义实现一个数据库连接池，并整合 Hibernate/Mybatis/Spring/SpringBoot。</li><li>(挑战)基于 MyBatis 实现一个简单的分库分表+读写分离+分布式 ID 生成方案。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week06-02 性能与SQL优化（1）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week06-02%20%E6%80%A7%E8%83%BD%E4%B8%8ESQL%E4%BC%98%E5%8C%96%EF%BC%881%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week06-02%20%E6%80%A7%E8%83%BD%E4%B8%8ESQL%E4%BC%98%E5%8C%96%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 12 课</p><h1 id="性能与SQL优化（1）"><a href="#性能与SQL优化（1）" class="headerlink" title="性能与SQL优化（1）"></a>性能与SQL优化（1）</h1><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.再聊聊性能优化</p><p>2.关系数据库 MySQL</p><p>3.深入数据库原理</p><p>4.MySQL 配置优化*</p><p>5.数据库设计优化*</p><p>6.第12课总结回顾与作业实践</p><h2 id="1-再聊聊性能优化"><a href="#1-再聊聊性能优化" class="headerlink" title="1. 再聊聊性能优化"></a>1. 再聊聊性能优化</h2><p><strong>复习一下什么是性能</strong></p><p>吞吐与延迟 ： 有些结论是反直觉的，指导我们关注什么</p><p>没有量化就没有改进：监控与度量指标，指导我们怎么去入手</p><p>80/20原则：先优化性能瓶颈问题，指导我们如何去优化</p><p>过早的优化是万恶之源：指导我们要选择优化的时机</p><p>脱离场景谈性能都是耍流氓：指导我们对性能要求要符合实际</p><p>性能是一个综合性问题</p><p><strong>DB/SQL 优化是业务系统性能优化的核心</strong></p><p>业务系统的分类：计算密集型、数据密集型</p><p>业务处理本身无状态，数据状态最终要保存到数据库</p><p>一般来说，DB/SQL 操作的消耗在一次处理中占比最大</p><p>业务系统发展的不同阶段和时期，性能瓶颈要点不同，类似木桶装水</p><p>例如传统软件改成 SaaS 软件</p><h2 id="2-关系数据库-MySQL"><a href="#2-关系数据库-MySQL" class="headerlink" title="2. 关系数据库 MySQL*"></a>2. 关系数据库 MySQL*</h2><p><strong>什么是关系数据库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160826.png" alt="image-20210411160825933"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160843.png" alt="image-20210411160843886"></p><p>1970年 Codd 提出关系模型，以关系代数理论为数学基础</p><p>《A Relational Model of Data for Large Shared Data Banks》</p><p><strong>什么是关系数据库？</strong></p><p>E-R 图</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160859.png" alt="image-20210411160859436"></p><p><strong>什么是关系数据库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160917.png" alt="image-20210411160916994"></p><p>数据库设计范式</p><p>第一范式（1NF）：关系 R 属于第一范式，当且仅当R中的每一个属性A的值域只包含原子项</p><p>第二范式（2NF）：在满足 1NF 的基础上，消除非主属性对码的部分函数依赖</p><p>第三范式（3NF）：在满足 2NF 的基础上，消除非主属性对码的传递函数依赖</p><p>BC 范式（BCNF）：在满足 3NF 的基础上，消除主属性对码的部分和传递函数依赖</p><p>第四范式（4NF）：消除非平凡的多值依赖</p><p>第五范式（5NF）：消除一些不合适的连接依赖</p><p><strong>什么是关系数据库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160933.png" alt="image-20210411160933062"></p><p>数据库设计范式</p><p>1NF：消除重复数据，即每一列都是不可再分的基本数据项；</p><p>每个列都是原子的。</p><p><strong>什么是关系数据库</strong></p><p>数据库设计范式</p><p>2NF：消除部分依赖，表中没有列只与主键的部分相关，即每一行都被主键唯一标识；</p><p>每个列都有主键。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160946.png" alt="image-20210411160946515"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160958.png" alt="image-20210411160958618"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161013.png" alt="image-20210411161013745"></p><p><strong>什么是关系数据库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161032.png" alt="image-20210411161032566"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161044.png" alt="image-20210411161044810"></p><p>数据库设计范式</p><p>3NF：消除传递依赖，消除表中列不依赖主键，而是依赖表中的非主键列的情况，即没</p><p>有列是与主键不相关的。</p><p>从表只引用主表的主键，</p><p>即表中每列都和主键相关。</p><p><strong>什么是关系数据库</strong></p><p>数据库设计范式</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161057.png" alt="image-20210411161057863"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161110.png" alt="image-20210411161110388"></p><p>BCNF：Boyce-Codd Normal Form（巴斯-科德范式）</p><p>3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p><p><strong>仓库（仓库名，管理员）</strong></p><p><strong>库存（仓库名，物品名，数量）</strong></p><p><strong>常见关系数据库</strong></p><p>常见关系数据库</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161125.png" alt="image-20210411161125390"></p><p>开源：MySQL、PostgreSQL</p><p>商业：Oracle，DB2，SQL Server</p><p>内存数据库：Redis？，VoltDB</p><p>图数据库：Neo4j，Nebula</p><p>时序数据库：InfluxDB、openTSDB</p><p>其他关系数据库：Access、Sqlite、H2、Derby、Sybase、Infomix 等</p><p>NoSQL 数据库：MongoDB、Hbase、Cassandra、CouchDB</p><p>NewSQL/ 分布式数据库：TiDB、CockroachDB、NuoDB、OpenGauss、OB、TDSQL</p><p><strong>SQL 语言</strong></p><p>SQL 语言1974年由 Boyce 和 Chamberlin 提出，并首先在 IBM 公司研制的关系数据库</p><p>系统 SystemR 上实现。</p><p>1979年 ORACLE 公司首先提供商用的 SQL，IBM 公司在 DB2和SQL/DS 数据库系统中</p><p>也实现了 SQL。</p><p>1986年10月，美国 ANSI 采用 SQL 作为关系数据库管理系统的标准语言（ANSI X3.</p><p>135-1986），后为国际标准化组织（ISO）采纳为国际标准。</p><p>1989年，美国 ANSI 采纳在 ANSI X3.135-1989 报告中定义的关系数据库管理系统的</p><p>SQL 标准语言，称为 ANSI SQL 89，该标准替代 ANSI X3.135-1986版本。</p><p>还有没有其他办法？</p><p><strong>SQL 语言</strong></p><p>结构化查询语言包含 6 个部分：</p><p>1、数据查询语言（DQL: Data Query Language）：其语句，也称为“数据检索语句”，用以从表</p><p>中获得数据，确定数据怎样在应用程序给出。保留字 SELECT 是 DQL（也是所有 SQL）用得最多</p><p>的动词，其他 DQL 常用的保留字有 WHERE，ORDER BY，GROUP BY 和 HAVING。这些 DQL 保</p><p>留字常与其它类型的 SQL 语句一起使用。</p><p>2、数据操作语言（DML：Data Manipulation Language）：其语句包括动词 INSERT、</p><p>UPDATE 和 DELETE。它们分别用于添加、修改和删除。</p><p>3、事务控制语言（TCL）：它的语句能确保被 DML 语句影响的表的所有行及时得以更新。包括</p><p>COMMIT（提交）命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。</p><p>4、数据控制语言（DCL）：它的语句通过 GRANT 或 REVOKE 实现权限控制，确定单个用户和用</p><p>户组对数据库对象的访问。某些 RDBMS 可用 GRANT 或 REVOKE 控制对表单个列的访问。</p><p>5、数据定义语言（DDL）：其语句包括动词 CREATE,ALTER 和 DROP。在数据库中创建新表或修</p><p>改、删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。</p><p>6、指针控制语言（CCL）：它的语句，像 DECLARE CURSOR，FETCH INTO 和 UPDATE WHERE</p><p>CURRENT 用于对一个或多个表单独行的操作。</p><p><strong>SQL 语言</strong></p><p>SQL 的各个版本:</p><p>1986年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86</p><p>1989年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89</p><p>1992年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2）</p><p>1999年，ISO/IEC 9075:1999，SQL:1999（SQL3）</p><p>2003年，ISO/IEC 9075:2003，SQL:2003</p><p>2008年，ISO/IEC 9075:2008，SQL:2008</p><p>2011年，ISO/IEC 9075:2011，SQL:2011</p><p><strong>MySQL 数据库</strong></p><p>瑞典的 MySQL AB 创立于1995年。</p><p>2008年1月16日 MySQL AB被 Sun Microsystems 收购。</p><p>2009年4月20日，甲骨文（Oracle）收购 Sun Microsystems 公司。</p><p>其后分离成两个版本：MariaDB 和 MySQL</p><p><strong>MySQL 数据库</strong></p><p>MySQL 的版本</p><p>4.0支持 InnoDB，事务</p><p>2003年，5.0</p><p>5.6 ==&gt; 历史使用最多的版本</p><p>5.7 ==&gt; 近期使用最多的版本</p><p>8.0 ==&gt;最新和功能完善的版本</p><p>选择学习哪个版本？</p><p><strong>MySQL 数据库</strong></p><p>5.6/5.7的差异</p><p>5.7支持：</p><p>多主</p><p>MGR 高可用</p><p>分区表</p><p>json</p><p>性能</p><p>修复 XA 等</p><p><strong>MySQL 数据库</strong></p><p>5.7/8.0的差异</p><p>通用表达式</p><p>窗口函数</p><p>持久化参数</p><p>自增列持久化</p><p>默认编码 utf8mb4</p><p>DDL 原子性</p><p>JSON 增强</p><p>不再对 group by 进行隐式排序？？==&gt; 坑</p><h2 id="3-深入数据库原理"><a href="#3-深入数据库原理" class="headerlink" title="3.深入数据库原理*"></a>3.深入数据库原理*</h2><p><strong>MySQL 架构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161145.png" alt="image-20210411161145465"></p><p>还有没有其他办法？</p><p><strong>MySQL 存储</strong></p><p>独占模式</p><p>1）日志组文件：ib_logfile0和ib_logfile1，默认均为5M</p><p>2）表结构文件：*.frm</p><p>3）独占表空间文件：*.ibd</p><p>4）字符集和排序规则文件：db.opt</p><p>5）binlog 二进制日志文件：记录主数据库服务器的 DDL 和 DML 操作</p><p>6）二进制日志索引文件：master-bin.index</p><p>共享模式 innodb_file_per_table=1</p><p>1）、数据都在 ibdata1</p><p><strong>MySQL 简化执行流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161201.png" alt="image-20210411161201576"></p><p><strong>MySQL 详细执行流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161218.png" alt="image-20210411161218511"></p><p><strong>MySQL 执行引擎和状态</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161236.png" alt="image-20210411161236457"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161257.png" alt="image-20210411161257217"></p><p><strong>MySQL 对 SQL 执行顺序</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161310.png" alt="image-20210411161310874"></p><p>实际上这个过程也并不是绝对这样的，</p><p>中间 mysql 会有部分的优化以达到最佳</p><p>的优化效果，比如在 select 筛选出找到</p><p>的数据集</p><p><strong>MySQL 索引原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411161323.png" alt="image-20210411161323310"></p><p>数据是按页来分块的，当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p>InnoDB 使用 B+ 树实现聚集索引，</p><p>为什么一般单表数据不超过2000万？</p><p><strong>MySQL 数据库操作演示</strong></p><p>操作示例</p><p>安装的几种方式，安装文件或命令，docker</p><p>操作工具，mysql-cli 或 IDE(DataGrip,MySQL-WorkBench,MySQL-Front,Navicat 等)</p><p>MySQL 库结构，操作语句与命令</p><p>MySQL SQL 语法演示</p><p>5.6/5.7/8.0</p><h2 id="4-MySQL-配置优化"><a href="#4-MySQL-配置优化" class="headerlink" title="4. MySQL 配置优化*"></a>4. MySQL 配置优化*</h2><p><strong>参数配置优化1</strong></p><p>1）连接请求的变量</p><p>1、max_connections</p><p>2、back_log</p><p>3、wait_timeout和interative_timeout</p><p><strong>参数配置优化</strong></p><p>查看参数配置</p><p>show variables like xxx</p><p>my.cnf 文件</p><p><strong>参数配置优化2</strong></p><p>2）缓冲区变量</p><p>4、key_buffer_size</p><p>5、query_cache_size（查询缓存简称 QC)</p><p>6、max_connect_errors：</p><p>7、sort_buffer_size：</p><p>8、max_allowed_packet=32M</p><p>9、join_buffer_size=2M</p><p>10、thread_cache_size=300</p><p><strong>参数配置优化3</strong></p><p>3）配置 Innodb 的几个变量</p><p>11、innodb_buffer_pool_size</p><p>12、innodb_flush_log_at_trx_commit</p><p>13、innodb_thread_concurrency=0</p><p>14、innodb_log_buffer_size</p><p>15、innodb_log_file_size=50M</p><p>16、innodb_log_files_in_group=3</p><p>17、read_buffer_size=1M</p><p>18、read_rnd_buffer_size=16M</p><p>19、bulk_insert_buffer_size=64M</p><p>20、binary log</p><h2 id="5-数据库设计优化"><a href="#5-数据库设计优化" class="headerlink" title="5.数据库设计优化*"></a>5.数据库设计优化*</h2><p><strong>MySQL 数据库设计优化最佳实践</strong></p><p>如何恰当选择引擎？</p><p>库表如何命名？</p><p>如何合理拆分宽表？</p><p>如何选择恰当数据类型：明确、尽量小</p><p>char、varchar 的选择</p><p>（text/blob/clob）的使用问题？</p><p>文件、图片是否要存入到数据库？</p><p>时间日期的存储问题？</p><p>数值的精度问题？</p><p>是否使用外键、触发器？</p><p>还有哪些常见问题？</p><p><strong>MySQL 数据库设计优化</strong></p><p>唯一约束和索引的关系？</p><p>是否可以冗余字段？</p><p>是否使用游标、变量、视图、自定义函数、存储过程？</p><p>自增主键的使用问题？</p><p>能够在线修改表结构（DDL 操作）？</p><p>逻辑删除还是物理删除？</p><p>要不要加 create_time,update_time 时间戳？</p><p>数据库碎片问题？</p><p>如何快速导入导出、备份数据？</p><p>性能是一个综合性问题</p><h2 id="6-总结回顾与作业实践"><a href="#6-总结回顾与作业实践" class="headerlink" title="6.总结回顾与作业实践"></a>6.总结回顾与作业实践</h2><p><strong>第 12 节课总结回顾</strong></p><p><strong>性能与关系数据库</strong></p><p><strong>MySQL 与 SQL</strong></p><p><strong>数据库原理</strong></p><p><strong>参数优化与设计优化</strong></p><p><strong>第12节课作业实践</strong></p><p>1、（选做）：基于课程中的设计原则和最佳实践，分析是否可以将自己负责的业务系统</p><p>进行数据库设计或是数据库服务器方面的优化。</p><p>2、（必做）：基于电商交易场景（用户、商品、订单），设计一套简单的表结构，提交</p><p>DDL 的 SQL 文件到 Github（后面2周的作业依然要是用到这个表结构）。</p><p>3、（选做）：尽可能多的从“常见关系数据库”中列的清单，安装运行，并使用上一题的</p><p>SQL 测试简单的增删改查。</p><p>4、（选做）：基于上一题，尝试对各个数据库测试100万订单数据的增删改查性能。</p><p>5、（选做）：尝试对 MySQL 不同引擎下测试100万订单数据的增删改查性能。</p><p>6、（选做）：模拟1000万订单数据，测试不同方式下导入导出（数据备份还原）</p><p>MySQL 的速度，包括 jdbc 程序处理和命令行处理。思考和实践，如何提升处理效率。</p><p>7、（选做）：对 MySQL 配置不同的数据库连接池（DBCP、C3P0、Druid、Hikari），</p><p>测试增删改查100万次，对比性能，生成报告。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week06-01 Java相关框架（3）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week06-01%20Java%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%883%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week06-01%20Java%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 11 课</p><h1 id="Java相关框架（3）"><a href="#Java相关框架（3）" class="headerlink" title="Java相关框架（3）"></a>Java相关框架（3）</h1><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.Java8 Lambda*</p><p>2.Java8 Stream*</p><p>3.Lombok</p><p>4.Guava</p><p>5.设计原则*</p><p>6.设计模式*</p><p>7.单元测试*</p><p>8.第11课总结回顾与作业实践</p><h2 id="1-Java8-Lambda"><a href="#1-Java8-Lambda" class="headerlink" title="1. Java8 Lambda*"></a>1. Java8 Lambda*</h2><p><strong>什么是 Lambda 表达式？</strong></p><p>Lambda 表达式（lambda expression）是一个匿名函数，Lambda 表达式基于数学中的λ演算得名，直接对应于其中的 lambda 抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。从动态引用到动态定义，简化写法</p><p><strong>Java Lambda 表达式</strong></p><p>面向对象与面向函数。</p><p>Java 里，函数不是第一等公民，需要封装到接口里。</p><p>从而 Java Lambda 表达式 –&gt; 内部匿名类。</p><p>方法签名。</p><p>两种函数。</p><p>只有一行时可以省略大括号</p><p>(parameters) -&gt; expression</p><p>或</p><p>(parameters) -&gt;{ statements; }</p><p><strong>Java Lambda 表达式</strong></p><p>// 1. 不需要参数,返回值为 5</p><p>() -&gt; 5</p><p>// 2. 接收一个参数(数字类型),返回其2倍的值</p><p>x -&gt; 2 * x</p><p>// 3. 接受2个参数(数字),并返回他们的差值</p><p>(x, y) -&gt; x – y</p><p>// 4. 接收2个int型整数,返回他们的和</p><p>(int x, int y) -&gt; x + y</p><p>// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回 void)</p><p>(String s) -&gt; System.out.print(s)</p><p>J<strong>ava Lambda 表达式</strong></p><p>代码实例</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160448.png" alt="image-20210411160447928"></p><p><strong>Java Lambda 表达式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160503.png" alt="image-20210411160503453"></p><p><strong>深入 Java8 函数式</strong></p><p>@FunctionalInterface</p><p>Predicate<t> 有参数、条件判断</t></p><p>Function&lt;T, R&gt; 有参数、有返回值</p><p>Consumer<t> 无返回值</t></p><p>Supplier<t> 无参数、有返回值</t></p><p>能否进一步简化：方法引用</p><p><strong>Java Lambda 表达式</strong></p><p>代码实例</p><h2 id="2-Java8-Stream"><a href="#2-Java8-Stream" class="headerlink" title="2.Java8 Stream*"></a>2.Java8 Stream*</h2><p><strong>再聊聊 Java 集合与泛型</strong></p><p>什么是泛型？</p><p>伪泛型，擦除法</p><p>运行期怎么判断有泛型？</p><p>lambda 里用泛型</p><p>多个泛型约束条件</p><p>泛型也是为了简化编程</p><p><strong>什么是流</strong></p><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><p>元素：特定类型的对象，形成一个队列。 Java 中的 Stream 并不会存储元素，而是按需计算。</p><p>数据源：流的来源。 可以是集合，数组，I/O channel， 产生器 generator 等。</p><p>聚合操作 类似 SQL 语句一样的操作， 比如 filter, map, reduce, find, match, sorted 等。</p><p>和以前的 Collection 操作不同， Stream 操作还有两个基础的特征：</p><p>Pipelining：中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格(fluent style)。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路((short circuiting)。</p><p>内部迭代：以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream 提供了内部迭代的方式， 通过访问者模式(Visitor)实现。创建有 Stream 有哪些方法</p><p><strong>Stream 操作</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160522.png" alt="image-20210411160521971"></p><p>中间操作：</p><p>1、选择与过滤</p><p>filter(Predicate p) 接收 Lambda ， 从流中排除某些元素。</p><p>distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</p><p>limit(long maxSize) 截断流，使其元素不超过给定数量。</p><p>skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返</p><p>回一个空流。</p><p><strong>Stream 操作</strong></p><p>中间操作：</p><p>2、映射</p><p>map(Function f) 接收 Lambda ， 将元素转换成其他形式或提取信息;接收一个函数作为参数，</p><p>该函数会被应用到每个元素上，并将其映射成一个新的元素。</p><p>mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，</p><p>产生一个新的 DoubleStream。</p><p>mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新</p><p>的 IntStream。</p><p>mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生</p><p>一个新的 LongStream。</p><p>flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连</p><p>接成一个流。</p><p><strong>Stream 操作</strong></p><p>中间操作：</p><p>3、排序</p><p>sorted() 产生一个新流，其中按自然顺序排序</p><p>sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序</p><p><strong>Stream 操作</strong></p><p>终止操作：</p><p>1.查找与匹配</p><p><strong>allMatch——检查是否匹配所有元素</strong></p><p><strong>anyMatch——检查是否至少匹配一个元素</strong></p><p><strong>noneMatch——检查是否没有匹配的元素</strong></p><p><strong>findFirst——返回第一个元素</strong></p><p><strong>findAny——返回当前流中的任意元素</strong></p><p><strong>count——返回流中元素的总个数</strong></p><p><strong>max——返回流中最大值</strong></p><p><strong>min——返回流中最小值</strong></p><p>2.归约 reduce, 需要初始值（类比Map-Reduce）</p><p>3.收集 collect</p><p><strong>toList List<t> 把流中元素收集到 List</t></strong></p><p><strong>toSet Set<t> 把流中元素收集到 Set</t></strong></p><p><strong>toCollection Collection<t> 把流中元素收集到创建的集合</t></strong></p><p><strong>count 计算流中元素的个数</strong></p><p><strong>summaryStatistics 统计最大最小平均值Steam 操作示例</strong></p><p>4.迭代 forEach</p><p>Stream 代码</p><p>Stream 大大简化了集合编程</p><h2 id="3-Lombok"><a href="#3-Lombok" class="headerlink" title="3.Lombok"></a>3.Lombok</h2><p><strong>Lombok 是什么</strong></p><p>Lombok 是什么？</p><p>Lombok 是基于 jsr269 实现的一个非常神奇的 java 类库，会利用注解自动生成 java Bean 中烦人的get、set 方法及有参无参构造函数，还能自动生成 logger、ToString、HashCode、Builder 等 java 特色的函数或是符合设计模式的方法，能够让你 java Bean 更简洁，更美观。基于字节码增强，编译期处理。可以配置开发工具 IDE 或 Mave 能使用。</p><p>编译期增强跟前面讲的字节码工具异同点？</p><p><strong>Lombok 示例</strong></p><p>@Setter @Getter</p><p>@Data</p><p>@XXXConstructor</p><p>@Builder</p><p>@ToString</p><p>@Slf4j</p><p>泛型也是为了简化编程</p><h2 id="4-Guava"><a href="#4-Guava" class="headerlink" title="4.Guava"></a>4.Guava</h2><p><strong>什么是 Guava</strong></p><p>Guava 是什么?</p><p>Guava 是一种基于开源的 Java 库，其中包含谷歌正在由他们很多项目使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O 和验证的实用方法。</p><p>Guava 的好处</p><p>标准化 – Guava 库是由谷歌托管。</p><p>高效 - 可靠，快速和有效的扩展 JAVA 标准库。</p><p>优化 –Guava 库经过高度的优化。</p><p>JDK8 里的一些新特性源于 Guava。</p><p><strong>什么是 Guava</strong></p><p><strong>集合[Collections]</strong></p><p>Guava 对 JDK 集合的扩展，这是 Guava 最成熟和为人所知的部分</p><p>1 不可变集合: 用不变的集合进行防御性编程和性能提升。</p><p><strong>2 新集合类型: multisets, multimaps, tables, bidirectional maps 等</strong></p><p><strong>3 强大的集合工具类: 提供 java.util.Collections 中没有的集合工具</strong></p><p>4 扩展工具类：让实现和扩展集合类变得更容易，比如创建 Collection 的装饰器，或实现迭代器</p><p><strong>什么是 Guava</strong></p><p><strong>缓存[Caches]</strong></p><p><strong>本地缓存实现，支持多种缓存过期策略</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160549.png" alt="image-20210411160548991"></p><p><strong>并发[Concurrency]</strong></p><p><strong>ListenableFuture：完成后触发回调的 Future</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160601.png" alt="image-20210411160601058"></p><p><strong>什么是 Guava</strong></p><p><strong>字符串处理[Strings]</strong></p><p><strong>非常有用的字符串工具，包括分割、连接、填充等操作</strong></p><p><strong>事件总线[EventBus]</strong></p><p><strong>发布-订阅模式的组件通信，进程内模块间解耦</strong></p><p><strong>反射[Reflection]</strong></p><p><strong>Guava 的 Java 反射机制工具类</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160615.png" alt="image-20210411160615774"></p><h2 id="5-设计原则"><a href="#5-设计原则" class="headerlink" title="5.设计原则*"></a>5.设计原则*</h2><p><strong>面向对象设计原则 SOLID</strong></p><p>S.O.L.I.D 是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字</p><p>母缩写。</p><p>1.SRP：The Single Responsibility Principle 单一责任原则</p><p>2.OCP：The Open Closed Principle 开放封闭原则</p><p>3.LSP：The Liskov Substitution Principle 里氏替换原则</p><p>4.ISP：The Interface Segregation Principle 接口分离原则</p><p>5.DIP：The Dependency Inversion Principle 依赖倒置原则</p><p>最小知识原则，KISS，高内聚低耦合</p><p><strong>编码规范、checkstyle</strong></p><p>为什么需要编码规范？</p><p>常见的编码规范：</p><p>1、Google 编码规范：<a href="https://google.github.io/styleguide/javaguide.html">https://google.github.io/styleguide/javaguide.html</a></p><p>2、Alibaba 编码规范：<a href="https://github.com/alibaba/p3c">https://github.com/alibaba/p3c</a></p><p>3、VIP 规范：<a href="https://vipshop.github.io/vjtools/#/standard/">https://vipshop.github.io/vjtools/#/standard/</a></p><p>其他规范：</p><p>架构设计规范，技术调研规范，数据库规范等等。</p><h2 id="6-设计模式"><a href="#6-设计模式" class="headerlink" title="6.设计模式*"></a>6.设计模式*</h2><p><strong>GoF 23 设计模式</strong></p><p>GoF 23 个经典设计模式（面向接口编程），</p><p>本质是一类特定场景下通用解决经验。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160632.png" alt="image-20210411160632394"></p><p><strong>创建型</strong></p><p><strong>1. Factory Method（工厂方法）</strong></p><p><strong>2. Abstract Factory（抽象工厂）</strong></p><p><strong>3. Builder（建造者）</strong></p><p><strong>4. Prototype（原型）</strong></p><p><strong>5. Singleton（单例）</strong></p><p><strong>结构型</strong></p><p><strong>6. Adapter（适配器）</strong></p><p><strong>7. Bridge（桥接）</strong></p><p><strong>8. Composite（组合）</strong></p><p><strong>9. Decorator（装饰）</strong></p><p><strong>10. Facade（外观）</strong></p><p><strong>11. Flyweight（享元）</strong></p><p><strong>12. Proxy（代理）</strong></p><p><strong>行为型</strong></p><p><strong>13. Interpreter（解释器）</strong></p><p><strong>14. Template Method（模板方法）</strong></p><p><strong>15. Chain of Responsibility（责任链）</strong></p><p><strong>16. Command（命令）</strong></p><p><strong>17. Iterator（迭代器）</strong></p><p><strong>18. Mediator（中介者）</strong></p><p><strong>19. Memento（备忘录）</strong></p><p><strong>20. Observer（观察者）</strong></p><p><strong>21. State（状态）</strong></p><p><strong>22. Strategy（策略）</strong></p><p><strong>23. Visitor（访问者）</strong></p><p><strong>设计模式与反模式</strong></p><p>模式的3个层次：解决方案层面（架构模式），组件层面（框架模式），代码层面（GoF设计模式）</p><p>其他模式：集成模式，事务模式，IO 模式/Context 模式，甚至状态机 FSM，规则引擎 RE，workflow 都是模式。</p><p>反模式：死用模式，都是反模式。</p><h2 id="7-单元测试"><a href="#7-单元测试" class="headerlink" title="7.单元测试*"></a>7.单元测试*</h2><p><strong>什么是单元测试</strong></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160649.png" alt="image-20210411160649642" style="zoom:33%;"><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160710.png" alt="image-20210411160710049"></p><p><strong>什么是单元测试</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411160726.png" alt="image-20210411160726211"></p><p>发现缺陷越提前，修复成本越小</p><p><strong>如何做单元测试</strong></p><p>JUnit -&gt; TestCase, TestSuite, Runner</p><p>SpringTest</p><p>Mock 技术</p><p>Mockito</p><p>easyMock</p><p><strong>如何做单元测试</strong></p><ol><li>单元测试方法应该每个方法是一个 case，断言充分，提示明确</li><li>单测要覆盖所有的 corner case</li><li>充分使用 mock（一切皆可 mock）</li><li>如果发现不好测试，则说明业务代码设计存在问题，可以反向优化代码</li><li>批量测试用例使用参数化单元测试</li><li>注意测试是单线程执行</li><li>合理使用 before, after, setup 准备环境</li><li>合理使用通用测试基类</li><li>配合 checkstyle，coverage 等工具</li></ol><p>10.制定单元测试覆盖率基线</p><p><strong>单元测试的常见陷阱与经验</strong></p><ol><li>尽量不要访问外部数据库等外部资源</li><li>如果必须用数据库考虑用嵌入式 DB+ 事务自动回滚</li><li>防止静态变量污染导致测试无效</li><li>小心测试方法的顺序导致的不同环境测试失败</li><li>单元测试总时间特别长的问题</li></ol><h2 id="9-总结回顾与作业实践"><a href="#9-总结回顾与作业实践" class="headerlink" title="9.总结回顾与作业实践"></a>9.总结回顾与作业实践</h2><p><strong>第 11 课总结回顾</strong></p><p><strong>Java8 Lambda/Stream</strong></p><p>Lombok/Guava</p><p>设计原则与设计模式</p><p><strong>单元测试与编程经验</strong></p><p><strong>第11课作业实践</strong></p><p>1、（选做）尝试使用 Lambda/Stream/Guava 优化之前作业的代码。</p><p>2、（选做）尝试使用 Lambda/Stream/Guava 优化工作中编码的代码。</p><p>3、（选做）根据课上提供的材料，系统性学习一遍设计模式，并在工作学习中思考如何</p><p>用设计模式解决问题。</p><p>4、（选做）根据课上提供的材料，深入了解 Google 和 Alibaba 编码规范，并根据这</p><p>些规范，检查自己写代码是否符合规范，有什么可以改进的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week05-01 Java 相关框架（1）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week05-01%20Java%20%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week05-01%20Java%20%E7%9B%B8%E5%85%B3%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 9 课</p><h1 id="Java-相关框架（1）"><a href="#Java-相关框架（1）" class="headerlink" title="Java 相关框架（1）"></a>Java 相关框架（1）</h1><p>KimmKing Apache Dubbo/ShardingSphere PMC <strong>个人介绍</strong></p><p>Apache Dubbo/ShardingSphere PMC</p><p>前某集团高级技术总监/阿里架构师/某银行北京研发中心负责人</p><p>阿里云 MVP、腾讯 TVP、TGO 会员</p><p>10 多年研发管理和架构经验</p><p>熟悉海量并发低延迟交易系统的设计实现</p><p><strong>目录</strong></p><p>1.Spring 技术发展</p><p>2.Spring 框架设计*</p><p>3.Spring AOP 详解*</p><p>4.Spring Bean 核心原理*</p><p>5.Spring XML 配置原理*</p><p>6.Spring Messaging 等技术</p><p>7.第9课总结回顾与作业实践</p><h2 id="第9课-1-Spring-技术发展"><a href="#第9课-1-Spring-技术发展" class="headerlink" title="第9课 1. Spring 技术发展"></a>第9课 1. Spring 技术发展</h2><p><strong>Spring 技术发展</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154823.png" alt="image-20210411154823743"></p><p><strong>Spring 框架的产生与发展</strong></p><p><strong>2002 年 10 月，Rod Johnson 撰写了一本名为 Expert One-on-One J2EE 设计和开发的</strong></p><p><strong>书。</strong></p><p><strong>Rod，Juergen 和 Yann 于 2003 年 2 月左右开始合作开发 Spring 项目。</strong></p><p><strong>自 2004 年 1.0 版本发布以来，Spring 框架迅速发展。</strong></p><p><strong>Spring 2.0 于 2006 年 10 月发布，到那时，Spring 的下载量超过了 100 万。</strong></p><p><strong>在 Rod 领导下管理 Interface21 项目于 2007 年 11 月更名为 SpringSource。同时发布了</strong></p><p><strong>Spring 2.5。Spring 2.5 中的主要新功能包括支持 Java 6 / Java EE 5，支持注释配置，</strong></p><p><strong>classpath 中的组件自动检测和兼容 OSGi 的 bundle。</strong></p><p><strong>2007 年，SpringSource 从基准资本获得了 A 轮融资（1000万美元）。</strong></p><p><strong>2009 年 8 月，SpringSource 以 4.2 亿美元被 VMWare 收购。</strong></p><p><strong>2009 年 12 月，Spring 3.0 发布。</strong></p><p><strong>2012 年 7 月，Rod Johnson 离开了团队。Spring 技术发展</strong></p><p><strong>Spring 框架的产生与发展</strong></p><p><strong>2013 年 4月，VMware 和 EMC 通过 GE 投资创建了一家名为 Pivotal 的合资企业。所有的</strong></p><p><strong>Spring 应用项目都转移到了 Pivotal。</strong></p><p><strong>2013 年 12 月，Pivotal 宣布发布 Spring 框架 4.0。Spring 4.0 是 Spring 框架的一大进</strong></p><p><strong>步，它包含了对 Java 8 的全面支持，更高的第三方库依赖性（groovy 1.8+，ehcache</strong></p><p><strong>2.1+，hibernate 3.6+等），Java EE 7 支持，groovy DSL for bean 定义，对</strong></p><p><strong>websockets 的支持以及对泛型类型的支持作为注入 bean 的限定符。</strong></p><p><strong>2014 年至 2017 年期间发布了许多 Spring 框架 4.xx 系列版本。</strong></p><p><strong>Spring 5.0 GA 版本于 2017 年 9 月 28 日发布。</strong></p><p><strong>Spring 5.0 开始支持 JDK 8 和 Java EE 7，同时兼容 JDK9。</strong></p><p><strong>全面支持 Servlet 3.1，还引入了一个全新的模块 Spring WebFlux。</strong></p><p><strong>用于替代老话的 spring-webmvc；对 Kotlin 也有了更好的支持。</strong></p><p><strong>Spring 技术发展</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154957.png" alt="image-20210411154957703"></p><p><strong>Spring框架的产生与发展</strong></p><p><strong>Spring 技术发展</strong></p><p><strong>Spring框架的产生与发展</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154843.png" alt="image-20210411154843083"></p><p><strong>Pivotal 公司成立之后，于 2014 年发布了 Spring Boot，2015 年发布了 Spring Cloud，2018 年</strong></p><p><strong>Pivotal 公司在纽约上市。公司的开源产品有：Spring 以及 Spring 衍生产品、Web 服务器</strong></p><p><strong>Tomcat、缓存中间件 Redis、消息中间件 RabbitMQ、平台即服务的 Cloud Foundry、</strong></p><p><strong>Greenplum 数据引擎、 GemFire（12306 系统解决方案组件之一）。</strong></p><p><strong>Spring 技术发展</strong></p><p><strong>Spring 框架的产生与发展</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155025.png" alt="image-20210411155025330"></p><p>2.5.6</p><p>3.3.1</p><p>4.x</p><h2 id="2-Spring-框架设计"><a href="#2-Spring-框架设计" class="headerlink" title="2.Spring 框架设计*"></a>2.Spring 框架设计*</h2><p><strong>Spring 框架设计</strong></p><p>思考一下：什么是框架？</p><p>你理解的 Spring 框架是什么呢？</p><p><strong>Spring framework 6大模块</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155049.png" alt="image-20210411155049193"></p><p>4 个常用模块</p><ol><li>Core：Bean/Context/AOP</li><li>Testing：Mock/TestContext</li><li>DataAccess: Tx/JDBC/ORM</li><li>Spring MVC/WebFlux: web</li><li>Integration: remoting/JMS/WS</li><li>Languages: Kotlin/Groovy</li></ol><p><strong>Spring 框架设计</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155112.png" alt="image-20210411155112327"></p><p>Bean</p><p>AOP</p><p>Context</p><p>JDBC</p><p>Web</p><p>TX</p><p>Testing</p><p>Core/Batch/Security</p><p>MVC/WebFlux</p><p>ORM</p><p>Integration</p><p>Data</p><p><strong>Spring 框架设计</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155126.png" alt="image-20210411155126366"></p><p>引入 Spring 意味着引入了一种研发协作模式3.Spring AOP 详解*</p><p><strong>Spring AOP</strong></p><p>AOP-面向切面编程</p><p>Spring 早期版本的核心功能，管理对象生命周期与对象装配。</p><p>为了实现管理和装配，一个自然而然的想法就是，加一个中间层代理（字节码增强）来实现所有对象</p><p>的托管。</p><p>IoC-控制反转</p><p>也称为 DI（Dependency Injection）依赖注入。</p><p>对象装配思路的改进。</p><p>从对象 A 直接引用和操作对象 B，变成对象 A 里指需要依赖一个接口 IB，系统启动和装配阶段，把</p><p>IB 接口的实例对象注入到对象 A，这样 A 就不需要依赖一个 IB 接口的具体实现，也就是类 B。</p><p>从而可以实现在不修改代码的情况，修改配置文件，即可以运行时替换成注入 IB 接口另一实现类 C</p><p>的一个对象实例。</p><p>什么类型的循环依赖 Spring 无法处理？</p><p>除了 Spring，循环依赖还有哪些类似场景？</p><p><strong>Spring AOP</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155145.png" alt="image-20210411155145009"></p><p>一个对象的代理有哪些种类？用在什么场景？</p><p>com.sun.proxy.$Proxy</p><p>EnhancerBySpringCGLIB</p><p>接口类型</p><p>非接口类型</p><p>默认使用 JdkProxy</p><p>proxyTargetClass</p><p>默认使用 CGlib</p><p>EnhancerBySpringCGLIB</p><p><strong>Spring AOP</strong></p><p>AOP-面向切面编程</p><p>演示 AOP 的例子</p><p><strong>Spring AOP</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155207.png" alt="image-20210411155207276"></p><p><strong>字节码增强与反射的区别</strong></p><p><strong>类似于基因操作技术与拍CT照B超</strong></p><p><strong>字节码增强新工具</strong></p><p><strong>ByteBuddy提供了更友好的操作API</strong></p><p>字节码增强有哪些类似 CGlib 工具？</p><h2 id="4-Spring-Bean-核心原理"><a href="#4-Spring-Bean-核心原理" class="headerlink" title="4.Spring Bean 核心原理*"></a>4.Spring Bean 核心原理*</h2><p><strong>Spring Bean 生命周期</strong></p><p>Bean 的加载过程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155225.png" alt="image-20210411155225691"></p><p>从 Bean 工厂到应用上下文</p><p><strong>Spring Bean 生命周期</strong></p><p>Bean 的加载过程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155241.png" alt="image-20210411155241172"></p><p>为什么设计得这么复杂？</p><p><strong>Spring Bean 生命周期</strong></p><p>Bean 的加载过程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155303.png" alt="image-20210411155303108"></p><p>是否可以对照 Classloader 加载？</p><p><strong>Spring Bean 生命周期</strong></p><p><strong>Bean 的加载过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155318.png" alt="image-20210411155318104"></p><p><strong>1）创建对象</strong></p><p><strong>2）属性赋值</strong></p><p><strong>3）初始化</strong></p><p><strong>4）注销接口注册</strong></p><p><strong>Spring Bean 生命周期</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155334.png" alt="image-20210411155334885"></p><p><strong>Bean 的加载过程：</strong></p><p><strong>1）检查 Aware 装配</strong></p><p><strong>2）前置处理、After 处理</strong></p><p><strong>3）调用 init method</strong></p><p><strong>4）后置处理</strong></p><p><strong>返回包装类</strong></p><p><strong>Spring Bean 生命周期</strong></p><p><strong>Bean 的加载过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155353.png" alt="image-20210411155353729"></p><p><strong>Spring 管理对象生命周期以后，也就改变了编程和协作模式。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155406.png" alt="image-20210411155406453"></p><h2 id="5-Spring-XML-配置原理"><a href="#5-Spring-XML-配置原理" class="headerlink" title="5.Spring XML 配置原理*"></a>5.Spring XML 配置原理*</h2><p><strong>Spring XML 配置原理</strong></p><p><strong>XML 配置原理：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155421.png" alt="image-20210411155421792"></p><p>Bean schema</p><p>Location</p><p><strong>spring.schemas</strong></p><p><strong>spring.handler</strong></p><p><strong>检查 XML 配置是否正确</strong></p><p><strong>从 DOM 节点 parse 对象</strong></p><p>自定义标签</p><p><strong>Spring XML 配置原理</strong></p><p><strong>自动化 XM L配置工具：</strong></p><p>XmlBeans -&gt; Spring-xbean</p><p>2个原理：</p><p>1、根据 Bean 的字段结构，自动生成 XSD</p><p>2、根据 Bean 的字段结构，配置 XML 文件</p><p>思考：1、解析 XML 的工具有哪些，都有什么特点？</p><p>2、XML &lt;-&gt; Bean 相互转换的工具，除了 xbean，还有什么？</p><p>演示自定义 XML 配置的例子</p><p><strong>Spring Bean 配置方式演化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155435.png" alt="image-20210411155435722"></p><p>XML 配置/注解注入</p><p>全自动注解配置</p><p>XML</p><p>@AutoWire</p><p>@Service</p><p>@Bean</p><p>@Configuration</p><p>@Condition</p><p>@AutoConfigureX</p><p>1.0/2.0</p><p>2.5</p><p>3.0</p><p>4.0/SpringBoot</p><p>半自动注解配置</p><p>Java Config 配置</p><h2 id="6-Spring-Messaging-等技术"><a href="#6-Spring-Messaging-等技术" class="headerlink" title="6.Spring Messaging 等技术"></a>6.Spring Messaging 等技术</h2><p><strong>Spring Messaging 等技术</strong></p><p>介绍 Messaging 与 JMS</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155636.png" alt="image-20210411155636513"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155654.png" alt="image-20210411155654172"></p><p>同步转异步</p><p><strong>Spring Messaging 等技术</strong></p><p>介绍 Messaging 与 JMS</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155709.png" alt="image-20210411155709515"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411155723.png" alt="image-20210411155722944"></p><p>JMS 规范类似于 JDBC</p><p><strong>Spring Messaging 等技术</strong></p><p>介绍 Messaging 与 JMS</p><p>不要着急，《分布式消息》模块系统化讲解 MQ</p><p>演示 JMS 的例子</p><h2 id="7-第9课总结回顾与作业实践"><a href="#7-第9课总结回顾与作业实践" class="headerlink" title="7.第9课总结回顾与作业实践"></a>7.第9课总结回顾与作业实践</h2><p><strong>第 9 节课总结回顾</strong></p><p><strong>Spring 发展与框架</strong></p><p><strong>Spring AOP</strong></p><p><strong>Spring Bean</strong></p><p><strong>Spring XML 配置</strong></p><p><strong>Spring JMS 示例</strong></p><p><strong>第 9 节课作业实践</strong></p><p>1、（选做）使 Java 里的动态代理，实现一个简单的 AOP。</p><p>2、（必做）写代码实现 Spring Bean 的装配，方式越多越好（XML、Annotation 都可以）,</p><p>提交到 Github。</p><p>3、（选做）实现一个 Spring XML 自定义配置，配置一组 Bean，例如：</p><p>Student/Klass/School。</p><p>4、（<em>选做，会添加到高手附加题</em>）</p><p>4.1 （挑战）讲网关的 frontend/backend/filter/router 线程池都改造成 Spring 配置方式；</p><p>4.2 （挑战）基于 AOP 改造 Netty 网关，filter 和 router 使用 AOP 方式实现；</p><p>4.3 （中级挑战）基于前述改造，将网关请求前后端分离，中级使用 JMS 传递消息；</p><p>4.4 （中级挑战）尝试使用 ByteBuddy 实现一个简单的基于类的 AOP；</p><p>4.5 （超级挑战）尝试使用 ByteBuddy 与 Instrument 实现一个简单 JavaAgent 实现无侵入</p><p>下的 AOP。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week04-01 Java 并发编程（2）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week04-01%20Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week04-01%20Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 7 课</p><h1 id="Java-并发编程（2）"><a href="#Java-并发编程（2）" class="headerlink" title="Java 并发编程（2）"></a>Java 并发编程（2）</h1><p><strong>目录</strong></p><ol><li>Java并发包（JUC）</li><li>到底什么是锁*</li><li>并发原子类*</li><li>并发工具类详解*</li><li>第 7 课总结回顾与作业实践</li></ol><h2 id="1-Java-并发包"><a href="#1-Java-并发包" class="headerlink" title="1. Java 并发包"></a>1. Java 并发包</h2><p><strong>JDK 核心库的包</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153443.png" alt="image-20210411153443404"></p><p>java.lang.*</p><p><a href="http://java.io/">java.io</a>.*</p><p>java.util.*</p><p>java.math.*</p><p><a href="http://java.net/">java.net</a>.*</p><p>java.rmi.*</p><p>java.sql.*</p><p>javax.*</p><p>sun.*</p><p>JDK 公开 API</p><p>所有 JDK 都需要实现</p><p>最基础,Integer/String</p><p>IO读写，文件操作</p><p>工具类，集合/日期</p><p>数学计算，BigInteger</p><p>网络编程，Socket</p><p>Java 内置的远程调用</p><p>JDBC 操作数据库</p><p>Java 扩展 API</p><p>sun 的 JDK 实现包</p><p><strong>Java.util.concurrency</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153501.png" alt="image-20210411153500978"></p><p>锁</p><p>原子类</p><p>线程池</p><p>工具类</p><p>集合类</p><p>线程1</p><p>线程2</p><p>线程3</p><p>线程4</p><p>synchronized/wait</p><p>sum++多线程安全</p><p>new Thread()管理</p><p>线程间协作信号量</p><p>线程安全集合类</p><p><strong>Java.util.concurrency</strong></p><p>锁机制类 Locks : Lock, Condition, ReadWriteLock</p><p>原子操作类 Atomic : AtomicInteger</p><p>线程池相关类 Executer : Future, Callable, Executor</p><p>信号量三组工具类 Tools : CountDownLatch, CyclicBarrier, Semaphore</p><p>并发集合类 Collections : CopyOnWriteArrayList, ConcurrentMap</p><h2 id="2-到底什么是锁"><a href="#2-到底什么是锁" class="headerlink" title="2.到底什么是锁"></a>2.到底什么是锁</h2><p><strong>为什么需要显式的 Lock</strong></p><p>回忆一下，上节课讲过的，</p><p>synchronized 可以加锁，</p><p>wait/notify 可以看做加锁和解锁。</p><p>那为什么还需要一个显式的锁呢？</p><p>synchronized 方式的问题：</p><p>1、同步块的阻塞无法中断（不能 Interruptibly）</p><p>2、同步块的阻塞无法控制超时（无法自动解锁）</p><p>3、同步块无法异步处理锁（即不能立即知道是否可以拿到锁）</p><p>4、同步块无法根据条件灵活的加锁解锁（即只能跟同步块范围一致）</p><p><strong>更自由的锁: Lock</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153527.png" alt="image-20210411153526982"></p><ol><li>使用方式灵活可控</li><li>性能开销小</li><li>锁工具包: java.util.concurrent.locks</li></ol><p>思考: Lock 的性能比 synchronized 高吗？</p><p>Lock 接口设计：</p><p>// 1.支持中断的 API</p><p>void lockInterruptibly() throws InterruptedException;</p><p>// 2.支持超时的 API</p><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</p><p>// 3.支持非阻塞获取锁的 API</p><p>boolean tryLock();</p><p><strong>基础接口 Lock</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153545.png" alt="image-20210411153545392"></p><p><strong>重要方法 说明</strong></p><p><strong>void</strong> lock(); 获取锁; 类比 <strong>synchronized</strong> (<strong>lock</strong>)</p><p><strong>void</strong> lockInterruptibly()</p><p><strong>throws</strong> InterruptedException;</p><p>获取锁; 允许打断;</p><p><strong>boolean</strong> tryLock(long time, TimeUnit unit)</p><p>throws InterruptedException;</p><p>尝试获取锁; 成功则返回 <strong>true; 超时则退出</strong></p><p><strong>boolean</strong> tryLock(); 尝试【无等待】获取锁; 成功则返回 <strong>true</strong></p><p><strong>void</strong> unlock(); 解锁；要求当前线程已获得锁; 类比同步块结束</p><p><strong>Condition</strong> newCondition(); 新增一个绑定到当前Lock的条件；</p><p>示例: （类比: <strong>Object</strong> monitor）</p><p><strong>final</strong> Lock lock = <strong>new</strong> ReentrantLock();</p><p><strong>final</strong> Condition notFull = lock.newCondition();</p><p><strong>final</strong> Condition notEmpty = lock.newCondition();</p><p><strong>Lock 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153619.png" alt="image-20210411153619347"></p><p>![image-20210411153636795](/Users/cutie/Library/Application Support/typora-user-images/image-20210411153636795.png)</p><p>思考:</p><p>什么是可重入锁?</p><ul><li>第二次进入时是否阻塞。</li></ul><p>什么是公平锁？</p><ul><li>公平锁意味着排队靠前的优先。</li><li>非公平锁则是都是同样机会。</li></ul><p><strong>public class LockCounter {</strong></p><p><strong>private int sum = 0;</strong></p><p><strong><em>// 可重入锁+公平锁\</em></strong></p><p><strong>private Lock lock = new ReentrantLock(true);</strong></p><p><strong>public int addAndGet() {</strong></p><p><strong>try {</strong></p><p><strong>lock.lock();</strong></p><p><strong>return ++sum;</strong></p><p><strong>} finally {</strong></p><p><strong>lock.unlock();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>public int getSum() {</strong></p><p><strong>return sum;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong><em>// 测试代码\</em></strong></p><p><strong>public static void testLockCounter() {</strong></p><p><strong>int loopNum = 100_0000;</strong></p><p><strong>LockCounter counter = new LockCounter();</strong></p><p><strong>IntStream.*range*(0, loopNum).parallel()</strong></p><p><strong>.forEach(i -&gt; counter.incrAndGet());</strong></p><p><strong>}</strong></p><p><strong>读写锁 – 接口与实现</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153656.png" alt="image-20210411153656711"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153718.png" alt="image-20210411153718724"></p><p><strong>重要方法 说明</strong></p><p><strong>Lock</strong> readLock(); 获取读锁; 共享锁</p><p><strong>Lock</strong> writeLock(); 获取写锁; 独占锁(也排斥读锁)</p><p><strong>public class ReadWriteLockCounter {</strong></p><p><strong>private int sum = 0;</strong></p><p><strong><em>// 可重入读写锁公平锁\</em></strong></p><p><strong>private ReadWriteLock lock = new</strong></p><p><strong>ReentrantReadWriteLock(true);</strong></p><p><strong>public int incrAndGet() {</strong></p><p><strong>try {</strong></p><p><strong>lock.writeLock().lock(); *// 写锁; 独占锁; 被读锁排斥*</strong></p><p><strong>return ++sum;</strong></p><p><strong>} finally {</strong></p><p><strong>lock.writeLock().unlock();</strong></p><p><strong>} }</strong></p><p><strong>public int getSum() {</strong></p><p><strong>try {</strong></p><p><strong>lock.readLock().lock(); *// 读锁; //共享锁; 保证可见性*</strong></p><p><strong>return ++sum;</strong></p><p><strong>} finally {</strong></p><p><strong>lock.readLock().unlock();</strong></p><p><strong>}</strong></p><p><strong>} }</strong></p><p><strong>// 构造方法</strong></p><p><strong>public ReentrantReadWriteLock(boolean fair) {</strong></p><p><strong>sync = fair ? new FairSync() : new</strong></p><p><strong>NonfairSync();</strong></p><p><strong>readerLock = new ReadLock(this);</strong></p><p><strong>writerLock = new WriteLock(this);</strong></p><p><strong>}</strong></p><p>注意：ReadWriteLock 管理一组锁，一个读锁，一个写锁。</p><p>读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。</p><p>所有读写锁的实现必须确保写操作对读操作的内存影响。每次只能有一个写线程，但是</p><p>同时可以有多个线程并发地读数据。ReadWriteLock 适用于读多写少的并发情况。</p><p><strong>基础接口 Condition</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153738.png" alt="image-20210411153738096"></p><p><strong>重要方法 说明</strong></p><p><strong>void</strong> await() <strong>throws</strong></p><p>InterruptedException;</p><p>等待信号; 类比 Object#wait()</p><p><strong>void</strong> awaitUninterruptibly(); 等待信号;</p><p><strong>boolean</strong> await(<strong>long</strong> time, TimeUnit unit)</p><p><strong>throws</strong> InterruptedException;</p><p>等待信号; 超时则返回 <strong>false</strong></p><p><strong>boolean</strong> awaitUntil(Date deadline)</p><p><strong>throws</strong> InterruptedException;</p><p>等待信号; 超时则返回 <strong>false</strong></p><p><strong>void</strong> signal(); 给一个等待线程发送唤醒信号; 类比</p><p>Object#notify ()</p><p><strong>void</strong> signalAll(); 给<strong>所有</strong>等待线程发送唤醒信号;</p><p>类比 Object#notifyAll()</p><p>通过 Lock.newCondition()创建。</p><p>可以看做是 Lock 对象上的信号。类似于 wait/notify。</p><p><strong>LockSupport–锁当前线程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153757.png" alt="image-20210411153757235"></p><p>LockSupport 类似于 Thread 类的静态方法，专门处理（执行这个代码的）本线程的。</p><p>思考：为什么 unpark 需要加一个线程作为参数？</p><p>因为一个 park 的线程，无法自己唤醒自己，所以需要其他线程来唤醒。</p><p><strong>用锁的最佳实践</strong></p><p>Doug Lea《Java 并发编程：设计原则与模式》一书中，</p><p>推荐的三个用锁的最佳实践，它们分别是：</p><ol><li>永远只在更新对象的成员变量时加锁</li><li>永远只在访问可变的成员变量时加锁</li><li>永远不在调用其他对象的方法时加锁</li></ol><p>KK总结-最小使用锁：</p><p>1、降低锁范围：锁定代码的范围/作用域</p><p>2、细分锁粒度：讲一个大锁，拆分成多个小锁</p><h2 id="2-并发原子类"><a href="#2-并发原子类" class="headerlink" title="2.并发原子类"></a>2.并发原子类</h2><p><strong>Atomic 工具类</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153816.png" alt="image-20210411153816631"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153832.png" alt="image-20210411153832002"></p><ol><li>原子类工具包:</li></ol><p>java.util.concurrent.atomic</p><p><strong>// 使用示例</strong></p><p><strong>public class AtomicCounter {</strong></p><p><strong>private AtomicInteger sum = new AtomicInteger(0);</strong></p><p><strong>public int incrAndGet() {</strong></p><p><strong>return sum.incrementAndGet();</strong></p><p><strong>}</strong></p><p><strong>public int getSum() {</strong></p><p><strong>return sum.get();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p>对比前面讲的，int sum，sum++线程不安全的例子。</p><p><strong>无锁技术 – Atomic 工具类</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153849.png" alt="image-20210411153849722"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153928.png" alt="image-20210411153928452"></p><ol><li>无锁技术的底层实现原理</li></ol><p>Unsafe API - Compare-And-Swap</p><p>CPU 硬件指令支持: CAS 指令</p><p>核心实现原理：</p><p>1、volatile 保证读写操作都可见（注意不保证原子）；</p><p>2、使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入。</p><p><strong>锁与无锁之争</strong></p><ol><li>思考一下，到底是有锁好，还是无锁好？</li></ol><p>什么情况下有锁好</p><p>什么情况下无锁好</p><p>乐观锁、悲观锁</p><p>数据库事务锁</p><p>CAS 本质上没有使用锁。</p><p>并发压力跟锁性能的关系：</p><p>1、压力非常小，性能本身要求就不高；</p><p>2、压力一般的情况下，无锁更快，大部分都一次写入；</p><p>3、压力非常大时，自旋导致重试过多，资源消耗很大。</p><p><strong>LongAdder 对 AtomicLong 的改进</strong></p><p>通过分段思想改进原子类，</p><p>大家想想，还有哪些是用这个思想？</p><p>多路归并的思想：</p><p>快排</p><p>G1 GC</p><p>ConcurrentHashMap</p><p>还记得我们讲的爬山，做一个大项目，都需要加里程碑，也是分段</p><p>LongAdder 的改进思路：</p><p>1、AtomicInteger 和 AtomicLong 里的 value 是所有</p><p>线程竞争读写的热点数据；</p><p>2、将单个 value 拆分成跟线程一样多的数组 Cell[]；</p><p>3、每个线程写自己的 Cell[i]++，最后对数组求和。</p><h2 id="3-并发工具类"><a href="#3-并发工具类" class="headerlink" title="3.并发工具类"></a>3.并发工具类</h2><p><strong>什么是并发工具类</strong></p><p>思考一下：</p><p>多个线程之间怎么相互协作？</p><p>前面讲到的：</p><p>1、wait/notify，</p><p>2、Lock/Condition,</p><p>可以作为简单的协作机制。</p><p>但是更复杂的，需要这些线程</p><p>满足某些条件（数量，时间，）。</p><p>更复杂的应用场景，比如</p><p>我们需要控制实际并发访问资源的并发数量</p><p>我们需要多个线程在某个时间同时开始运行</p><p>我们需要指定数量线程到达某个状态再继续处理</p><p><strong>AQS</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153947.png" alt="image-20210411153947445"></p><p>AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础（如Semaphore、CountDownLatch、ReentrantLock、ReentrantReadWriteLock），是JUC并发包中的核心基础组件。</p><p>AbstractQueuedSynchronizer：抽象队列式的同步器</p><p>两种资源共享方式: 独占 | 共享，子类负责实现公平 OR 非公平</p><p><strong>Semaphore - 信号量</strong></p><ol><li>准入数量 N</li><li>N =1 则等价于独占锁</li></ol><p>使用场景：同一时间控制并发线程数</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154004.png" alt="image-20210411154004670"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154019.png" alt="image-20210411154019870"></p><p><strong>public class SemaphoreCounter {</strong></p><p><strong>private int sum = 0;</strong></p><p><strong>private Semaphore readSemaphore = new Semaphore(100, true);</strong></p><p><strong>private Semaphore writeSemaphore = new Semaphore(1);</strong></p><p><strong>public int incrAndGet() {</strong></p><p><strong>try {</strong></p><p><strong>writeSemaphore.acquireUninterruptibly();</strong></p><p><strong>return ++sum;</strong></p><p><strong>} finally {</strong></p><p><strong>writeSemaphore.release();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>public int getSum() {</strong></p><p><strong>try {</strong></p><p><strong>readSemaphore.acquireUninterruptibly();</strong></p><p><strong>return sum;</strong></p><p><strong>} finally {</strong></p><p><strong>readSemaphore.release();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>CountdownLatch</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154037.png" alt="image-20210411154037683"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154100.png" alt="image-20210411154100769"></p><p>场景: Master 线程等待 Worker 线程把任务执行完</p><p>示例: 等所有人干完手上的活，一起去吃饭。</p><p><strong>重要方法 说明</strong></p><p><strong>public</strong> CountDownLatch(<strong>int</strong> count) 构造方法（总数）</p><p><strong>void</strong> await() <strong>throws</strong> InterruptedException 等待数量归0</p><p><strong>boolean</strong> await(<strong>long</strong> timeout, TimeUnit unit) 限时等待</p><p><strong>void</strong> countDown() 等待数减1</p><p><strong>long</strong> getCount() 返回剩余数量</p><p><strong>CountDownLatch 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154115.png" alt="image-20210411154115637"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154139.png" alt="image-20210411154139711"></p><p><strong>public static class CountDownLatchTask</strong></p><p><strong>implements Runnable {</strong></p><p><strong>private CountDownLatch latch;</strong></p><p><strong>public CountDownLatchTask(CountDownLatch latch) {</strong></p><p><strong>this.latch = latch;</strong></p><p><strong>}</strong></p><p><strong>@Override</strong></p><p><strong>public void run() {</strong></p><p><strong>Integer millis = new Random().nextInt(10000);</strong></p><p><strong>try {</strong></p><p><strong>TimeUnit.*MILLISECONDS*.sleep(millis);</strong></p><p><strong>this.latch.countDown();</strong></p><p><strong>System.*out*.println(“我的任务OK</strong></p><p><strong>了:”+Thread.*currentThread*().getName());</strong></p><p><strong>} catch (Exception e) {</strong></p><p><strong>e.printStackTrace();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>// 使用示例</strong></p><p><strong>public static void main(String[] args)</strong></p><p><strong>throws Exception {</strong></p><p><strong>int num = 100;</strong></p><p><strong>CountDownLatch latch = new</strong></p><p><strong>CountDownLatch(num);</strong></p><p><strong>List<completablefuture> list = new</completablefuture></strong></p><p><strong>ArrayList&lt;&gt;(num);</strong></p><p><strong>for (int i = 0; i &lt; num; i++) {</strong></p><p><strong>CompletableFuture<void> future =</void></strong></p><p><strong>CompletableFuture.*runAsync*(</strong></p><p><strong>new CountDownLatchTask(latch));</strong></p><p><strong>list.add(future);</strong></p><p><strong>}</strong></p><p><strong>latch.await();</strong></p><p><strong>for (CompletableFuture future : list) {</strong></p><p><strong>future.get();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>CyclicBarrier</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154201.png" alt="image-20210411154201095"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154224.png" alt="image-20210411154224811"></p><p>场景: 任务执行到一定阶段, 等待其他任务对齐。</p><p>示例: 等待所有人都到达，再一起开吃。</p><p><strong>重要方法 说明</strong></p><p><strong>public</strong> CyclicBarrier(<strong>int</strong> parties) 构造方法（需要等待的数量）</p><p><strong>public</strong> CyclicBarrier(<strong>int</strong> parties, Runnable barrierAction) 构造方法（需要等待的数量, 需要执行的任务）</p><p><strong>int</strong> await() 任务内部使用; 等待大家都到齐</p><p><strong>int</strong> await(<strong>long</strong> timeout, TimeUnit unit) 任务内部使用; 限时等待到齐</p><p><strong>void</strong> reset() 重新一轮</p><p><strong>CyclicBarrier 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154248.png" alt="image-20210411154248493"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154304.png" alt="image-20210411154304036"></p><p><strong>public static class CyclicBarrierTask</strong></p><p><strong>implements Runnable {</strong></p><p><strong>private CyclicBarrier barrier;</strong></p><p><strong>public CyclicBarrierTask(CyclicBarrier barrier) {</strong></p><p><strong>this.barrier = barrier;</strong></p><p><strong>}</strong></p><p><strong>@Override</strong></p><p><strong>public void run() {</strong></p><p><strong>Integer millis = new Random().nextInt(10000);</strong></p><p><strong>try {</strong></p><p><strong>TimeUnit.*MILLISECONDS*.sleep(millis);</strong></p><p><strong>this.barrier.await(); // 线程阻塞</strong></p><p><strong>System.*out*.println(“开吃:” +</strong></p><p><strong>Thread.*currentThread*().getName());</strong></p><p><strong>TimeUnit.*MILLISECONDS*.sleep(millis);</strong></p><p><strong>} catch (Exception e) {</strong></p><p><strong>e.printStackTrace();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>// 使用</strong></p><p><strong>public static void main(String[] args) throws Exception {</strong></p><p><strong>int num = 2; *// 如果数量过大会发生什么情况?*</strong></p><p><strong>CyclicBarrier barrier = new CyclicBarrier(num);</strong></p><p><strong>List<completablefuture> list = new ArrayList&lt;&gt;(num);</completablefuture></strong></p><p><strong>for (int i = 0; i &lt; num; i++) {</strong></p><p><strong>CompletableFuture<void> future =</void></strong></p><p><strong>CompletableFuture.*runAsync*(</strong></p><p><strong>new CyclicBarrierTask(barrier));</strong></p><p><strong>list.add(future);</strong></p><p><strong>}</strong></p><p><strong>for (CompletableFuture future : list) {</strong></p><p><strong>future.get();</strong></p><p><strong>}</strong></p><p><strong>barrier.reset();</strong></p><p><strong>}</strong></p><p><strong>CountDownLatch 与 CyclicBarrier 比较</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154324.png" alt="image-20210411154324159"></p><p><strong>CountDownLatch 与 CyclicBarrier 比较</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154342.png" alt="image-20210411154342722"></p><p><strong>Future/FutureTask/CompletableFuture</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154359.png" alt="image-20210411154359090"></p><p><strong>Future/FutureTask/CompletableFuture</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154415.png" alt="image-20210411154415016"></p><p>Future</p><p>FutureTask</p><p><strong>CompletableFuture</strong></p><p>单个线程/任务的执行结果</p><p>异步，回调，组合</p><p><strong>CompletableFuture</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154441.png" alt="image-20210411154441752"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411154501.png" alt="image-20210411154501421"></p><p><strong>重要方法 说明</strong></p><p><strong>static final boolean *useCommonPool*</strong> =</p><p>(ForkJoinPool.<em>getCommonPoolParallelism</em>() &gt; 1);</p><p>是否使用内置线程池</p><p><strong>static final</strong> Executor <strong><em>asyncPool\</em></strong> = <strong><em>useCommonPool\</em></strong> ?</p><p>ForkJoinPool.<em>commonPool</em>() : <strong>new</strong> ThreadPerTaskExecutor();</p><p>线程池</p><p>CompletableFuture<void> runAsync(Runnable runnable)； 异步执行【当心阻塞？】</void></p><p>CompletableFuture<void> runAsync(Runnable runnable, Executor</void></p><p>executor)</p><p>异步执行, 使用自定义线程池</p><p>T get() 等待执行结果</p><p>T get(<strong>long</strong> timeout, TimeUnit unit) 限时等待执行结果</p><p>T getNow(T valueIfAbsent) 立即获取结果(默认值)</p><p>……</p><h2 id="5-总结回顾与作业实践"><a href="#5-总结回顾与作业实践" class="headerlink" title="5.总结回顾与作业实践"></a>5.总结回顾与作业实践</h2><p><strong>第 7 节课总结回顾</strong></p><p><strong>Java 并发包</strong></p><p><strong>什么是锁</strong></p><p><strong>并发原子类</strong></p><p><strong>并发工具类</strong></p><p><strong>第7节课作业实践</strong></p><p>1、（选做）把示例代码，运行一遍，思考课上相关的问题。也可以做一些比较。</p><p>2、（必做）思考有多少种方式，在 main 函数启动一个新线程，运行一个方法，拿到这</p><p>个方法的返回值后，退出主线程？</p><p>写出你的方法，越多越好，提交到 Github。</p><p>一个简单的代码参考：</p><p><a href="https://github.com/kimmking/JavaCourseCodes/tree/main/03concurrency/030">https://github.com/kimmking/JavaCourseCodes/tree/main/03concurrency/030</a></p><p>1/src/main/java/java0/conc0303/Homework03.java</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week03-02 Java 并发编程（1）</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week03-02%20Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week03-02%20Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 6 课</p><h1 id="Java-并发编程（1）"><a href="#Java-并发编程（1）" class="headerlink" title="Java 并发编程（1）"></a>Java 并发编程（1）</h1><p><strong>目录</strong></p><p>1.多线程基础</p><p>2.Java 多线程*</p><p>3.线程安全*</p><p>4.线程池原理与应用*</p><p>5.第 6 课总结回顾与作业实践</p><h2 id="1-多线程基础"><a href="#1-多线程基础" class="headerlink" title="1.多线程基础"></a>1.多线程基础</h2><p><strong>为什么会有多线程</strong></p><p>本质原因是摩尔定律失效 -&gt; 多核+分布式时代的来临。</p><p>JVM、NIO 是不是都因为这个问题变复杂？</p><p>后面讲的分布式系统，也是这个原因。</p><p><strong>为什么会有多线程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151311.png" alt="image-20210411151311599"></p><p>多 CPU 核心意味着同时操作系统有更多的并行</p><p>计算资源可以使用。</p><p>操作系统以线程作为基本的调度单元。</p><p>单线程是最好处理不过的。</p><p>线程越多，管理复杂度越高。</p><p>跟我们程序员都喜欢自己单干一样。</p><p>《人月神话》里说加人可能干得更慢。</p><p>可见多核时代的编程更有挑战。</p><p><strong>Java 线程的创建过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151348.png" alt="image-20210411151348318"></p><p>线程与进程的区别是什么？</p><h2 id="2-Java-多线程"><a href="#2-Java-多线程" class="headerlink" title="2. Java 多线程*"></a>2. Java 多线程*</h2><p><strong>Thread 使用示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151410.png" alt="image-20210411151410010"></p><p><strong>public static void main(String[] args) {</strong></p><p><strong>Runnable task = new Runnable() {</strong></p><p><strong>@Override</strong></p><p><strong>public void run() {</strong></p><p><strong>try {</strong></p><p><strong>Thread.*sleep*(5000);</strong></p><p><strong>} catch (InterruptedException e) {</strong></p><p><strong>e.printStackTrace();</strong></p><p><strong>}</strong></p><p><strong>Thread t = Thread.*currentThread*();</strong></p><p><strong>System.*out*.println(“当前线程:” + t.getName());</strong></p><p><strong>}</strong></p><p><strong>};</strong></p><p><strong>Thread thread = new Thread(task);</strong></p><p><strong>thread.setName(“test-thread-1”);</strong></p><p><strong>thread.setDaemon(true);</strong></p><p><strong>thread.start();</strong></p><p><strong>}</strong></p><p>守护线程</p><p>启动方式</p><p>思考:</p><ol><li>输出结果是什么?</li><li>为什么?</li><li>有哪些方式可以修改?</li></ol><p><strong>基础接口 Runnable</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151428.png" alt="image-20210411151428476"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151443.png" alt="image-20210411151443613"></p><p>![image-20210411151712939](/Users/cutie/Library/Application Support/typora-user-images/image-20210411151712939.png)</p><p><strong>// 接口定义</strong></p><p><strong>public interface Runnable {</strong></p><p><strong>public abstract void run();</strong></p><p><strong>}</strong></p><p><strong>// 示例1</strong></p><p><strong>Runnable task = new Runnable() {</strong></p><p><strong>@Override</strong></p><p><strong>public void run() {</strong></p><p><strong>System.*out*.println(“业务逻辑…”);</strong></p><p><strong>}</strong></p><p><strong>};</strong></p><p><strong>// 示例2</strong></p><p><strong>public class XXXTask implements Runnable {</strong></p><p><strong>@Override</strong></p><p><strong>public void run() {</strong></p><p><strong>System.*out*.println(“执行逻辑…”);</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>// 重要实现</strong></p><p><strong>Thread implements Runnable …</strong></p><p>辨析:</p><p>Thread#start():创建新线程</p><p>Thread#run() : 本线程调用</p><p><strong>线程状态</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151736.png" alt="image-20210411151736456"></p><p><strong>Thread 类</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151757.png" alt="image-20210411151757749"></p><p>Thread: 线程</p><p><strong>重要属性/方法 说明</strong></p><p><strong>volatile</strong> String <strong>name</strong>; 线程名称 – 诊断分析使用</p><p><strong>boolean daemon</strong> = <strong>false</strong>; 后台守护线程标志 – 决定JVM优雅关闭</p><p>Runnable <strong>target</strong>; 任务(只能通过构造函数传入)</p><p><strong>synchronized void</strong> start() 【协作】启动新线程并自动执行</p><p><strong>void</strong> join() 【协作】等待某个线程执行完毕（来汇合）</p><p><strong>static native</strong> Thread currentThread(); 静态方法: 获取当前线程信息</p><p><strong>static native void</strong> sleep(<strong>long</strong> millis); 静态方法: 线程睡眠并让出CPU时间片</p><p><strong>wait &amp; notify</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151827.png" alt="image-20210411151827644"></p><p>辨析:</p><p>Thread.sleep: 释放 CPU</p><p>Object#wait : 释放锁</p><p><strong>Object# 方法 说明</strong></p><p><strong>void</strong> wait() 放弃锁+等待0ms+尝试获取锁;</p><p><strong>void</strong> wait(<strong>long</strong> timeout, <strong>int</strong> nanos) 放弃锁 + wait + 到时间自动唤醒/中途唤醒</p><p>(精度: nanos&gt;0则 timeout++)</p><p><strong>native void</strong> wait(<strong>long</strong> timeout); 放弃锁+ wait + 到时间自动唤醒/中途被唤醒</p><p>(唤醒之后需要自动获取锁)</p><p><strong>native void</strong> notify(); 发送信号通知1个等待线程</p><p><strong>native void</strong> notifyAll(); 发送信号通知所有等待线程</p><p><strong>Thread 的状态改变操作</strong></p><ol><li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入 TIMED_WAITING 状态，但不释放对象锁，millis 后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。</li><li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的 CPU 时间片，但不释放锁资源，由运行状态变为就绪状态，让 OS 再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield() 不会导致阻塞。该方法与sleep() 类似，只是不能由用户指定暂停多长时间。</li><li>t.join()/t.join(long millis)，当前线程里调用其它线程 t 的 join 方法，当前线程进入WAITING/TIMED_WAITING 状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者 millis 时间到，当前线程进入就绪状态。</li><li>obj.wait()，当前线程调用对象的 wait() 方法，当前线程释放对象锁，进入等待队列。依靠 notify()/notifyAll() 唤醒或者 wait(long timeout) timeout 时间到自动唤醒。</li><li>obj.notify() 唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll() 唤醒在此对象监视器上等待的所有线程。</li></ol><p><strong>Thread 的中断与异常处理</strong></p><ol><li>线程内部自己处理异常，不溢出到外层。</li><li>如果线程被 Object.wait, Thread.join 和 Thread.sleep 三种方法之一阻塞，此时调用该线程的interrupt() 方法，那么该线程将抛出一个 InterruptedException 中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用interrupt() 将不起作用，直到执行到 wait(),sleep(),join() 时,才马上会抛出InterruptedException。</li><li>如果是计算密集型的操作怎么办？分段处理，每个片段检查一下状态，是不是要终止。</li></ol><p><strong>Thread 状态</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151848.png" alt="image-20210411151847956"></p><p>1、本线程主动操作</p><p>2、被动：</p><p>遇到锁</p><p>被通知</p><h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3.线程安全*"></a>3.线程安全*</h2><p><strong>多线程执行会遇到什么问题?</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151915.png" alt="image-20210411151915291"></p><p><strong>竞态条件</strong></p><p>多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p><p><strong>临界区</strong></p><p>导致竞态条件发生的代码区称作临界区。</p><p><strong>共享与同步 (线程间通信)</strong></p><p>不进行恰当的控制，会导致线程安全问题</p><p><strong>多线程</strong></p><p><strong>同步/加锁</strong></p><p><strong>并发相关的性质</strong></p><p>原子性：原子操作，注意跟事务 ACID 里原子性的区别与联系</p><p>对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>只有语句1是原子操作。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151929.png" alt="image-20210411151929326"></p><p>多个线程并发问题</p><p>类似于</p><p>多个事务的并发问题</p><p><strong>并发相关的性质</strong></p><p>可见性：对于可见性，Java 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。</p><p>volatile 并不能保证原子性。</p><p><strong>并发相关的性质</strong></p><p>有序性：Java 允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以通过 volatile 关键字来保证一定的“有序性”（synchronized 和 Lock也可以）。</p><p>happens-before 原则（先行发生原则）：</p><ol><li>程序次序规则：一个线程内，按照代码先后顺序</li><li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作</li><li>Volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出 A 先于 C</li><li>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始</li></ol><p><strong>一个简单的实际例子</strong></p><p>最简单的例子</p><p>多线程计数</p><p>如何解决？</p><p><strong>synchronized 的实现</strong></p><ol><li>使用对象头标记字(Object monitor)</li><li>Synchronized 方法优化</li><li>偏向锁: BiaseLock</li></ol><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151949.png" alt="image-20210411151949775"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152007.png" alt="image-20210411152007576"></p><p><strong>对象头</strong></p><p><strong>标记字(1机器字)</strong></p><p><strong>Class指针(1机器字)</strong></p><p><strong>数组长度 (int)</strong></p><p><strong>数组独有</strong></p><p><strong>synchronized 使用示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152026.png" alt="image-20210411152026201"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152043.png" alt="image-20210411152043442"></p><p>思考: 哪种方式性能更高？</p><p>同步块 : 粒度小</p><p>同步方法: 专有指令</p><p><strong>public class SyncCounter {</strong></p><p><strong>private int sum = 0;</strong></p><p><strong>public synchronized int incrAndGet() {</strong></p><p><strong>return ++sum;</strong></p><p><strong>}</strong></p><p><strong>public int addAndGet() {</strong></p><p><strong>synchronized (this) {</strong></p><p><strong>return ++sum;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>public int getSum() {</strong></p><p><strong>return sum;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong><em>// 测试代码\</em></strong></p><p><strong>public static void testSyncCounter1() {</strong></p><p><strong>int loopNum = 100_0000;</strong></p><p><strong>SyncCounter counter = new SyncCounter();</strong></p><p><strong>IntStream.*range*(0, loopNum).parallel()</strong></p><p><strong>.forEach(i -&gt; counter.incrAndGet());</strong></p><p><strong>}</strong></p><p><strong>volatile</strong></p><ol><li>每次读取都强制从主内存刷数据</li><li>适用场景： 单个线程写；多个线程读</li><li>原则： 能不用就不用，不确定的时候也不用</li><li>替代方案： Atomic 原子操作类</li></ol><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152102.png" alt="image-20210411152101929"></p><p>那么，语句1和2，不会被重排到3的后面，4和5也不会到前面。</p><p>同时可以保证1和2的结果是对3、4、5可见。</p><p><strong>final</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152116.png" alt="image-20210411152115930"></p><p>思考: final 声明的引用类型与原生类型在处理时有什么区别?</p><p>Java 里的常量替换。写代码最大化用 final 是个好习惯。</p><p><strong>**final 定义类型 说明</strong></p><p>final class XXX 不允许继承</p><p>final 方法 不允许 Override</p><p>final 局部变量 不允许修改</p><p>final 实例属性</p><p>构造函数/初始化块/<init>之后不允许变更；只能赋值一次</init></p><p><strong>安全发布</strong>: 构造函数结束返回时，final 域最</p><p>新的值被保证对其他线程可见</p><p>final static 属性 <clinit>静态块执行后不允许变更；只能赋值一次</clinit></p><h2 id="4-线程池原理与应用"><a href="#4-线程池原理与应用" class="headerlink" title="4.线程池原理与应用*"></a>4.线程池原理与应用*</h2><p><strong>线程池</strong></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152131.png" alt="image-20210411152131233" style="zoom:33%;"><ol><li>Excutor: 执行者 – 顶层接口</li><li>ExcutorService: 接口 API</li><li>ThreadFactory: 线程工厂</li><li>Excutors: 工具类</li></ol><p>线程池 A</p><p>线程 a-1</p><p>线程 a-2</p><p>线程 a-n</p><p><strong>Executor – 执行者</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152200.png" alt="image-20210411152200089"></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152214.png" alt="image-20210411152214777" style="zoom:50%;"><p>线程池从功能上看，就是一个任务执行器</p><p>submit 方法 -&gt; 有返回值，用 Future 封装</p><p>execute 方法 -&gt; 无返回值</p><p>submit 方法还异常可以在主线程中 catch 到。</p><p>execute 方法执行任务是捕捉不到异常的。</p><p><strong>重要方法 说明</strong></p><p><strong>void</strong> execute(Runnable command); 执行可运行的任务</p><p><strong>ExecutorService</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152237.png" alt="image-20210411152237601"></p><p><strong>重要方法 说明</strong></p><p><strong>void</strong> execute(Runnable command); 执行可运行的任务</p><p><strong>void</strong> shutdown(); 关闭线程池</p><p>List<runnable> shutdownNow(); 立即关闭</runnable></p><p>Future&lt;?&gt; submit(Runnable task); 提交任务; 允许获取执行结果</p><p><t> Future<t> submit(Runnable task, T result); 提交任务（指定结果）; 控制|获取执行结果</t></t></p><p><t> Future<t> submit(Callable<t> task); 提交任务; 允许控制任务和获取执行结果</t></t></t></p><p>shutdown()：停止接收新任务，原来的任务继续执行</p><p>shutdownNow()：停止接收新任务，原来的任务停止执行</p><p>awaitTermination(long timeOut, TimeUnit unit)：当前线程阻塞</p><p><strong>ThreadFactory</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152257.png" alt="image-20210411152257071"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152312.png" alt="image-20210411152312717"></p><p>ThreadPoolExecutor 提交任务逻辑:</p><ol><li>判断 corePoolSize 【创建】</li><li>加入 workQueue</li><li>判断 maximumPoolSize 【创建】</li><li>执行拒绝策略处理器</li></ol><p><strong>重要方法 说明</strong></p><p>Thread newThread(Runnable r); 创建新线程</p><p><strong>线程池参数</strong></p><p>缓冲队列</p><p>BlockingQueue 是双缓冲队列。BlockingQueue 内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</p><ol><li>ArrayBlockingQueue:规定大小的 BlockingQueue，其构造必须指定大小。其所含的对象是 FIFO 顺序排序的。</li><li>LinkedBlockingQueue:大小不固定的 BlockingQueue，若其构造时指定大小，生成的BlockingQueue 有大小限制，不指定大小，其大小有 Integer.MAX_VALUE 来决定。其所含的对象是 FIFO 顺序排序的。</li><li>PriorityBlockingQueue:类似于 LinkedBlockingQueue，但是其所含对象的排序不是 FIFO，而是依据对象的自然顺序或者构造函数的 Comparator 决定。</li><li>SynchronizedQueue:特殊的 BlockingQueue，对其的操作必须是放和取交替完成。</li></ol><p><strong>线程池参数</strong></p><p>拒绝策略</p><ol><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出 RejectedExecutionException</li></ol><p>异常。</p><ol><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提</li></ol><p>交被拒绝的任务</p><ol><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任</li></ol><p>务</p><p><strong>ThreadFactory 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152340.png" alt="image-20210411152340312"></p><p><strong>public class CustomThreadFactory implements ThreadFactory {</strong></p><p><strong>private AtomicInteger serial = new AtomicInteger(0);</strong></p><p><strong>@Override</strong></p><p><strong>public Thread newThread(Runnable r) {</strong></p><p><strong>Thread thread = new Thread(r);</strong></p><p><strong>thread.setDaemon(true); *// 根据需要，设置守护线程*</strong></p><p><strong>thread.setName(“CustomeThread-“ + serial.getAndIncrement());</strong></p><p><strong>return thread;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>ThreadPoolExecutor</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152405.png" alt="image-20210411152405737"></p><p><strong>重要属性/方法 说明</strong></p><p><strong>int corePoolSize</strong>; 核心线程数</p><p><strong>int maximumPoolSize</strong>; 最大线程数</p><p>ThreadFactory <strong>threadFactory</strong>; 线程创建工厂</p><p>BlockingQueue<runnable> <strong>workQueue</strong>; 工作队列</runnable></p><p>RejectedExecutionHandler <strong>handler</strong>; 拒绝策略处理器</p><p><strong>void</strong> execute(Runnable command) 执行</p><p>Future&lt;?&gt; submit(Runnable task) 提交任务</p><p>submit(Runnable task, T result) 提交任务</p><p>submit(Callable<t> task) 提交任务</t></p><p><strong>ThreadPoolExecutor 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152432.png" alt="image-20210411152432666"></p><p><strong>public static ThreadPoolExecutor initThreadPoolExecutor() {</strong></p><p><strong>int coreSize = Runtime.*getRuntime*().availableProcessors();</strong></p><p><strong>int maxSize = Runtime.*getRuntime*().availableProcessors() * 2;</strong></p><p><strong>BlockingQueue<runnable> workQueue = new</runnable></strong></p><p><strong>LinkedBlockingDeque&lt;&gt;(500);</strong></p><p><strong>CustomThreadFactory threadFactory = new CustomThreadFactory();</strong></p><p><strong>ThreadPoolExecutor executor = new ThreadPoolExecutor(coreSize,</strong></p><p><strong>maxSize,</strong></p><p><strong>1, TimeUnit.*MINUTES*, workQueue, threadFactory);</strong></p><p><strong>return executor;</strong></p><p><strong>}</strong></p><p><strong>创建线程池方法</strong></p><p><strong>1. newSingleThreadExecutor</strong></p><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任</p><p>务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务</p><p>的执行顺序按照任务的提交顺序执行。</p><p><strong>2.newFixedThreadPool</strong></p><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线</p><p>程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充</p><p>一个新线程。</p><p><strong>3. newCachedThreadPool</strong></p><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，</p><p>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添</p><p>加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者</p><p>说JVM）能够创建的最大线程大小。</p><p><strong>4.newScheduledThreadPool</strong></p><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><p><strong>Callable – 基础接口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152535.png" alt="image-20210411152535775"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152451.png" alt="image-20210411152451530"></p><p>对比:</p><p>Runnable#run()没有返回值</p><p>Callable#call()方法有返回值</p><p><strong>重要方法 说明</strong></p><p>V call() <strong>throws</strong> Exception; 调用执行</p><p><strong>public class RandomSleepTask implements</strong></p><p><strong>Callable<integer> {</integer></strong></p><p><strong>@Override</strong></p><p><strong>public Integer call() throws Exception {</strong></p><p><strong>Integer sleep = new</strong></p><p><strong>Random().nextInt(10000);</strong></p><p><strong>TimeUnit.*MILLISECONDS*.sleep(sleep);</strong></p><p><strong>return sleep;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>Future – 基础接口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411152552.png" alt="image-20210411152552877"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411153224.png" alt="image-20210411153224109"></p><p><strong>重要方法 说明</strong></p><p><strong>boolean</strong> cancel(<strong>boolean</strong></p><p>mayInterruptIfRunning);</p><p>取消任务</p><p>（执行时是否打断）</p><p><strong>boolean</strong> isCancelled(); 是否被取消</p><p><strong>boolean</strong> isDone(); 是否执行完毕</p><p>V get()</p><p><strong>throws</strong> InterruptedException,</p><p>ExecutionException;</p><p>获取执行结果</p><p>V get(<strong>long</strong> timeout, TimeUnit</p><p>unit)</p><p><strong>throws</strong> InterruptedException,</p><p>ExecutionException,</p><p>TimeoutException;</p><p>限时获取执行结果</p><p><strong>public static void main(String[] args) throws Exception {</strong></p><p><strong>Callable<integer> task = new RandomSleepTask();</integer></strong></p><p><strong>ExecutorService executorService =</strong></p><p><strong><em>initThreadPoolExecutor\</em>();</strong></p><p><strong>Future<integer> future1 = executorService.submit(task);</integer></strong></p><p><strong>Future<integer> future2 = executorService.submit(task);</integer></strong></p><p><strong><em>// 等待执行结果\</em></strong></p><p><strong>Integer result1 = future1.get(1, TimeUnit.*SECONDS*);</strong></p><p><strong>Integer result2 = future2.get(1, TimeUnit.*SECONDS*);</strong></p><p><strong>System.*out*.println(“result1=” + result1);</strong></p><p><strong>System.*out*.println(“result2=” + result2);</strong></p><p><strong>}</strong></p><h2 id="5-总结回顾与作业实践"><a href="#5-总结回顾与作业实践" class="headerlink" title="5.总结回顾与作业实践"></a>5.总结回顾与作业实践</h2><p><strong>第六节课总结回顾</strong></p><p><strong>多线程基础</strong></p><p><strong>Java 多线程</strong></p><p><strong>线程安全</strong></p><p><strong>线程池原理与应用</strong></p><p><strong>第六节课作业实践</strong></p><p>1、（可选）跑一跑课上的各个例子，加深对多线程的理解</p><p>2、（可选）完善网关的例子，试着调整其中的线程池参数</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week03-01 Netty 原理与 API 网关</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week03-01%20Netty%20%E5%8E%9F%E7%90%86%E4%B8%8E%20API%20%E7%BD%91%E5%85%B3/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week03-01%20Netty%20%E5%8E%9F%E7%90%86%E4%B8%8E%20API%20%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 5 课</p><h1 id="Netty-原理与-API-网关"><a href="#Netty-原理与-API-网关" class="headerlink" title="Netty 原理与 API 网关"></a>Netty 原理与 API 网关</h1><p><strong>目录</strong></p><ol><li>再谈谈什么是高性能</li><li>Netty 如何实现高性能</li><li>Netty 网络程序优化</li><li>典型应用：API 网关</li><li>自己动手实现 API 网关</li><li>第 5 课总结回顾与作业实践</li></ol><h2 id="1-再谈谈什么是高性能"><a href="#1-再谈谈什么是高性能" class="headerlink" title="1.再谈谈什么是高性能"></a>1.再谈谈什么是高性能</h2><p><strong>什么是高性能？</strong></p><p>大家思考一下，什么是高性能？</p><p>高并发用户（Concurrent Users）</p><p>高吞吐量（Throughout）</p><p>低延迟（Latency）</p><p><strong>什么是高性能？</strong></p><p>大家思考一下，什么是高性能？</p><p>![image-20210411145651138](/Users/cutie/Library/Application Support/typora-user-images/image-20210411145651138.png)</p><p>高并发用户（Concurrent Users）</p><p><strong>什么是高性能？</strong></p><p>大家思考一下，什么是高性能？</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411145706.png" alt="image-20210411145706116"></p><p>高吞吐量（Throughout）</p><p><strong>什么是高性能？</strong></p><p>大家思考一下，什么是高性能？</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411145722.png" alt="image-20210411145722636"></p><p>低延迟（Latency）</p><p><strong>高性能的另一面</strong></p><p>如果实现了高性能，有什么副作用呢？</p><p>系统复杂度 x10以上</p><p>建设与维护成本++++</p><p>故障或 BUG 导致的破坏性 x10以上</p><p><strong>应对策略</strong></p><p>稳定性建设（混沌工程）：</p><p>1、容量</p><p>2、爆炸半径</p><p>3、工程方面积累与改进</p><h2 id="2-Netty-如何实现高性能"><a href="#2-Netty-如何实现高性能" class="headerlink" title="2. Netty 如何实现高性能"></a>2. Netty 如何实现高性能</h2><p><strong>Netty 概览</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411145853.png" alt="image-20210411145853298"></p><p>网络应用开发框架</p><ol><li>异步</li><li>事件驱动</li><li>基于 NIO</li></ol><p>适用于:</p><p>服务端</p><p>客户端</p><p>TCP/UDP</p><p><strong>从 Socket IO 到 NIO</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411145911.png" alt="image-20210411145911703"></p><p><strong>从 Socket IO 到 NIO–BIO多线程模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411145932.png" alt="image-20210411145932251"></p><p><strong>回顾一下事件处理机制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411145952.png" alt="image-20210411145952719"></p><p><strong>从事件处理机制到 Reactor 模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150014.png" alt="image-20210411150014406"></p><p><strong>Reactor 模式首先是事件驱动的，有一个或者多个并发输入源，有一个 Service Handler</strong></p><p><strong>和多个EventHandlers。</strong></p><p><strong>这个 Service Handler 会同步的将输入的请求多路复用的分发给相应的 Event Handler。</strong></p><p><strong>从 Reactor 模型到 Netty NIO–01</strong></p><p><strong>Reactor 单线程模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150045.png" alt="image-20210411150045073"></p><p><strong>Doug lea 《Scalable IO in Java》</strong></p><p><strong>从 Reactor 模型到 Netty NIO–01</strong></p><p><strong>Reactor 单线程模型</strong></p><p>![image-20210411150102664](/Users/cutie/Library/Application Support/typora-user-images/image-20210411150102664.png)</p><p><strong>从 Reactor 模型到 Netty NIO–02</strong></p><p><strong>Reactor 多线程模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150122.png" alt="image-20210411150122605"></p><p><strong>从 Reactor 模型到 Netty NIO–02</strong></p><p><strong>Reactor 多线程模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150143.png" alt="image-20210411150143907"></p><p><strong>从 Reactor 模型到 Netty NIO–03</strong></p><p><strong>Reactor 主从模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150204.png" alt="image-20210411150204753"></p><p><strong>从 Reactor 模型到 Netty NIO–03</strong></p><p><strong>Reactor 主从模型</strong></p><p>![image-20210411150238906](/Users/cutie/Library/Application Support/typora-user-images/image-20210411150238906.png)</p><p><strong>Netty 对三种模式的支持</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150301.png" alt="image-20210411150301450"></p><p><strong>Netty 启动和处理流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150318.png" alt="image-20210411150318632"></p><p><strong>Netty 线程模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150340.png" alt="image-20210411150340396"></p><p><strong>Netty 核心对象</strong></p><p><strong>到底什么是EventLoop</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150401.png" alt="image-20210411150401469"></p><p><strong>Netty 运行原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150417.png" alt="image-20210411150417915"></p><p><strong>关键对象</strong></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150436.png" alt="image-20210411150436164" style="zoom:50%;"><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150455.png" alt="image-20210411150455710"></p><p>Bootstrap: 启动线程，开启 socket</p><p>EventLoopGroup</p><p>EventLoop</p><p>SocketChannel: 连接</p><p>ChannelInitializer: 初始化</p><p>ChannelPipeline: 处理器链</p><p>ChannelHandler: 处理器</p><p><strong>ChannelPipeline</strong></p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150514.png" alt="image-20210411150514271" style="zoom:50%;"><p><strong>Event &amp; Handler</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150534.png" alt="image-20210411150534788"></p><p>入站事件：</p><p>通道激活和停用</p><p>读操作事件</p><p>异常事件</p><p>用户事件</p><p>出站事件：</p><p>打开连接</p><p>关闭连接</p><p>写入数据</p><p>刷新数据</p><p>Netty 应用组成: • 网络事件</p><p>应用程序逻辑事件</p><p>事件处理程序</p><p>事件处理程序接口:</p><p>ChannelHandler</p><p>ChannelOutboundHandler</p><p>ChannelInboundHandler</p><p>适配器（空实现，需要继承使用）：</p><p>ChannelInboundHandlerAdapter</p><p>ChannelOutboundHandlerAdapter</p><h2 id="3-Netty-网络程序优化"><a href="#3-Netty-网络程序优化" class="headerlink" title="3. Netty 网络程序优化"></a>3. Netty 网络程序优化</h2><p><strong>粘包与拆包</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150550.png" alt="image-20210411150550823"></p><p>都是人为问题</p><p>ByteToMessageDecoder 提供的一些常见的实现类：</p><p>1.FixedLengthFrameDecoder：定长协议解码器，我们可以指定固定的字节数算一个完整的报文</p><p>2.LineBasedFrameDecoder：行分隔符解码器，遇到\n 或者\r\n，则认为是一个完整的报文</p><p>3.DelimiterBasedFrameDecoder：分隔符解码器，分隔符可以自己指定</p><p>4.LengthFieldBasedFrameDecoder：长度编码解码器，将报文划分为报文头/报文体</p><p>5.JsonObjectDecoder：json 格式解码器，当检测到匹配数量的“{” 、”}”或”[””]”时，则认为是一个完整的 json 对象或者 json 数组</p><p><strong>Nagle 与 TCP_NODELAY</strong></p><p><strong>MTU: Maxitum Transmission Unit 最大传输单元</strong></p><p><strong>MSS: Maxitum Segment Size 最大 分段大小</strong></p><p><strong>1500 Byte</strong></p><p><strong>1460 Byte</strong></p><p><strong>网络拥堵与 Nagle 算法优化 TCP_NODELAY</strong></p><p><strong>优化条件： 缓冲区满 和 达到超时</strong></p><p><strong>连接优化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150611.png" alt="image-20210411150611210"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150628.png" alt="image-20210411150628518"></p><p>注意 TCP 与 UDP 区别</p><p><strong>Netty 优化</strong></p><p><strong>1、不要阻塞 EventLoop</strong></p><p><strong>2、系统参数优化</strong></p><p><strong>ulimit -a /proc/sys/net/ipv4/tcp_fin_timeout, TcpTimedWaitDelay</strong></p><p><strong>3、缓冲区优化</strong></p><p><strong>SO_RCVBUF/SO_SNDBUF/SO_BACKLOG/ REUSEXXX</strong></p><p><strong>4、心跳周期优化</strong></p><p><strong>心跳机制与短线重连</strong></p><p><strong>5、内存与 ByteBuffer 优化</strong></p><p><strong>DirectBuffer与HeapBuffer</strong></p><p><strong>6、其他优化</strong></p><p><strong>ioRatio</strong></p><p><strong>Watermark</strong></p><p><strong>TrafficShaping</strong></p><ol><li>典型应用：API 网关</li></ol><p><strong>典型应用：API 网关</strong></p><p>网关的结构和功能？</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150647.png" alt="image-20210411150744"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150734.png" alt="image-20210411150734343"></p><p><strong>典型应用：API 网关</strong></p><p>网关的结构和功能？</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150817.png" alt="image-20210411150817278"></p><p><strong>典型应用：API 网关</strong></p><p>网关的分类</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150835.png" alt="image-20210411150834941"></p><p><strong>网关典型应用：API 网关</strong></p><p>Zuul</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150906.png" alt="image-20210411150906704"></p><p><strong>Zuul 是 Netflix 开源的 API 网关系统，它的主要设计目标是动态路由、监控、弹性和安全。</strong></p><p><strong>Zuul 的内部原理可以简单看做是很多不同功能 filter 的集合，最主要的就是 pre、routing、post 这三种过滤器，分别作用于调用业务服务 API 之前的请求处理、直接响应、调用业务服务 API 之后的响应处理。</strong></p><p><strong>典型应用：API 网关</strong></p><p>Zuul2</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150925.png" alt="image-20210411150925545"></p><p>Zuul 2.x 是基于 Netty 内核重构的版本。</p><p>核心功能：</p><p>1.Service Discovery</p><p>2.Load Balancing</p><p>3.Connection Pooling</p><p>4.Status Categories</p><p>5.Retries</p><p>6.Request Passport</p><p>7.Request Attempts</p><p>8.Origin Concurrency Protection</p><p>9.HTTP/2</p><p>10.Mutual TLS</p><p>11.Proxy Protocol</p><p>12.GZip</p><p>13.WebSockets</p><p><strong>典型应用：API 网关</strong></p><p>Spring Cloud Gateway</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411150950.png" alt="image-20210411150950457"></p><p><strong>典型应用：API 网关</strong></p><p>网关对比</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151012.png" alt="image-20210411151011916"></p><h2 id="5-自己动手实现-API-网关"><a href="#5-自己动手实现-API-网关" class="headerlink" title="5. 自己动手实现 API 网关"></a>5. 自己动手实现 API 网关</h2><p><strong>自己动手实现 API 网关</strong></p><p>最简单的网关–gateway 1.0</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151039.png" alt="image-20210411151039161"></p><p><strong>自己动手实现 API 网关</strong></p><p>最简单的网关–gateway 2.0</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151057.png" alt="image-20210411151057301"></p><p><strong>自己动手实现 API 网关</strong></p><p>最简单的网关–gateway 3.0</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151115.png" alt="image-20210411151115419"></p><p><strong>自己动手实现 API 网关</strong></p><p>架构设计</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411151141.png" alt="image-20210411151140991"></p><p>设计：技术复杂度与业务复杂度</p><p>抽象：概念理清、正确命名</p><p>组合：组件之间的相互关系</p><ol><li>总结回顾与作业实践</li></ol><p><strong>第5节课总结回顾</strong></p><p>再谈谈什么是高性能</p><p>Netty 如何实现高性能</p><p>Netty 网络程序优化</p><p>典型应用：API 网关</p><p>自己动手实现 API 网关</p><p><strong>第5节课作业实践</strong></p><p>1、按今天的课程要求，实现一个网关，</p><p>基础代码可以 fork：<a href="https://github.com/kimmking/JavaCourseCodes">https://github.com/kimmking/JavaCourseCodes</a></p><p>02nio/nio02 文件夹下</p><p>实现以后，代码提交到 Github。</p><p>1）周四作业：整合你上次作业的httpclient/okhttp；</p><p>2）周四作业（可选）:使用 netty 实现后端 http 访问（代替上一步骤）；</p><p>3）周六作业：实现过滤器</p><p>4）周六作业（可选）：实现路由</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week02-02 NIO 模型与 Netty 入门</title>
      <link href="2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week02-02%20NIO%20%E6%A8%A1%E5%9E%8B%E4%B8%8E%20Netty%20%E5%85%A5%E9%97%A8/"/>
      <url>2021/04/11/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week02-02%20NIO%20%E6%A8%A1%E5%9E%8B%E4%B8%8E%20Netty%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><p>第 4 课</p><h1 id="NIO-模型与-Netty-入门"><a href="#NIO-模型与-Netty-入门" class="headerlink" title="NIO 模型与 Netty 入门"></a>NIO 模型与 Netty 入门</h1><p><strong>目录</strong></p><ol><li>Java Socket 编程*：如何基于 Socket 实现 Server</li><li>深入讨论 IO*：Server 处理时到底发生了什么</li><li>IO 模型与相关概念*：怎么理解 NIO</li><li>Netty 框架简介：什么是 Netty</li><li>Netty 使用示例*：如何使用 Netty 实现 NIO</li><li>第 4 课总结回顾与作业实践</li></ol><h2 id="1-Java-Socket-编程"><a href="#1-Java-Socket-编程" class="headerlink" title="1. Java Socket 编程"></a>1. Java Socket 编程</h2><p><strong>服务器通信原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135102.png" alt="image-20210411135102226"></p><p><strong>Java 实现一个最简的 HTTP 服务器01</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135125.png" alt="image-20210411135125401"></p><ol><li>创建一个 ServerSocket</li><li>绑定8801端口</li><li>当有客户端请求时通过 accept 方法拿</li></ol><p>到 Socket，进而可以进行处理</p><ol><li>sleep 20ms，模拟业务操作(IO)</li><li>模拟输出 HTTP 报文头和 hello</li><li>关闭 socket</li></ol><p>可以浏览器访问 <a href="http://localhost:8801/">http://localhost:8801</a></p><p>思考一下有什么问题？</p><p><strong>Java 实现一个最简的 HTTP 服务器01</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135143.png" alt="image-20210411135143610"></p><p>设置-Xmx512 然后启动</p><p>压测：</p><p>sb -u <a href="http://localhost:8801/">http://localhost:8801</a> -c 40 -N 30</p><p>wrk -c 40 -d30s <a href="http://localhost:8801/">http://localhost:8801</a></p><p><strong>Java 实现一个最简的 HTTP 服务器02</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135159.png" alt="image-20210411135159518"></p><p>改进一下，绑定8802端口</p><p>每个客户端请求进来时创建一个线程</p><p>有什么问题？</p><p><strong>Java 实现一个最简的 HTTP 服务器02</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135213.png" alt="image-20210411135213797"></p><p>设置-Xmx512 然后启动</p><p>压测：</p><p>sb -u <a href="http://localhost:8802/">http://localhost:8802</a> -c 40 -N 30</p><p>wrk -c 40 -d30s <a href="http://localhost:8802/">http://localhost:8802</a></p><p><strong>Java 实现一个最简的 HTTP 服务器03</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135233.png" alt="image-20210411135233694"></p><p>再改进一下，绑定8802端口</p><p>创建一个固定大小的线程池来处理</p><p>why？</p><p>有什么问题？</p><p><strong>Java 实现一个最简的 HTTP 服务器02</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135251.png" alt="image-20210411135251887"></p><p>设置-Xmx512 然后启动</p><p>压测：</p><p>sb -u <a href="http://localhost:8803/">http://localhost:8803</a> -c 40 -N 30</p><p>wrk -c 40 -d30s <a href="http://localhost:8803/">http://localhost:8803</a></p><p><strong>总结一下，到目前为止，我们做了什么</strong></p><p><strong>单线程处理 socket</strong></p><p><strong>每个请求一个线程</strong></p><p><strong>固定大小线程池处理</strong></p><h2 id="2-深入讨论-IO-通信"><a href="#2-深入讨论-IO-通信" class="headerlink" title="2. 深入讨论 IO 通信"></a>2. 深入讨论 IO 通信</h2><p><strong>服务器通信过程分析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135307.png" alt="image-20210411135307539"></p><p>仔细分析一下，</p><p>这个过程中，存在两种类型操作：</p><p>CPU 计算/业务处理</p><p>IO 操作与等待/网络、磁盘、数据库</p><p>想想我们前面的例子为什么创建大量</p><p>线程？</p><p><strong>服务器通信过程分析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135329.png" alt="image-20210411135329037"></p><p>对于一个 IO 相关应用来说，</p><p>例如通过网络访问，服务器端读取本</p><p>地文件，再返回给客户端（如左图）。</p><p>这种情况下，</p><p>大部分 CPU 等资源，可能就被浪费了。</p><p><strong>再深入一层的看问题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135347.png" alt="image-20210411135347732"></p><p>不仅面临线程 /CPU 的问题，</p><p>还要面对数据来回复制的问题。</p><p>这个一来，对每个业务处理过程，使</p><p>用一个线程以一竿子通到底的方式，</p><p>性能不是最优的，还有提升空间。</p><p>考虑一下，理想状态，是什么样的？</p><p>流水线</p><h2 id="3-NIO-模型与相关概念"><a href="#3-NIO-模型与相关概念" class="headerlink" title="3. NIO 模型与相关概念"></a>3. NIO 模型与相关概念</h2><p><strong>通信模型</strong></p><p>考虑一下：</p><p>阻塞、非阻塞，</p><p>同步、异步，</p><p>有什么关系和区别？</p><p>同步异步 是通信模式。</p><p>阻塞、非阻塞 是 线程处理模式。</p><p><strong>五种 IO 模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135402.png" alt="image-20210411135402320"></p><p>基本上都是同步的</p><p><strong>IO 模型01</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135429.png" alt="image-20210411135428944"></p><p>阻塞式 IO、BIO</p><p>一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接</p><p><strong>IO 模型01</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135445.png" alt="image-20210411135445038"></p><p><strong>IO 模型02</strong></p><p>非阻塞式 IO</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135459.png" alt="image-20210411135459689"></p><p>和阻塞 IO 类比，内核会立即返回，返回后获得足够的 CPU 时间继续做其它的事情。</p><p>用户进程第一个阶段不是阻塞的,需要不断的主动询问 kernel 数据好了没有；第二个阶段依然总是阻塞的。</p><p><strong>IO 模型02</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135526.png" alt="image-20210411135526065"></p><p><strong>IO 模型03</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135545.png" alt="image-20210411135545242"></p><p>IO 多路复用(IO multiplexing)，也称事件驱动 IO(event-driven IO)，就是在单个线程里同时监控多个套接字，通过select 或 poll 轮询所负责的所有socket，当某个 socket 有数据到达了，就通知用户进程。</p><p>IO 复用同非阻塞 IO 本质一样，不过利用了新的 select 系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞 IO 还多了一个系统调用开销，不过因为可以支持多路 IO，才算提高了效率。</p><p>进程先是阻塞在 select/poll 上，再是阻塞在读操作的第二个阶段上。</p><p><strong>IO 模型03</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135605.png" alt="image-20210411135605051"></p><p>select/poll 的几大缺点：</p><p>（1）每次调用 select，都需要把 fd 集合从用户态拷贝到</p><p>内核态，这个开销在 fd 很多时会很大</p><p>（2）同时每次调用 select 都需要在内核遍历传递进来的</p><p>所有 fd，这个开销在 fd 很多时也很大</p><p>（3）select 支持的文件描述符数量太小了，默认是1024</p><p>epoll（Linux 2.5.44内核中引入,2.6内核正式引入,可被用</p><p>于代替 POSIX select 和 poll 系统调用）：</p><p>（1）内核与用户空间共享一块内存</p><p>（2）通过回调解决遍历问题</p><p>（3）fd 没有限制，可以支撑10万连接</p><p><strong>IO 模型03</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135624.png" alt="image-20210411135624732"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135645.png" alt="image-20210411135645077"></p><p><strong>IO 模型04</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135700.png" alt="image-20210411135700770"></p><p>信号驱动 I/O</p><p>信号驱动 IO 与 BIO 和 NIO 最大的区别就在于，在 IO 执行的数据准备阶段，不会阻塞用户进程。</p><p>如图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用 recvfrom，去查收数据。</p><p><strong>IO 模型05</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135911.png" alt="image-20210411135911019"></p><p>异步式 IO</p><p>异步 IO 真正实现了 IO 全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程 IO 操作执行完毕（与 SIGIO 相比，一个是发送信号告诉用户进程数据准备完毕，一个是 IO执行完毕）。</p><p>windows 的 IOCP 模型</p><p><strong>IO 模型05</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135928.png" alt="image-20210411135928612"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411135944.png" alt="image-20210411135944480"></p><p>一个场景，去打印店打印文件。</p><p>同步阻塞</p><p>直接排队，别的啥也干不成，直到轮</p><p>到你使用打印机了，自己打印文件</p><p>Reactor</p><p>拿个号码，回去该干嘛干嘛，等轮到</p><p>你使用打印机了，店主通知你来用打</p><p>印机，打印文件</p><p>Proactor</p><p>拿个号码，回去该干嘛干嘛，等轮到</p><p>你使用打印机了，店主直接给你打印</p><p>好文件，通知你来拿。</p><ol><li>Netty 框架简介</li></ol><p><strong>Netty 概览</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411140002.png" alt="image-20210411140001953"></p><p>网络应用开发框架</p><ol><li>异步</li><li>事件驱动</li><li>基于 NIO</li></ol><p>适用于:</p><p>服务端</p><p>客户端</p><p>TCP/UDP</p><p>Netty官网: <a href="http://netty.io/">netty.io</a></p><p><strong>Netty 特性</strong></p><p>高性能的协议服务器:</p><p>高吞吐</p><p>低延迟</p><p>低开销</p><p>零拷贝</p><p>可扩容</p><p>松耦合: 网络和业务逻辑分离</p><p>使用方便、可维护性好</p><p><strong>兼容性</strong></p><p>JDK 兼容性:</p><p>Netty 3.x: JDK5</p><p>Netty 4.x: JDK6</p><p>Netty 5.x: 已废弃</p><p>协议兼容性:</p><p>兼容大部分通用协议</p><p>支持自定义协议</p><p>嵌入式:</p><p>HTTP Server</p><p>HTTPS Server</p><p>WebSocket Server</p><p>TCP Server</p><p>UDP Server</p><p>In VM Pipe</p><p>Netty vs. Java EE?</p><p><strong>基本概念</strong></p><p><strong>Channel</strong></p><p>通道，Java NIO 中的基础概念,代表一个打开的连接,可执行读取/写入 IO 操作。</p><p>Netty 对 Channel 的所有 IO 操作都是非阻塞的。</p><p><strong>ChannelFuture</strong></p><p>Java 的 Future 接口，只能查询操作的完成情况, 或者阻塞当前线程等待操作完成。</p><p>Netty 封装一个 ChannelFuture 接口。</p><p>我们可以将回调方法传给 ChannelFuture，在操作完成时自动执行。</p><p><strong>Event &amp; Handler</strong></p><p>Netty 基于事件驱动，事件和处理器可以关联到入站和出站数据流。</p><p><strong>Encoder &amp; Decoder</strong></p><p>处理网络 IO 时，需要进行序列化和反序列化, 转换 Java 对象与字节流。</p><p>对入站数据进行解码, 基类是 ByteToMessageDecoder。</p><p>对出站数据进行编码, 基类是 MessageToByteEncoder。</p><p><strong>ChannelPipeline</strong></p><p>数据处理管道就是事件处理器链。</p><p>有顺序、同一 Channel 的出站处理器和入站处理器在同一个列表中。</p><p><strong>Event &amp; Handler</strong></p><p>入站事件：</p><p>通道激活和停用</p><p>读操作事件</p><p>异常事件</p><p>用户事件</p><p>出站事件：</p><p>打开连接</p><p>关闭连接</p><p>写入数据</p><p>刷新数据</p><p>Netty 应用组成: • 网络事件</p><p>应用程序逻辑事件</p><p>事件处理程序</p><p>事件处理程序接口:</p><p>ChannelHandler</p><p>ChannelOutboundHandler</p><p>ChannelInboundHandler</p><p>适配器（空实现，需要继承使用）：</p><p>ChannelInboundHandlerAdapter</p><p>ChannelOutboundHandlerAdapter</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411140024.png" alt="image-20210411140024533"></p><ol><li>Netty 使用示例</li></ol><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411140044.png" alt="image-20210411140044810"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411140103.png" alt="image-20210411140103056"></p><p><strong>demoNetty 简单例子</strong></p><p>使用 Netty 改写</p><p>最开始的例子</p><p>然后，压测一下效果如何。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411140119.png" alt="image-20210411140119329"></p><ol><li>总结回顾与作业实践</li></ol><p><strong>第四节课总结回顾</strong></p><p><strong>Java Socket 编程</strong></p><p><strong>IO 处理过程分析</strong></p><p><strong>IO 模型与 NIO</strong></p><p><strong>Netty 介绍与示例</strong></p><p><strong>第四节课作业实践</strong></p><p>1、（可选）运行课上的例子，以及 Netty 的例子，分析相关现象。</p><p>2、写一段代码，使用 HttpClient 或 OkHttp 访问 <a href="http://localhost:8801，代码提交到">http://localhost:8801，代码提交到</a></p><p>Github。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三节 Spring 基础架构重构</title>
      <link href="2021/04/10/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82%20Spring%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%87%8D%E6%9E%84/"/>
      <url>2021/04/10/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82%20Spring%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><p>Java EE 项目 - 第十三节 Spring 基础架构重构 </p><p>小马哥（mercyblitz）</p><p><strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><p><strong>议题</strong> </p><p>• Spring Web MVC </p><p>• Spring JDBC </p><p>• Spring Logging</p><p><strong>Spring Web MVC</strong> </p><p>• 架构</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210410184651.png" alt="image-20210410184651911"></p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC 核心组件 </p><p>• 处理器管理 </p><p>• 页面渲染 </p><p>• 异常处理</p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC 处理器管理 </p><p>• 映射：HandlerMapping </p><p>• 适配：HandlerAdapter </p><p>• 执行：HandlerExecutionChain</p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC 页面渲染 </p><p>• 视图解析： ViewResolver </p><p>• 国际化：LocaleResolver、LocaleContextResolver </p><p>• 个性化：ThemeResolver</p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC 异常处理 </p><p>• 异常解析： HandlerExceptionResolver</p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC 注解驱动 </p><p>• 注解配置：@Configuration </p><p>• 组件激活：@EnableWebMvc </p><p>• 自定义组件 ：WebMvcConfigurer </p><p>• 模型属性：@ModelAttribute </p><p>• 请求头：@RequestHeader </p><p>• Cookie：@CookieValue </p><p>• 校验参数：@Valid、@Validated </p><p>• 注解处理：@ExceptionHandler </p><p>• 切面通知：@ControllerAdvice</p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC 自动装配 </p><p>• Servlet 依赖： Servlet 3.0+ </p><p>• Servlet SPI： ServletContainerInitializer </p><p>• Spring 适配： SpringServletContainerInitializer </p><p>• Spring SPI： WebApplicationInitializer </p><p>• 编程驱动： AbstractDispatcherServletInitializer </p><p>• 注解驱动：AbstractAnnotationConfigDispatcherServletInitializer</p><p><strong>Spring Web MVC</strong> </p><p>• 视图处理交互流程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210410184749.png" alt="image-20210410184749060"></p><p><strong>Spring Web MVC</strong> </p><p>• 视图处理核心组件 </p><p>• 视图解析器： ContentNegotiatingViewResolver </p><p>• 内容协商管理器： ContentNegotiationManager </p><p>• 内容协商策略： ContentNegotiationStrategy</p><p><strong>Spring Web MVC</strong> </p><p>• Web MVC REST 支持 </p><p>• 定义：@Controller、@RestController </p><p>• 映射：@RequestMapping、@*Mapping </p><p>• 请求：@RequestParam、@RequestHeader、@CookieValue </p><p>• 响应：@ResponseBody、ResponseEntity </p><p>• 拦截：@RestControllerAdvice </p><p>• 跨域：@CrossOrigin </p><p>• 处理方法参数解析器： HandlerMethodArgumentResolver </p><p>• 处理方法返回值解析器： HandlerMethodReturnValueHandler</p><p><strong>Spring Web MVC</strong> </p><p>• Spring Web MVC REST 处理流程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210410184818.png" alt="image-20210410184818296"></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>redission实现了readwritelock，不是很严谨</p><p>StampedLock</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三周 - 代码重构</title>
      <link href="2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%89%E5%91%A8%20-%20%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
      <url>2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%89%E5%91%A8%20-%20%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第三周-代码重构"><a href="#第三周-代码重构" class="headerlink" title="第三周 - 代码重构"></a>第三周 - 代码重构</h1><h2 id="3-1-设计模式：使用设计模式优化排序工具包的设计-19-52"><a href="#3-1-设计模式：使用设计模式优化排序工具包的设计-19-52" class="headerlink" title="3.1 设计模式：使用设计模式优化排序工具包的设计 19:52"></a>3.1 设计模式：使用设计模式优化排序工具包的设计 19:52</h2><p>设计模式是一个可重复使用的解决方案，如何举一反三，解决什么问题，如何解决的，这样开发的时候就能本能地在开发中想起来。</p><p>创建，结构，模型；类模式，对象模式</p><p>简单工厂设计模式，使用反射，使用配置文件</p><h2 id="3-2-设计模式：Singleton单例模式-23-34"><a href="#3-2-设计模式：Singleton单例模式-23-34" class="headerlink" title="3.2 设计模式：Singleton单例模式 23:34"></a>3.2 设计模式：Singleton单例模式 23:34</h2><p>单例：构造函数是private，获取单例的方法是静态的方法 public synchronized static。单例只提供服务，不保存对象。</p><p>饿汉模式</p><p>适配器模式</p><p>已经定义好的接口方法通过适配器暴露出去</p><p>类的适配器：实现一个接口，并且调用父类的方法【继承被适配的类】</p><p>对象的适配器：实现一个接口，组合的方式调用</p><p>组合优于继承，尽量使用对象适配器的方式</p><p>适配器的使用：jdbc driver</p><h2 id="3-3-JUnit中的设计模式（上）"><a href="#3-3-JUnit中的设计模式（上）" class="headerlink" title="3.3 JUnit中的设计模式（上）"></a>3.3 JUnit中的设计模式（上）</h2><h2 id="3-4-JUnit中的设计模式（下）"><a href="#3-4-JUnit中的设计模式（下）" class="headerlink" title="3.4 JUnit中的设计模式（下）"></a>3.4 JUnit中的设计模式（下）</h2><h2 id="3-5-Spring中的设计模式"><a href="#3-5-Spring中的设计模式" class="headerlink" title="3.5 Spring中的设计模式"></a>3.5 Spring中的设计模式</h2><h2 id="3-6-设计模式案例：Intel-大数据SQL引擎-amp-Panthera设计模式"><a href="#3-6-设计模式案例：Intel-大数据SQL引擎-amp-Panthera设计模式" class="headerlink" title="3.6 设计模式案例：Intel 大数据SQL引擎&amp;Panthera设计模式"></a>3.6 设计模式案例：Intel 大数据SQL引擎&amp;Panthera设计模式</h2><h2 id="3-7-第三周课后练习"><a href="#3-7-第三周课后练习" class="headerlink" title="3.7 第三周课后练习"></a>3.7 第三周课后练习</h2><h2 id="3-8-第三周课后练习-解答"><a href="#3-8-第三周课后练习-解答" class="headerlink" title="3.8 第三周课后练习-解答"></a>3.8 第三周课后练习-解答</h2>]]></content>
      
      
      <categories>
          
          <category> 架构师训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 架构师训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周 - 框架设计</title>
      <link href="2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%BA%8C%E5%91%A8%20-%20%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%BA%8C%E5%91%A8%20-%20%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="第二周-框架设计"><a href="#第二周-框架设计" class="headerlink" title="第二周 - 框架设计"></a>第二周 - 框架设计</h1><h2 id="2-1-从编程历史看面向对象编程的本质和未来-35min"><a href="#2-1-从编程历史看面向对象编程的本质和未来-35min" class="headerlink" title="2.1.从编程历史看面向对象编程的本质和未来 35min"></a>2.1.从编程历史看面向对象编程的本质和未来 35min</h2><p>打孔纸带 - 冯诺依曼手动查拔 - 汇编语言【面向机器，每一种cpu都有独特的机器语言，因此需要不同的汇编语言】 - 早期Basic - 结构化Basic - Perl语言- C/C++ 【面向过程，面向逻辑】C++兼容C的所有功能， 并且提供了面向对象的编程机制 - Java</p><p><code>面向对象很重要重要</code>，日常思考，是否面向对象设计和编程？面向对象的本质是什么，理解透彻后再想别的。</p><p>领域驱动设计，微服务，中台化等</p><p>大数据：函数式编程，响应式编程【本质是面向对象，数据这个对象】</p><p>面向对象关键：</p><p>封装【隐藏实现】，继承，多态【重要特点，C：指向函数的指针实现】</p><p>面向对象设计原则，设计模式</p><p>充血模型和贫血模型 &amp; 领域驱动设计DDD</p><p>实现目标：高内聚，低耦合</p><p>系统</p><ol><li>易拓展 增加新功能</li><li>更强壮 不容易被粗心的程序猿破坏</li><li>可移植 能够在多样的环境下运行</li><li>更简单 容易理解，容易维护</li></ol><p>设计模式</p><p>框架：支撑程序的整体结构</p><p>框架设计：架构师基本技能之一，开发出自己的框架，或者改造目前已有的框架，阅读框架也是基础技能之一。框架保证架构落地，工具提高开发效率。</p><h2 id="2-2-设计臭味：糟糕的代码有哪些特点？-26min"><a href="#2-2-设计臭味：糟糕的代码有哪些特点？-26min" class="headerlink" title="2.2.设计臭味：糟糕的代码有哪些特点？ 26min"></a>2.2.设计臭味：糟糕的代码有哪些特点？ 26min</h2><p>很难对系统进行改动，依赖强。一点改动牵连很多其他地方。对改动无关的地方也有影响。很难抽取出来给其他系统使用。很难修改原来的代码。不必要的复杂性，重复性。很难阅读和理解。 </p><p>代码设计要遵循OOD设计原则</p><h2 id="2-3-开闭原则介绍及代码分析-19min"><a href="#2-3-开闭原则介绍及代码分析-19min" class="headerlink" title="2.3.开闭原则介绍及代码分析 19min"></a>2.3.开闭原则介绍及代码分析 19min</h2><p>拓展开放，更改关闭</p><p>不需要修改类，模块，函数，就可以实现功能的拓展。</p><p>如何实现？关键是抽象</p><p>通话拨号：策略模式，适配器模式【一个接口的调用适配成另一个接口的调用】，观察者模式</p><h2 id="2-4-依赖倒置原则介绍及代码案例分析-18min"><a href="#2-4-依赖倒置原则介绍及代码案例分析-18min" class="headerlink" title="2.4.依赖倒置原则介绍及代码案例分析 18min"></a>2.4.依赖倒置原则介绍及代码案例分析 18min</h2><ul><li>高层不能依赖底层，大家都依赖抽象</li><li>抽象不能依赖实现，而是实现依赖抽象</li></ul><p>依赖倒置倒置了什么东西？即基于接口提供实现【模块和报的依赖；开发顺序和职责】</p><p>接口属于高层模块，高层可以根据自己的使用场景进行设计</p><p>软件的层次化：高层决定低层；高层被重用</p><p>依赖倒置原则是框架设计的核心</p><p>tomcat是依赖规范和接口进行编程的，我们实现了servlet的接口doGET，doPOST，框架会来调用我们的代码。</p><p>好莱坞原则，我们的代码不调用框架，框架调用我们的代码</p><p>反应式编程</p><h2 id="2-5-里式替换原则-18min"><a href="#2-5-里式替换原则-18min" class="headerlink" title="2.5.里式替换原则 18min"></a>2.5.里式替换原则 18min</h2><p>父类可以使用的地方，可以使用子类进行替换</p><p>里式替换原则是判断继承是否合理的一个重要原则</p><p>properties实现hashtable是不符合里式替换原则的</p><p>stack集成vector，堆栈不是一个数组</p><p>正方形不能继承长方形，因为他们的行为是不同的</p><p>java语法看。。。</p><p>子类的契约不能比基类更加严格</p><p>什么方法解决？</p><ol><li>可以提取共性到基类</li><li>将继承改为组合【组合有限替代继承】</li></ol><p>继承vs组合</p><p>。。。</p><h2 id="2-6-单一职责接口隔离-23min"><a href="#2-6-单一职责接口隔离-23min" class="headerlink" title="2.6.单一职责接口隔离 23min"></a>2.6.单一职责接口隔离 23min</h2><p>接口分离原则：不应该强迫客户程序依赖它们不需要的方法。通过接口暴露客户应该看到的方法。</p><p>接口隔离如何解决？</p><ol><li>适配器模式</li><li>多继承实现接口隔离。实现类实现多个接口</li></ol><p>敏捷软件开发：软件程序设计的</p><h2 id="2-7-案例：反应式编程框架Flower设计-53min"><a href="#2-7-案例：反应式编程框架Flower设计-53min" class="headerlink" title="2.7.案例：反应式编程框架Flower设计 53min"></a>2.7.案例：反应式编程框架Flower设计 53min</h2><p>反应式编程：react，weblusx，rxjava</p><p>什么是反应式编程？</p><p>及时响应，消息驱动等特点，主要是异步操作</p><p>解决的问题是什么？</p><p>并发访问，资源阻塞【网络io通信阻塞，数据库排队操作阻塞】</p><p>一方面占据资源，同时又不能继续执行，导致服务不可用</p><p>容器线程，akka线程，异步数据库连接驱动</p><p>使用akka的actor进行消息传递【有流程图】</p><p>尝试使用flower框架</p><p><code>截图一下ppt中的使用的代码【todo】</code></p><p>37：19继续录屏</p><h2 id="2-8-第二周课后练习"><a href="#2-8-第二周课后练习" class="headerlink" title="2.8.第二周课后练习"></a>2.8.第二周课后练习</h2><p> 作业一：</p><ol><li><p>请描述什么是依赖倒置原则，为什么有时候依赖倒置原则又被称为好莱坞原则？</p></li><li><p>请用接口隔离原则优化 Cache 类的设计，画出优化后的类图。<br><img src="https://static001.geekbang.org/resource/image/9a/2c/9aec3589f51537014bed88ae21f0072c.png" alt="img"></p></li></ol><ul><li><strong>提示</strong>：cache 实现类中有四个方法，其中 put get delete 方法是需要暴露给应用程序的，rebuild 方法是需要暴露给系统进行远程调用的。如果将 rebuild 暴露给应用程序，应用程序可能会错误调用 rebuild 方法，导致 cache 服务失效。按照接口隔离原则：不应该强迫客户程序依赖它们不需要的方法。也就是说，应该使 cache 类实现两个接口，一个接口包含 get put delete 暴露给应用程序，一个接口包含 rebuild 暴露给系统远程调用。从而实现接口隔离，使应用程序看不到 rebuild 方法。</li></ul><h2 id="作业二：根据当周学习情况，完成一篇学习总结"><a href="#作业二：根据当周学习情况，完成一篇学习总结" class="headerlink" title="作业二：根据当周学习情况，完成一篇学习总结"></a>作业二：根据当周学习情况，完成一篇学习总结</h2><h2 id="2-9-第二周课后练习-解答"><a href="#2-9-第二周课后练习-解答" class="headerlink" title="2.9.第二周课后练习-解答"></a>2.9.第二周课后练习-解答</h2>]]></content>
      
      
      <categories>
          
          <category> 架构师训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 架构师训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构师训练营 - 汇总信息</title>
      <link href="2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E6%B1%87%E6%80%BB%E4%BF%A1%E6%81%AF/"/>
      <url>2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E6%B1%87%E6%80%BB%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="《架构师训练营-1-期-问题及反馈收集》："><a href="#《架构师训练营-1-期-问题及反馈收集》：" class="headerlink" title="《架构师训练营 1 期 问题及反馈收集》："></a>《架构师训练营 1 期 问题及反馈收集》：</h4><p><a href="https://shimo.im/sheets/wjGpkXXCkVcQGGPy/vNLLA/"> https://shimo.im/sheets/wjGpkXXCkVcQGGPy/vNLLA/</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构师训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 架构师训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周 - 架构方法</title>
      <link href="2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%80%E5%91%A8%20-%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95/"/>
      <url>2021/04/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%80%E5%91%A8%20-%20%E6%9E%B6%E6%9E%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周-架构方法"><a href="#第一周-架构方法" class="headerlink" title="第一周 - 架构方法"></a>第一周 - 架构方法</h1><h2 id="1-大厂架构师招聘JD解读"><a href="#1-大厂架构师招聘JD解读" class="headerlink" title="1.大厂架构师招聘JD解读"></a>1.大厂架构师招聘JD解读</h2><p>李智慧</p><p>个人介绍：长期从事大型网站架构，大数据的研发工作…</p><p>后端架构师 25k-50k</p><p>职位职责：</p><ol><li>负责字节跳动企业级<code>Sass应用等后台业务的产品调研/讨论以及整体架构设计</code></li><li>承担业务重点，<code>业内难点的技术攻坚，主导核心组件/富而无 编码以及上线</code></li><li>分析和发掘现有系统的不足，<code>定位系统瓶颈，提高系统性能/稳定性以及业务拓展性</code></li><li><code>主导跨部门写作和复杂功能的调研，设计，协调，实施和落地</code></li></ol><p>职位要求：</p><ol><li>本科及以上学历，7年及以上工作经验</li><li>具备丰富的架构设计经验，能够准确，全面地理解业务，并根据业务发展设计合理的架构方案</li><li><code>具备海量数据和大规模分布式系统的设计和开发经验</code></li><li>良好的产品意识，能够做到技术和产品相结合，<code>从设计到实现始终对齐业内一流产品水准</code></li><li><code>具备良好的沟通能力，组织能力及团队协作精神</code></li><li>负责过多条业务线或整个产品线的业务架构工作，组织过中等以上规模项目者优先</li><li><code>对多种数据库中间件，消息中间件及其他大规模分布式系统的基础架构组件有深入理解这优先</code></li><li>熟悉共有与，私有云，虚拟化，容器化部署者优先</li></ol><p>能力提升了，职业前途有更好的发展，做了什么事情才能通过面试，并在面试通过后能很好地工作？和上面的JD我们有什么差距？</p><p><code>todo:未完成下面的编写start</code></p><p>Java架构师 40k-50k</p><p>擅长领域模型和敏捷开发的思想和方法论</p><p>Java架构师 30k-60k</p><p>工作职责：</p><ol><li>负责公司电商平台的技术选型，架构搭建，完成系统整合过程的软件架构设计，解决开发中的各种系统架构问题</li><li>优化现有系统的性能，解决软件系统关键技术问题，核心功能的模块设计</li><li>营造技术学习氛围，带领…</li></ol><p><code>todo:未完成下面的编写end</code></p><p>框架约束职责和开发过程，根据实际情况构建解决方案</p><p>架构师不一定要写代码，但是要约束。如果是比较关键的东西，没有人能解决。数据结构和算法能力比较重要。</p><h3 id="架构师的主要职责"><a href="#架构师的主要职责" class="headerlink" title="架构师的主要职责"></a>架构师的主要职责</h3><ol><li>编写架构设计文档 week1</li><li>开发编程框架 week2</li><li>重构软件代码 week3</li><li>设计系统架构 week4</li><li>进行技术选型，解决技术应用中的问题 week5-6</li><li>优化系统性能 week7-9</li><li>模块分解与微服务架构重构 week10</li><li>保证系统安全和高可用 week11</li><li>大数据应用 week12-13</li><li>技术创新 week14</li><li>沟通管理 week15</li></ol><p>主要就是高性能，高并发，高可用的问题</p><h2 id="2-架构师面试题"><a href="#2-架构师面试题" class="headerlink" title="2.架构师面试题"></a>2.架构师面试题</h2><p>什么是软件架构？</p><p>如何写一个架构设计文档，文档中应该包括哪些方面的内容？</p><h4 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h4><p>子类override父类的方法后，想要修改抛出的异常，那么子类方法抛出的异常类应该是父类方法抛出的异常类的子类还是父类？</p><p>spring是如何实现单例的，和设计模式中的单例有什么不同？【设计模式，代码重构】</p><p>淘宝这样的大规模分布式互联网应用系统使用了哪些技术方案和手段。。。。。<code>【todo】</code></p><p>什么是CAP原理？</p><p>请描述某个你熟悉的NoSQL产品是如何解决CAP问题的？</p><p>如何进行性能测试，性能测试的流程是什么？性能测试的主要关注指标有哪些？</p><p>为什么在系统性能测试的时候，随着并发请求书的主键增加，错误响应（或者响应超时）<code>【todo】</code></p><p>你怎么理解领域驱动设计DDD？</p><p>DDD的优缺点是什么？</p><p>导致系统故障无法正常访问的原因有哪些？保障系统稳定高可用的方案有哪些？请举例并简述。</p><p>如何保护数据库中存储的用户密码，请用时序图用户<code>【todo】</code></p><p>Spark为什么比MapReduce快？</p><p>淘宝，头条这些应用会针对不同用户推荐不同的商品和内容，他们是如何做到的？<code>【todo】</code></p><p>区块链是如何保证数据无法被篡改？<code>【todo】</code></p><p>如果你觉得系统需要进行重构，但是老板和团队成员都觉得没必要，你如何说服大家？<code>【todo】</code></p><h4 id="架构师的主要能力【todo，有说一些详细的内容，需要视频里面找一遍】"><a href="#架构师的主要能力【todo，有说一些详细的内容，需要视频里面找一遍】" class="headerlink" title="架构师的主要能力【todo，有说一些详细的内容，需要视频里面找一遍】"></a>架构师的主要能力<code>【todo，有说一些详细的内容，需要视频里面找一遍】</code></h4><p>编程能力</p><p>基础技术掌握能力</p><p>常用技术产品的理解和应用能力</p><p>性能优化与分析故障的能力</p><p>常用架构模式和框架的理解和应用能力</p><p>建模以及设计文档的方法和能力</p><p>业务理解与功能模块及非功能模块拆解能力</p><p>快速学习能力</p><p>沟通和领导能力</p><h4 id="什么是软件架构？"><a href="#什么是软件架构？" class="headerlink" title="什么是软件架构？"></a>什么是软件架构？</h4><p><code>todo 可以截图</code></p><p>架构元素，元素间关系，架构，系统，架构文档，相关方，架构视图，关注点</p><p>给领导看架构设计，不同用户使用，不同用户如何做隔离？</p><h4 id="大家关心的一些问题"><a href="#大家关心的一些问题" class="headerlink" title="大家关心的一些问题"></a>大家关心的一些问题</h4><p>佳偶过会和全栈功能师的区别是？两者之间是否有联系<code>【todo】</code></p><p>学完之后，怎么应聘架构师？</p><p>感觉单单靠老师讲课还不够，系统老师推荐一些必备技能的书单，让我们在跟着老师学习的过程中还可以有目标去看一些书</p><p><code>【todo：睡着了】</code></p><h4 id="如何通过训练营提高自己"><a href="#如何通过训练营提高自己" class="headerlink" title="如何通过训练营提高自己"></a>如何通过训练营提高自己</h4><ul><li>架构师训练营，而不是架构训练营<ul><li>架构方法，架构模式，关键知识点可以训练，但是架构一定要实践，一定要关注场景</li></ul></li><li>课程中素有的技术都只是例子，通过学习例子训练架构思维，构建知识体系<ul><li>通过例子，总结模式，通过模式，构建知识体系</li></ul></li></ul><h2 id="3-4-1视图模型：软件开发的本质是什么？"><a href="#3-4-1视图模型：软件开发的本质是什么？" class="headerlink" title="3. 4+1视图模型：软件开发的本质是什么？"></a>3. 4+1视图模型：软件开发的本质是什么？</h2><h4 id="4-1视图模型"><a href="#4-1视图模型" class="headerlink" title="4+1视图模型"></a>4+1视图模型</h4><p>通过多个架构视图描述你的架构设计</p><p>软件架构 = 「元素，形式，关系/约束」</p><p>单一的视图无法完成的表达架构，需要完成的视图集</p><ul><li>逻辑视图<ul><li>相关方：客户，用户，开发组织管理着</li><li>视角：系统的功能元素，以及它们接口，职责，交互</li><li>主要元素：系统，子系统，功能模块i，子功能模块，接口</li><li>用途：开发组织划分<code>【todo】</code></li></ul></li><li>开发视图<ul><li>相关者：开发相关人员，测试人员</li><li>视角：系统如何开发实现</li><li>主要元素：<code>【todo】</code></li></ul></li><li>物理视图<ul><li>相关者：系统集成商 <code>【todo】</code></li><li>视角：</li><li>主要元素：</li></ul></li><li>过程视图<code>【todo】</code><ul><li>相关者：性能优化，开发相关人员</li><li>视角：</li><li>主要元素：系统进程，线程以及处理队列等</li></ul></li><li>场景视图<code>【todo】</code><ul><li>相关者：用户</li><li>视角：</li></ul></li></ul><p>软件开发所有的方面都通过上面5个视图涵盖</p><p>实践中更多用的是UML建模，视图让我们</p><h4 id="用UML进行软件架构设计"><a href="#用UML进行软件架构设计" class="headerlink" title="用UML进行软件架构设计"></a>用UML进行软件架构设计</h4><h5 id="什么是模型？"><a href="#什么是模型？" class="headerlink" title="什么是模型？"></a>什么是模型？</h5><p>模型是一个系统的完整的抽象。人们对某个领域特定的问题的求解以及解决方案，对它们的理解和认识都蕴含在模型中。</p><p>通常，开发一个计算机系统是为了解决某个领域特定问题，问题的求解过程，就是从领域问题到计算机系统的映射。</p><p>领域问题 -&gt; 分析&amp;抽取 - <code>领域模型/设计模型</code> - 分析&amp;设计 - 解决方案</p><h4 id="为什么要建造模型？"><a href="#为什么要建造模型？" class="headerlink" title="为什么要建造模型？"></a>为什么要建造模型？</h4><p>建造传统模型的目的</p><ul><li>为了证明某件事物能否工作</li><li>前提：建造模型的成本远远低于建造实物的成本<ul><li>造飞机</li><li>造高楼</li></ul></li></ul><p>建造软件模型的目的</p><ul><li>为了与他人沟通</li><li>为了保存软件设计的最终成果</li></ul><p><code>【todo】</code></p><h4 id="何时、何处画图？"><a href="#何时、何处画图？" class="headerlink" title="何时、何处画图？"></a>何时、何处画图？</h4><p>何时画图?</p><ul><li>讨论和交流的时候</li><li>最终设计文档<ul><li>只保留少量的，重要的图</li><li>避免设计过多内容和实现细节</li></ul></li></ul><p>何处画图？</p><ul><li>白板</li><li>绘图工具，visio，astah</li><li>draw.io</li></ul><h4 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h4><p>什么是UML？</p><ul><li>Unified  modeling  Language，或者统一建模语言</li><li>以图形方式描述软件的概念</li></ul><p>UML可用来描述：</p><ul><li>某个问题领域</li><li>构思中的软件设计</li><li>描述已经完成的软件实现</li></ul><p>不要纠结UML是否是规范的，错误不影响阅读和理解，问题都不大。</p><h2 id="4-UML：软件架构建模的一般方法和工具-47min"><a href="#4-UML：软件架构建模的一般方法和工具-47min" class="headerlink" title="4.UML：软件架构建模的一般方法和工具 47min"></a>4.UML：软件架构建模的一般方法和工具 47min</h2><h3 id="通用模型元素"><a href="#通用模型元素" class="headerlink" title="通用模型元素"></a>通用模型元素</h3><p>可以在图中使用的概念统称为模型元素。模型元素在图中用其相应的视图元素（符号）</p><p>表示，下图给出了常用的元素符号：类、对象、结点、包和组件等。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210410160822.png" alt="image-20210410160822515"></p><p>模型元素与模型元素之间的连接关系也是模型元素，常见的关系有关联（association）、泛化（generalization）、依赖（dependency）和聚合（aggregation）。这些关系的图示符号如图所示。</p><p>【图片】</p><p>关联：连接（connect）模型元素及链接（link）实例。</p><p>依赖：表示一个元素以某种方式依赖于另一种元素。</p><p>泛化：表示一般与特殊的关系，即“一般”元素是“特殊”关系的泛化。</p><p>聚合：表示整体与部分的关系。</p><h3 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h3><p><code>软件分析三个阶段：需求分析，概要设计，详细设计</code></p><p>用例建模技术，用于描述系统的功能需求。在宏观上给出模型的总体轮廓。通过对典型用例的分析，使开发者能够有效地了解用户的需求。</p><p>【图片】</p><p>用例模型描述的是外部执行者（Actor）所理解的系统功能。它描述了待开发系统的功能需求。</p><p>它驱动了需求分析之后各阶段的开发工作,不仅在开发过程中保证了系统所有功能的实现，而且被用于验证和检测所开发的系统，从而影响到开发工作的各个阶段和 UML 的各个模型。</p><p>用例模型由若干个用例图构成，用例图中主要描述执行者和用例之间的关系。在 UML中，构成用例图的主要元素是用例和执行者及其它们之间的联系。</p><p>创建用例模型的工作包括：定义系统、确定执行者和用例、描述用例、定义用例间的关系、确认模型。</p><p>执行者（Actor）</p><p>执行者是指用户在系统中所扮演的角色。执行者在用例图中是用类似人的图形来表示, 但执行者可以是人，也可以是一个外界系统。</p><p>注意：用例总是由执行者启动的。</p><p>如何确定执行者：</p><ol><li><p>谁使用系统的主要功能(主执行者)?</p></li><li><p>谁需要从系统获得对日常工作的支持和服务？</p></li><li><p>需要谁维护管理系统的日常运行（副执行者）？</p></li><li><p>系统需要控制哪些硬件设备？</p></li><li><p>系统需要与其它哪些系统交互？</p></li><li><p>谁需要使用系统产生的结果（值）？</p></li></ol><p>【图片】</p><p>用例图描述了系统的功能需求，它是从执行者的角度来理解系统，用于捕获系统的需求，规划和控制项目；描述了系统外部的执行者与系统提供的用例之间的某种联系。图中还有另外两种类型的连接，即《使用》和《扩展》关系，是两种不同形式的泛化关系。</p><p>《Use》表示一个用例使用另一个用例。</p><p>《Extend》通过向被扩展的用例添加动作来扩展用例。</p><p>【图片】</p><h4 id="例-项目与资源管理系统的-Use-case-图"><a href="#例-项目与资源管理系统的-Use-case-图" class="headerlink" title="例 项目与资源管理系统的 Use case 图"></a><strong>例 项目与资源管理系统的</strong> <strong>Use case</strong> <strong>图</strong></h4><p>系统的主要功能是：项目管理，资源管理和系统管理。项目管理包括项目的增加、删除、更新。资源管理包括对资源和技能的添加、删除和更新。系统管理包括系统的启动和关闭，数据的存储和备份等功能。</p><p>• 分析确定系统的执行者（角色）</p><p>​    Ø 项目管理员、资源管理员、系统管理员、备份数据系统。</p><p>• 确定用例</p><p>​    Ø 项目管理，资源管理和系统管理。</p><p>• 对用例进行分解，画出下层的 Use case 图 </p><p>​    Ø 对上层的用例进行分解,并将执行者分配到各层次的 Use case 图中。</p><p>【图片】</p><h3 id="静态建模"><a href="#静态建模" class="headerlink" title="静态建模"></a>静态建模</h3><p>任何建模语言都以静态建模机制为基础,标准建模语言UML也不例外。所谓静态建模是指对象之间通过属性互相联系，而这些关系不随时间而转移。</p><p>类和对象的建模，是 UML 建模的基础。UML 的静态建模机制包括：</p><p>• 用例图(Use case diagram) </p><p>• 类图(Class diagram)</p><p>• 对象图(Object diagram )</p><p>• 包图(Package diagram)</p><p>• 组件图(Component diagram)</p><p>• 部署图(Deployment diagram)</p><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>面向对象的开发方法的基本任务是建立对象模型，是软件系统开发的基础。UML 中的类图（Class Diagram）与对象图（Object Diagram）表达了对象模型的静态结构，能够有效地建立专业领域的计算机系统对象模型</p><p>【图片】</p><p>属性（attribute）</p><p>属性用来描述类的特征，表示需要处理的数据。</p><p>属性定义：</p><p>visibility attribute-name : type = initial-value {property-string}</p><p>可见性 属性名：类型=缺省值{约束特性}</p><p>其中：可见性（visibility）表示该属性对类外的元素是否可见。</p><p>分为：</p><p>• public（+） 公有的。</p><p>• private（-） 私有的。</p><p>• protected（#） 受保护的。</p><p>• 默认（未声明）操作</p><p>对数据的具体处理方法的描述则放在操作部分，操作说明了该类能做些什么工作。操作通常称为函数，它是类的一个组成部分，只能作用于该类的对象上。</p><p>操作定义：</p><p>visibility operating-name(parameter-list): return-type {property- string}</p><p>可见性 操作名（参数表）；返回类型{约束特性}</p><p><strong>一个使用</strong> <strong>Visio</strong> <strong>绘制的类图</strong></p><p>【图片】</p><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>一个最古老的软件方法问题是：怎样将大系统拆分成小系统。解决该问题的思路之一是将许多类集合成一个更高层次的单位，形成一个高内聚、低耦合的类的集合。UML 中这种分组机制叫包（Package）。引入包是为了降低系统的复杂性。</p><p>【图片】</p><h2 id="5-架构设计文档：软件架构设计文档的写作模式-31min"><a href="#5-架构设计文档：软件架构设计文档的写作模式-31min" class="headerlink" title="5.架构设计文档：软件架构设计文档的写作模式 31min"></a>5.架构设计文档：软件架构设计文档的写作模式 31min</h2><p>方正日本外包项目：都是被推动这做一些超过能力以上的事情，uml是李老师的敲门砖</p><p>开发规范，日志，异常处理等</p><p>UML逆向设计，通过代码得出UML图</p><p>要跟别人合作的时候，讲清楚，需要UML图</p><p>画图之后就是设计文档，老师有模板提供</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="作业一：食堂就餐卡系统设计"><a href="#作业一：食堂就餐卡系统设计" class="headerlink" title="作业一：食堂就餐卡系统设计"></a>作业一：食堂就餐卡系统设计</h2><ul><li>系统中每个消费者都有一张卡，在管理中心注册缴费，卡内记着消费者的身份、余额。</li><li>使用时将卡插入收款机则显示卡上金额，服务员按收款机上数字键，收款机自动计算并显示消费额及余额。</li><li>管理中心的管理员监视每一笔消费，可打印出消费情况的相关统计数据。</li></ul><p>请设计系统用例图，组件图，组件时序图，部署图。</p><h2 id="作业二：根据当周学习情况，完成一篇学习总结"><a href="#作业二：根据当周学习情况，完成一篇学习总结" class="headerlink" title="作业二：根据当周学习情况，完成一篇学习总结"></a>作业二：根据当周学习情况，完成一篇学习总结</h2><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>需要会的内容</p><ul><li>UML建模各类作图，以及都在什么时候使用他们，画图很重要</li></ul><p>之后上面都写笔记</p><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>UML精粹</p>]]></content>
      
      
      <categories>
          
          <category> 架构师训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 架构师训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零周 - 是什么奠定了架构师的职场地位</title>
      <link href="2021/04/09/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E9%9B%B6%E5%91%A8%20-%20%E6%98%AF%E4%BB%80%E4%B9%88%E5%A5%A0%E5%AE%9A%E4%BA%86%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E8%81%8C%E5%9C%BA%E5%9C%B0%E4%BD%8D/"/>
      <url>2021/04/09/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E9%9B%B6%E5%91%A8%20-%20%E6%98%AF%E4%BB%80%E4%B9%88%E5%A5%A0%E5%AE%9A%E4%BA%86%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E8%81%8C%E5%9C%BA%E5%9C%B0%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>成为什么样的人才能成为架构师？并且大家能认可？技术够了其实是不够的，有些人拿着ppt就可以去做架构师。不但要会写代码，还要ppt写得好，沟通也要好。作为一个职业长久发展的目标去培养。底层，业务，用户角度都体验过了才能算一个合格的架构师。ppt是打动控制资源的那些人的。</p><p>架构师 - 工资高，待遇好，但是是有很多事情需要克服的。架构，业务，底层，设计等等。工作按照自己的意愿去做事情。现在坚持不住，将来也是没有时间去做的。做好的开始做的时间是现在。意志坚定不坚定，是否之后都会做这一行？以此作为职业生涯。</p><h1 id="李智慧老师的个人经历"><a href="#李智慧老师的个人经历" class="headerlink" title="李智慧老师的个人经历"></a>李智慧老师的个人经历</h1><p>西部某核军工厂：弱点工程师，嵌入式工控软件软件开发工程师</p><p>方正：日本最大票务系统外包架构师</p><p>NEC：java web容器以及Web应用防火墙架构师</p><p>Alibaba：分布式基础平台产品架构师，Alibaba.com架构师</p><p>Intel：Spark开源开发者，Intel大数据仓库架构师</p><p>创业：CTO，首席架构师</p><p>只是看了人家的书，没有亲身的体验，能不能做好？需要进行实践。邓小平爷爷曾今说过，实践是检验真理的唯一标准。</p><p>知识完整理解了后，怎么去运用是最重要的。</p><h1 id="几个方面提升"><a href="#几个方面提升" class="headerlink" title="几个方面提升"></a>几个方面提升</h1><p>夸夸其谈能给你带来掌声。</p><p>解决棘手的问题能帮你带来名声。</p><p>让别人依赖你的代码，能帮你赢得地位。</p><h1 id="只有代码是不够的"><a href="#只有代码是不够的" class="headerlink" title="只有代码是不够的"></a>只有代码是不够的</h1><p>大家都依赖的代码，一定是核心代码，凭什么让你来写？</p><p>你写的代码，想让大家依赖，大家都知道一旦依赖你的代码，就会依赖与你，凭什么要依赖？</p><p>大家是依赖你才依赖你的代码，你会才会让你去做这件事。</p><p>学会了 - 夸夸其谈 - 你写代码 - 大家依赖你</p><p>围绕着核心【问题】去学习？？不要一个一个点去，有了核心之后能构建知识网络。</p><p>原来的技术是怎么解决的，新的技术是怎么解决问题的？</p><h1 id="优秀的架构师必须是软件开发的全才"><a href="#优秀的架构师必须是软件开发的全才" class="headerlink" title="优秀的架构师必须是软件开发的全才"></a>优秀的架构师必须是软件开发的全才</h1><p>卓越的编程和设计能力</p><p>解决棘手问题的能力</p><p>广阔的知识面</p><p>洞悉技术背后的本质和规律</p><p>沟通和打动人心的能力</p><p>周围强的人越来越多，技术厉害的人也越来越多</p><p>技术，沟通，吹牛逼好的人越来越多</p><p>学的东西多了，是触类旁通的一个，知识其实是相通的。</p><h1 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h1><p>务实是老师的方针</p><p>程序员修炼之道</p><p>uml精粹：标准对象建模语言简明指南</p><p>敏捷软件开发：原则，模式与实践</p><p>大型网站技术架构：核心原理和案例分析</p><p>互联网创业核心技术：构建可伸缩的Web应用</p><p>企业应用架构模式</p><p>实现领域驱动设计</p><p>架构整洁之道</p><p>程序员的思维修炼：开发认知潜能的九堂课</p><p>你的灯亮着吗：发现问题的真正所在</p><p>成为技术领导者：掌握全面解决问题的方法</p><p>不动带人，你就自己干到死</p>]]></content>
      
      
      <categories>
          
          <category> 架构师训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 架构师训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二节 应用容器高可用</title>
      <link href="2021/04/08/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82-%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>2021/04/08/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82-%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><p>Java EE 项目 - 第十二节 应用容器高可用 </p><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者<strong>议题</strong> </p><p>• Java 缓存 </p><p>• 分布式 Session </p><p>• 问答互动</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• 基本概念 </p><p>缓存是一种久经考验并且显著地提升应用性能以及伸缩性的技术。缓存用作临时存储信息 </p><p>复本，该复本未来可能被再次使用，减少再次加载或创建的成本。 </p><p>• Java Caching API </p><p>为 Java 程序提供一种通用方式去创建、读取、更新以及删除缓存中的元素。 </p><p>Java Cache（JSR-107）1.0 正式发布时间：2013年12月16日</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• 概念 </p><p>缓存是一种久经考验并且显著地提升应用性能以及伸缩性的技术。缓存用作临时存储信息 </p><p>复本，该复本未来可能被再次使用，减少再次加载或创建的成本。 </p><p>• Java Caching API </p><p>为 Java 程序提供一种通用方式去创建、读取、更新以及删除缓存中的元素。 </p><p>Java Cache（JSR-107）1.0 正式发布时间：2013年12月16日</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• 非规范目标 </p><p>• 资源和内存限制配置 </p><p>尽管许多缓存实现提供了运行时缓存资源限制能力，不过规范并不会定义功能性的配置。 </p><p>• 缓存存储和拓扑结构 </p><p>规范没有规定缓存的实现存储或者信息展示。 </p><p>• 管理 </p><p>规范没有规定缓存如何管理，定义了程序化配置缓存的机制以及通过Java Management Extensions（JMX） </p><p>探测缓存的统计信息。</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• 非规范目标 </p><p>• 安全 </p><p>规范没有规定缓存内容如何是否安全或者缓存操作如何控制。 </p><p>• 外部资源同步 </p><p>规范没有规定应用或缓存实现如何保持缓存与外部之间的内容同步。</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• 核心接口 </p><p>• javax.cache.spi.CachingProvider </p><p>定义构建、配置、获取、管理和控制零个以上CacheManager的机制，应用程序在运行时也可能读取或使用 </p><p>零个以上的CachingProvider。 </p><p>• javax.cache.CacheManager </p><p>定义构建、配置、获取、管理和控制零个以上不重名的Cache的机制。CacheManager 归属单个 </p><p>CacheProvider。</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• 核心接口 </p><p>• javax.cache.Cache </p><p>一种类似于Map的数据结构，允许Key-Value临时存储。Cache归属单个CacheManager。 </p><p>• javax.cache.Cache.Entry </p><p>单个存储在Cache中的键值对。存储在缓存中的每个Entry存在一个持久时间。 </p><p>• javax.cache.expiry.ExpiryPolicy </p><p>定义Entry的过期策略。<strong>Java</strong> <strong>缓存</strong> </p><p>• 存储方式 </p><p>• 值存储（Store-By-Value） </p><p>默认机制，在存储Key和Value前，需要实现创建一份复本数据，并且在读取缓存时，同样返回一份复制数据。 </p><p>一种简单键值复本的实现方式为Java序列化。规范推荐自定义Key和Value类均实现标准的Java 序列化，用户 </p><p>也可以自定义实现。比如：分布式缓存 - Redis </p><p>• 引用存储（Store-By-Reference） </p><p>可选机制，存储与获取Key和Value的实现通过Java引用。比如：JVM本地缓存 - Guava</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• Cache 与 Map的类似点 </p><p>• 缓存值均有关联键来存储 </p><p>• 每个值可能仅关联单个键 </p><p>• 特别注意key的可变性，可变的key可能会影响键的比较 </p><p>• 自定义Key类应该添加合适的Object.hashCode方法</p><p><strong>Java</strong> <strong>缓存</strong> </p><p>• Cache 与 Map的区别点 </p><p>• 缓存的键和值禁止为null </p><p>• 缓存项可能会过期 </p><p>• 缓存项可能被移除 </p><p>• 缓存支持Compare-And-Swap（CAS）操作 </p><p>• 缓存的键和值可能需要某种方式的序列化</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>分片是缓存</p><p>广播复制</p><p>java cache</p><p>举例</p><p>jvm缓存</p><p>guava</p><p>enhance cache</p><p>分布式缓存</p><p>apache ignite</p><p>hazelcast</p><p>相关只是</p><p>java序列化</p><p>java标准序列化</p><p>在网络中基本传输单位是字节</p><p>反序列化 - 字节数组变为对象</p><p>序列化 - 对象变为字节数组</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/08/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%A4%A7%E7%BA%B2%E6%B1%87%E6%80%BB&amp;%E5%85%B6%E4%BB%96%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/08/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%A4%A7%E7%BA%B2%E6%B1%87%E6%80%BB&amp;%E5%85%B6%E4%BB%96%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="java进阶训练营课程大纲"><a href="#java进阶训练营课程大纲" class="headerlink" title="java进阶训练营课程大纲"></a>java进阶训练营课程大纲</h1><h3 id="模块一：JVM-进阶–Java-开发者大厂面试必知必会"><a href="#模块一：JVM-进阶–Java-开发者大厂面试必知必会" class="headerlink" title="模块一：JVM 进阶–Java 开发者大厂面试必知必会"></a>模块一：JVM 进阶–Java 开发者大厂面试必知必会</h3><h4 id="教学目标："><a href="#教学目标：" class="headerlink" title="教学目标："></a>教学目标：</h4><p>从 0 掌握 JVM 关键技术，了解核心知识；</p><p>全面了解各类 GC 算法的原理和特性，洞悉相关原理；</p><p>全面学习常见的 JVM 分析调优工具，上手十八般武艺；</p><p>一线大厂 JVM 面试题全面剖析，助力拿到心仪 Offer。</p><h4 id="学习和工作中的痛点："><a href="#学习和工作中的痛点：" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>没有经过体系化 JVM 学习，不懂原理，做不到知其然知其所以</p><p>不熟悉 JVM 工具和方法，遇到问题不知道从何下手、如何分析和解决问题；</p><p>缺乏实际场景的练习，每次看看书上的知识就忘，理解不深，无法做到融会贯通；</p><p>在面试过程中十回有九回都遇到问 JVM 理论和分析调优的问题，每次都很难让面试官满意。</p><h4 id="通过学习掌握的核心能力："><a href="#通过学习掌握的核心能力：" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：掌握 JVM 的基础知识和常用工具，了解一般原理，知道从什么地方着手分析问题；</p><p>深入学习：掌握各类 GC 算法的一般原理，知道如何根据实际需要选择使用合适的 GC 策略；</p><p>分析问题：掌握 GC 日志、线程、内存等维度的分析技巧，知道排查问题和优化系统的套路；</p><p>积累经验：了解常见的分析调优经验，熟悉常见的面试问题和技巧，彻底学会 JVM 知识。</p><h4 id="详细内容："><a href="#详细内容：" class="headerlink" title="详细内容："></a>详细内容：</h4><p>JVM 基础知识、Java 字节码技术、JVM 类加载器、JVM 内存模型、JVM 启动参数详解；</p><p>JDK 内置命令行工具、JDK 内置图形界面工具、JDWP 简介、JMX 与相关工具；</p><p>常见的 JVM GC 算法（Parallel GC/CMS GC/G1 GC）基本原理和特点；</p><p>新一代 GC 算法（Java11 ZGC/Java12 Shenandoah）和Oracle Graalvm；</p><p>GC 日志解读与分析、JVM 的线程堆栈等数据分析、内存 dump 和内存分析工具u；</p><p>fastThread 相关工具以及面临复杂问题时的几个高级工具的使用；</p><p>JVM 问题排查分析的常用手段、性能调优的最佳实践经验等；</p><p>JVM 相关的常见面试问题必知必会、全面分析。</p><h3 id="模块二：NIO-技术–构建高吞吐服务器的终极武器"><a href="#模块二：NIO-技术–构建高吞吐服务器的终极武器" class="headerlink" title="模块二：NIO 技术–构建高吞吐服务器的终极武器"></a>模块二：NIO 技术–构建高吞吐服务器的终极武器</h3><h4 id="教学目标：-1"><a href="#教学目标：-1" class="headerlink" title="教学目标："></a>教学目标：</h4><p>理解 NIO 的相关概念和原理，了解核心知识；</p><p>全面掌握 Netty 相关的功能特性，掌握 Netty 的技术原理；</p><p>全面学会使用 Netty 技术编程，能够写出高效服务器端代码；</p><p>掌握常用的性能压测技术和相关工具，能够压测 HTTP 接口性能。</p><h4 id="学习和工作中的痛点：-1"><a href="#学习和工作中的痛点：-1" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>不理解 NIO 相关概念和技术点，搞不清原理，沟通和面试时无法准确表达；</p><p>缺乏实际场景的练习，对 Netty 的使用和原理不熟悉，难以应用到工作中；</p><p>不会使用 Netty 做高性能服务端编程，对性能相关指标和数据没有概念。</p><h4 id="通过学习掌握的核心能力：-1"><a href="#通过学习掌握的核心能力：-1" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：掌握 NIO 相关的知识和技术，能知道各种技术有什么优缺点，适用于什么场景；</p><p>深入学习：熟练掌握 Netty/NIO 编程，能够设计实现一个高性能 HTTP 服务器/API 网关；</p><p>积累经验：了解常见的性能相关概念和压测入门，对性能指标有清晰概念，能够简单地量化分析。</p><h4 id="详细内容：-1"><a href="#详细内容：-1" class="headerlink" title="详细内容："></a>详细内容：</h4><p>同步/异步、阻塞/非阻塞、BIO、NIO、AIO、Reactor/Proactor；</p><p>ByteBuff/Acceptor/Channel/Handler、NioEventLoopGroup/EventLoop、bossGroup/workerGroup；</p><p>Netty 的启动和执行过程、线程模型、事件驱动、服务端和客户端的使用方式；</p><p>常见的 API Gateway/HTTP Server、SEDA 原理、业务 API 网关的功能和结构；</p><p>Throughout/TPS/QPS、Latency/P99/P95/P90、ApacheBench/Wrk/JMeter/LoadRunner。</p><h3 id="模块三：并发编程–多核处理器时代高性能的秘诀"><a href="#模块三：并发编程–多核处理器时代高性能的秘诀" class="headerlink" title="模块三：并发编程–多核处理器时代高性能的秘诀"></a>模块三：并发编程–多核处理器时代高性能的秘诀</h3><h4 id="教学目标：-2"><a href="#教学目标：-2" class="headerlink" title="教学目标："></a>教学目标：</h4><p>学会多线程、高并发相关概念和技术，了解并发编程的核心知识；</p><p>全面了解并发的相关技术的原理和用途，洞悉技术原理和相互关系；</p><p>熟练掌握 Java 的多线程、并发包中各个类的使用，上手十八般武艺。</p><h4 id="学习和工作中的痛点：-2"><a href="#学习和工作中的痛点：-2" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>没有经过系统性学习并发编程，搞不清楚技术原理，写不出一个良好的多线程/异步代码；</p><p>不熟悉 Java 的各个多线程工具和方法，遇到多线程问题常常束手无措，不会分析解决问题；</p><p>缺乏实际场景的练习，平时没怎么用到多线程和并发，导致死记硬背的概念总是记不住。</p><h4 id="通过学习掌握的核心能力：-2"><a href="#通过学习掌握的核心能力：-2" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：系统掌握 Java 多线程和并发编程的技术原理和知识点，写出优秀的并发代码；</p><p>深入学习：熟练应用各种并发工具，了解在什么情况下使用哪些具体的技术和方法；</p><p>分析问题：掌握常见的多线程和并发问题分析技巧，知道排查一般问题的具体步骤；</p><p>积累经验：构建完整全面的并发编程知识体系，熟悉常见的面试问题和技巧，彻底掌握Java并发编程知识。</p><h4 id="详细内容：-2"><a href="#详细内容：-2" class="headerlink" title="详细内容："></a>详细内容：</h4><p>Java 多线程基础：线程、锁、synchronized、volatile/final、sleep/await/notify/fork/join；</p><p>Java 并发包基础：线程池 Executor、AQS/CAS、Atomic 原子操作、Lock/ReadWriteLock/Condition、Callable/Future；</p><p>Java 并发容器与工具：BlockingQueue/CopyOnWriteList/ConcurrentHashMap、CountDownLatch/CyclicBarrier/Semaphore等；</p><p>其他：万金油 ThreadLocal，化繁为简 Java8 parallelStream 等。</p><h3 id="模块四：开发框架–深入理解-Spring-等主流框架思想"><a href="#模块四：开发框架–深入理解-Spring-等主流框架思想" class="headerlink" title="模块四：开发框架–深入理解 Spring 等主流框架思想"></a>模块四：开发框架–深入理解 Spring 等主流框架思想</h3><h4 id="教学目标：-3"><a href="#教学目标：-3" class="headerlink" title="教学目标："></a>教学目标：</h4><p>重新认识主流开源技术框架，深入理解背后的原理和关系；</p><p>掌握整合各种框架的最佳实践，学会在工作中做技术框架选型；</p><p>了解主流框架的发展趋势，一线大厂的使用模式和关注点。</p><h4 id="学习和工作中的痛点：-3"><a href="#学习和工作中的痛点：-3" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>对主流开源技术框架，始终在会用、会做简单整合，不懂背后原理；</p><p>只会用自己熟悉的框架，不会做技术选型，也不了解一些最佳实践经验；</p><p>框架发展太快，学习跟不上了，也不太了解一线大厂使用主流框架的方式。</p><h4 id="通过学习掌握的核心能力：-3"><a href="#通过学习掌握的核心能力：-3" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：从更高的维度和更深入的原理，重新学习主流框架，了解框架的内在联系；</p><p>深入学习：掌握常见框架的一些最佳实践经验，能够根据具体的项目情况进行技术框架选型；</p><p>积累经验：了解常见主流框架的发展趋势，掌握最佳学习姿势，能够轻松驾驭技术发展。</p><h4 id="详细内容：-3"><a href="#详细内容：-3" class="headerlink" title="详细内容："></a>详细内容：</h4><p>Spring 技术体系（Spring Core/Web/MVC/Data/Messaging、Spring Boot 等）；</p><p>ORM 技术体系（JPA、Hibernate、MyBatis 等）。</p><h3 id="模块五：系统性能优化–学会性能分析与-MySQL-优化"><a href="#模块五：系统性能优化–学会性能分析与-MySQL-优化" class="headerlink" title="模块五：系统性能优化–学会性能分析与 MySQL 优化"></a>模块五：系统性能优化–学会性能分析与 MySQL 优化</h3><h4 id="教学目标：-4"><a href="#教学目标：-4" class="headerlink" title="教学目标："></a>教学目标：</h4><p>深入了解业务系统性能的度量分析方法，找到性能瓶颈和关键路径；</p><p>了解 MySQL 的性能关键点，学会如何进行 MySQL 和 SQL 语句的性能分析；</p><p>掌握如何编写高效的 SQL 语句，能对复杂的业务 SQL 进行性能优化。</p><h4 id="学习和工作中的痛点：-4"><a href="#学习和工作中的痛点：-4" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>性能调优能力是架构师/技术专家的核心能力之一，但是对这一块没经验；</p><p>遇到性能问题不知道从何下手、如何分析性能瓶颈在哪儿，也就不知道如何解决问题；</p><p>缺乏实际场景的练习，每次看别人讲的理论，都没办法转化到实际工作中去；</p><p>在面试过程中经常被问到分析调优的问题，总是觉得自己没有太多干货可讲。</p><h4 id="通过学习掌握的核心能力：-4"><a href="#通过学习掌握的核心能力：-4" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>深入学习：通过系统化的学习性能相关知识和实践经验，掌握复杂业务系统性能分析方法；</p><p>分析问题：掌握 SQL/索引/事务 的分析技巧，知道排查问题和优化 MySQL/SQL 的办法；</p><p>积累经验：掌握编写高性能 SQL 的技能，避免常见的各种低性能坑，提升数据库编程水平。</p><h4 id="详细内容：-4"><a href="#详细内容：-4" class="headerlink" title="详细内容："></a>详细内容：</h4><p>系统可观测性（日志、调用链跟踪、指标度量），80/20 优化原则，CPU、内存、磁盘/网络 IO 等分析；</p><p>MySQL 的锁、事务、索引、并发级别、死锁、执行计划、慢 SQL 统计、缓存失效、参数优化；</p><p>库表设计优化，引擎选择，表结构优化设计，列类型选择，索引设计，外键等；</p><p>SQL 查询优化，索引选择，连接优化，聚合查询优化，Union 优化，子查询优化，条件优化等；</p><p>场景分析，主键生成与优化，高效分页，快速导入导出数据，解决死锁问题等。</p><h3 id="模块六：超越分库分表–掌握海量业务数据的应对之道"><a href="#模块六：超越分库分表–掌握海量业务数据的应对之道" class="headerlink" title="模块六：超越分库分表–掌握海量业务数据的应对之道"></a>模块六：超越分库分表–掌握海量业务数据的应对之道</h3><h4 id="教学目标：-5"><a href="#教学目标：-5" class="headerlink" title="教学目标："></a>教学目标：</h4><p>从 0 掌握海量业务数据处理的关键技术，了解核心知识，参与实践案例；</p><p>全面学习 MySQL 主从复制架构，读写分离和数据库垂直/水平拆分；</p><p>学习应对系统不同类型数据的处理办法，对数据进行冷热分离，提升系统数据处理能力；</p><p>全面掌握各类场景下的读写分离，数据库拆分的框架和中间件，在实际工作中熟练使用。</p><h4 id="学习和工作中的痛点：-5"><a href="#学习和工作中的痛点：-5" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>只会增删改查，不了解对海量业务数据的处理办法；</p><p>每次被人问到 MySQL 的高可用和高性能架构，都不能清晰地讲明白；</p><p>缺乏实际场景的练习，不了解不同类型的数据对应的处理办法；</p><p>对于常见的读写分离、分库分表等技术，停留在理论阶段，没有动手实践过。</p><h4 id="通过学习掌握的核心能力：-5"><a href="#通过学习掌握的核心能力：-5" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：全面了解 MySQL 主从复制架构，读写分离和数据库垂直/水平拆分的应用场景和技术原理；</p><p>深入学习：进一步学会 MySQL 的高可用和高性能架构；</p><p>分析问题：掌握应对系统不同类型数据的处理办法，对数据进行冷热分离，提升系统数据处理能力；</p><p>积累经验：全面掌握各类场景下的读写分离，分库分表的框架和中间件，在实际工作中熟练使用。</p><h4 id="详细内容：-5"><a href="#详细内容：-5" class="headerlink" title="详细内容："></a>详细内容：</h4><p>MySQL 主从复制，Binlog，Row/Statement 模式，主从切换，读写分离，数据库扩容；</p><p>数据库垂直拆分与水平拆分，分库分表，分布式主键，分表算法，SQL 限制，数据迁移，实时同步；</p><p>Spring 动态切换数据库，TDDL/Sharding-JDBC 框架，MyCat/Sharding-Proxy 中间件；</p><p>数据库拆分的最佳实践，分布式事务的最佳实践，多租户的最佳实践。</p><h3 id="模块七：分布式服务–复杂业务系统架构演进必由之路"><a href="#模块七：分布式服务–复杂业务系统架构演进必由之路" class="headerlink" title="模块七：分布式服务–复杂业务系统架构演进必由之路"></a>模块七：分布式服务–复杂业务系统架构演进必由之路</h3><h4 id="教学目标：-6"><a href="#教学目标：-6" class="headerlink" title="教学目标："></a>教学目标：</h4><p>全面掌握 RPC 原理和常见的 RPC 技术；</p><p>深刻理解服务治理相关的技术和应用场景；</p><p>深入学习 Dubbo 和 Spring Cloud 的功能和技术原理；</p><p>深入了解微服务架构的特点和最佳实践。</p><h4 id="学习和工作中的痛点：-6"><a href="#学习和工作中的痛点：-6" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>会用简单的 RPC 和 REST，但是对其原理和细节不够了解；</p><p>一直没有实际接触过服务治理相关的技术，只知道几个名词，不清楚具体的功能和用法；</p><p>对 Dubbo 和 Spring Cloud 一知半解，简单作为 RPC 调用都会，再复杂的就不太清楚了；</p><p>微服务相关的知识都有些了解，但是不是很懂到底什么时候该做微服务，怎么做微服务。</p><h4 id="通过学习掌握的核心能力：-6"><a href="#通过学习掌握的核心能力：-6" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：系统的了解和学习 RPC 知识，知道每种 RPC 有什么特点，什么时候用什么 RPC 技术；</p><p>深入学习：全面的学习一遍服务治理的技术，能够认识到什么情况下使用哪种具体的特性；</p><p>分析问题：深刻理解 Dubbo 和 Spring Cloud 技术体系原理，遇到问题能够迅速定位和解决；</p><p>积累经验：深入了解微服务架构的特点和最佳实践经验，学会何时做微服务，如何做微服务。</p><h4 id="详细内容：-6"><a href="#详细内容：-6" class="headerlink" title="详细内容："></a>详细内容：</h4><p>基础知识：RPC、通信与数据协议、WebService、Hessian、REST、gRPC、Protocol Buffers 等；</p><p>服务化：服务治理、配置管理、注册发现、服务分组、版本管理、集群管理、负载均衡、限流与降级熔断等；</p><p>框架：Apache Dubbo 的功能与原理分析，Spring Cloud 体系，具体的案例实践；</p><p>微服务：微服务架构的 6 个最佳实践，从微服务到服务网格、云原生的介绍。</p><h3 id="模块八：分布式缓存–复杂业务系统访问提速第一法宝"><a href="#模块八：分布式缓存–复杂业务系统访问提速第一法宝" class="headerlink" title="模块八：分布式缓存–复杂业务系统访问提速第一法宝"></a>模块八：分布式缓存–复杂业务系统访问提速第一法宝</h3><h4 id="教学目标：-7"><a href="#教学目标：-7" class="headerlink" title="教学目标："></a>教学目标：</h4><p>深入理解缓存的应用场景和缓存策略；</p><p>全面掌握几种常见缓存问题的处理方式；</p><p>彻底掌握 Redis 缓存中间件，了解 Hazelcast 内存网格；</p><p>学会使用缓存技术实现排行数据展示，分布式 ID 生成等典型应用场景。</p><h4 id="学习和工作中的痛点：-7"><a href="#学习和工作中的痛点：-7" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>对缓存的认知停留在 JVM 内的静态 Map 和往 Redis 存 KV 数据，不了解什么时候该用缓存；</p><p>不熟悉常见的缓存问题处理方案，遇到问题难以解决，例如缓存失效和雪崩问题如何解决；</p><p>只了解简单的 Redis 操作，高级功能（例如集群或 Lua）没用过，其他缓存技术也没接触过；</p><p>没有在实际的应用场景里用 Redis 之类的缓存技术，不知道具体有哪些典型的应用场景。</p><h4 id="通过学习掌握的核心能力：-7"><a href="#通过学习掌握的核心能力：-7" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：掌握缓存的应用场景和常见的策略，特别是与数据库的同步；</p><p>深入学习：掌握常见的缓存问题的处理策略，将缓存技术应用到实际工作；</p><p>分析问题：全面掌握 Redis 缓存技术，能够分析和解决缓存问题；</p><p>积累经验：深入实践和掌握几个典型的应用场景，了解 Hazelcast 内存网格技术。</p><h4 id="详细内容：-7"><a href="#详细内容：-7" class="headerlink" title="详细内容："></a>详细内容：</h4><p>缓存的应用场景，缓存加载策略与失效策略，缓存与数据库同步等；</p><p>缓存预热、缓存失效、缓存击穿、缓存雪崩、多级缓存、缓存与 Spring+ORM 框架集成；</p><p>缓存中间件，Redis（几种常用数据结构、分布式锁、Lua 支持、集群），Hazelcast（Java 数据结构、内存网格、事务支持、集群）；</p><p>缓存的应用场景，排行数据展示，分布式 ID 生成，Session 共享，热点账户操作等。</p><h3 id="模块九：分布式消息–复杂业务系统关系解耦不二法门"><a href="#模块九：分布式消息–复杂业务系统关系解耦不二法门" class="headerlink" title="模块九：分布式消息–复杂业务系统关系解耦不二法门"></a>模块九：分布式消息–复杂业务系统关系解耦不二法门</h3><h4 id="教学目标：-8"><a href="#教学目标：-8" class="headerlink" title="教学目标："></a>教学目标：</h4><p>从 0 掌握消息队列（MQ）的关键技术，了解核心知识；</p><p>全面了解各类 MQ 技术的原理和特性，洞悉相关原理；</p><p>全面吃透 Kafka 的基本功能，集群搭建，高可用等，上手十八般武艺；</p><p>深入理解 MQ 的特点和应用场景，通过交易场景实战演练，并动手做一个简单的 MQ。</p><h4 id="学习和工作中的痛点：-8"><a href="#学习和工作中的痛点：-8" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>很少使用 MQ，就算用过也只是简单的收发消息，对 MQ 的原理和细节不了解；</p><p>不熟悉常见的几个主流 MQ，其中的多数技术都没有接触过，或者只听过名词；</p><p>缺乏实际场景的练习，每次看看书上的知识就忘，理解不深，无法做到融会贯通；</p><p>不太了解什么时候该用 MQ，MQ 能帮我们解决哪些方面的问题，带来什么样的好处。</p><h4 id="通过学习掌握的核心能力：-8"><a href="#通过学习掌握的核心能力：-8" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：掌握 MQ 的基础知识和常用工具，了解一般原理，知道 MQ 的一些基本概念；</p><p>深入学习：掌握各类 MQ 技术的一般原理和功能，知道如何根据实际需要选择使用合适的 MQ；</p><p>分析问题：掌握 Kafka 等主流 MQ 技术，能对一般的 MQ 问题进行分析和解决；</p><p>积累经验：了解 MQ 如何应用到一个具体的业务场景和 MQ 内部细节，彻底学会 JVM 知识。</p><h4 id="详细内容：-8"><a href="#详细内容：-8" class="headerlink" title="详细内容："></a>详细内容：</h4><p>消息队列的基本知识，Broker 与 Client，消息模式（点对点、发布订阅），消息协议（STOMP、JMS、AMQP、OpenMessaging 等），消息 QoS（最多一次、最少一次、有且仅有一次），消息重试，延迟投递，事务性，消息幂等与去重；</p><p>消息中间件：ActiveMQ 的简单入门，Kafka 的基本功能与使用，高可用（集群、分区、副本）、性能，RabbitMQ 和 RocketMQ，Pulsar 的简单介绍；</p><p>消息的 4 个主要功能，搭建一个 Kafka 集群，实现常用的消息发送、消息消费功能；</p><p>典型使用场景，使用 MQ 实现交易订单的处理，动手实现一个简化版的消息队列。</p><h3 id="模块十：分布式系统架构–如何设计高并发高可用的-Java-系统"><a href="#模块十：分布式系统架构–如何设计高并发高可用的-Java-系统" class="headerlink" title="模块十：分布式系统架构–如何设计高并发高可用的 Java 系统"></a>模块十：分布式系统架构–如何设计高并发高可用的 Java 系统</h3><h4 id="教学目标：-9"><a href="#教学目标：-9" class="headerlink" title="教学目标："></a>教学目标：</h4><p>了解大规模分布式的复杂业务系统架构技术发展脉络；</p><p>全面掌握业务系统发展不同阶段应该如何做技术选型；</p><p>以一个电商系统为例，深入学习如何分析系统架构；</p><p>掌握高并发高可用的分布式 Java 系统的设计方法。</p><h4 id="学习和工作中的痛点：-9"><a href="#学习和工作中的痛点：-9" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>没有机会去从头设计一个高并发的大规模分布式系统，缺乏对此类问题深入的学习和思考；</p><p>对业务系统架构发展不了解，技术思路一直停留在一个静态观念，一般只会选择自己熟悉的技术；</p><p>缺乏实际场景的练习，每次看看书上的知识就忘，面对复杂业务系统架构设计，总觉得无从下手；</p><p>平时从网上或书上看到各种零散的知识和经验，无法转化成自己的知识和能力，总是掌握不了。</p><h4 id="通过学习掌握的核心能力：-9"><a href="#通过学习掌握的核心能力：-9" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：了解大规模分布式的复杂业务系统架构技术发展脉络，从技术发展里借鉴经验；</p><p>深入学习：掌握业务系统发展不同阶段应该如何做技术选型，为系统选择合适的架构方案；</p><p>分析问题：深入理解如何基于系统的功能性和非功能性需求，进行详细的系统架构分析；</p><p>积累经验：掌握高并发高可用的分布式 Java 系统的设计方法，能够独立设计复杂业务系统。</p><h4 id="详细内容：-9"><a href="#详细内容：-9" class="headerlink" title="详细内容："></a>详细内容：</h4><p>业务分析、功能性需求、非功能性需求、高可用、高性能、稳定性、易用性、扩展性、可维护性、安全性等；</p><p>“4+1” Views、TOGAF、架构方案、业务架构、数据架构、设计文档、技术选型、部署文档、运维文档等；</p><p>分布式服务化、分布式消息中间件、分布式缓存、分布式文件系统、监控告警系统、权限与认证中心等。</p><h3 id="模块十一：业务系统重构–重构遗留系统是架构师的必修技能"><a href="#模块十一：业务系统重构–重构遗留系统是架构师的必修技能" class="headerlink" title="模块十一：业务系统重构–重构遗留系统是架构师的必修技能"></a>模块十一：业务系统重构–重构遗留系统是架构师的必修技能</h3><h4 id="教学目标：-10"><a href="#教学目标：-10" class="headerlink" title="教学目标："></a>教学目标：</h4><p>通过一个具体复杂电商业务系统的重构，掌握遗留系统重构的方法和经验；</p><p>了解一线大厂系统演进的具体案例，掌握如何解决老系统的各种疑难杂症；</p><p>学会如何解决困难的问题，协调资源，推动团队，完成看似不可能的目标。</p><h4 id="学习和工作中的痛点：-10"><a href="#学习和工作中的痛点：-10" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>实际工作中，我们并不是总能有机会从头去做一个大系统，维护和改造老系统，反而是更常见的任务；</p><p>遗留的老系统质量很差，经常出故障没文档，代码复杂且没人清楚细节，不知如何下手改造；</p><p>改造过程中，遇到很多具体的复杂技术难题，心里没底，各项估计也不准确；</p><p>涉及到的各方人员都不是很理解，也不怎么配合，阻力很大，工作难以推动。</p><h4 id="通过学习掌握的核心能力：-10"><a href="#通过学习掌握的核心能力：-10" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>深入学习：通过一个具体复杂电商业务系统的重构，学习遗留系统重构的方法和经验；</p><p>分析问题：了解如何评估遗留老系统，做出充分、详细、客观的分析报告；</p><p>积累经验：掌握业务系统重构改造中的一些通用性技术问题，以及推动工作的办法。</p><h4 id="详细内容：-10"><a href="#详细内容：-10" class="headerlink" title="详细内容："></a>详细内容：</h4><p>分析系统现状，给出明确的各项指标，了解各方对指标的期望和差距；</p><p>给出多个可选的改造或重做方案，明确各方案的优缺点，提供决策依据；</p><p>方案上的适当妥协，各方达成一致，快速推动重构工作启动和展开；</p><p>细化具体的方案细节，形成路径，争取足够的资源，恰当的时间窗口；</p><p>小步快跑，迅速取得阶段性成果，不影响业务整体的规划和发展；</p><p>保持业务连续性，多做监控、兼容和特性开关，给改造加上保险丝和缓冲区；</p><p>及时评估改进进展，更新方案和路线、资源和时间，推动改造顺利进行；</p><p>复盘总结相关经验，提出更多建议和改进办法，实现经验分享，方法复用。</p><h3 id="模块十二：架构师修炼之道–如何升级打怪终成一线技术专家"><a href="#模块十二：架构师修炼之道–如何升级打怪终成一线技术专家" class="headerlink" title="模块十二：架构师修炼之道–如何升级打怪终成一线技术专家"></a>模块十二：架构师修炼之道–如何升级打怪终成一线技术专家</h3><h4 id="教学目标：-11"><a href="#教学目标：-11" class="headerlink" title="教学目标："></a>教学目标：</h4><p>了解架构师应该具备的硬技能和软实力；</p><p>全面了解架构师典型的成长路径；</p><p>掌握一些实用的学习方法，借鉴一些成长经验；</p><p>学习如何准备相关的面试和求职。</p><h4 id="学习和工作中的痛点：-11"><a href="#学习和工作中的痛点：-11" class="headerlink" title="学习和工作中的痛点："></a>学习和工作中的痛点：</h4><p>总搞不清楚怎么样才能算是一名合格的架构师，总觉得是架构师很玄乎；</p><p>技术能力提升和软实力都遇到瓶颈，没人指导，找不到成长的突破口；</p><p>不知道什么好的学习方法和经验，总是走弯路，浪费了很多时间精力；</p><p>总是觉得自己面试准备的不好，发挥的不好，不能够给面试官足够好的评价。</p><h4 id="通过学习掌握的核心能力：-11"><a href="#通过学习掌握的核心能力：-11" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h4><p>夯实基础：学习架构师应该具备的硬技能和软实力，摸清自己哪些方面可以进一步提升；</p><p>深入学习：找到自己成长到下一个层次的突破口，制定相关的规划路径，实现成长；</p><p>借鉴方法：掌握一些实用的好方法和经验，能够让我们少走弯路，事半功倍；</p><p>积累经验：如何提前准备面试，怎样打磨简历突出亮点，如何在面试过程中脱颖而出。</p><h4 id="详细内容：-11"><a href="#详细内容：-11" class="headerlink" title="详细内容："></a>详细内容：</h4><p>分享我个人的成长第一手经验，升级打怪，成为架构师、技术专家、技术总监；</p><p>六个硬能力：技术能力、设计能力、抽象能力、管理能力、结构化思考能力、系统化分析能力；</p><p>七个软实力：大局观能力、沟通协作能力、持续学习能力、关注力、探索力、决策力、自我驱动力。加油！</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://shimo.im/docs/63WTTxkwCPHJdcyP/">https://shimo.im/docs/63WTTxkwCPHJdcyP/</a> 《Java1期文档汇总》，想复习的同学冲呀</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>巧目java面试题20210408</title>
      <link href="2021/04/08/java/%E9%9D%A2%E8%AF%95/%E5%B7%A7%E7%9B%AEjava%E9%9D%A2%E8%AF%95%E9%A2%9820210408/"/>
      <url>2021/04/08/java/%E9%9D%A2%E8%AF%95/%E5%B7%A7%E7%9B%AEjava%E9%9D%A2%E8%AF%95%E9%A2%9820210408/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a><strong>一、Java基础</strong></h1><p><strong>1. 实例方法和静态方法有什么不一样？</strong></p><p><strong>2. Java中的异常有哪几类？分别怎么使用？</strong></p><p>检出异常，非检出异常。检出异常需要try…catch才能编译通过。非检出异常不用try…catch也能编译通过。</p><p>RuntimeException是非检出异常，不需要try…catch也能编译通过。</p><p>IoException，SQLException等等其他所有异常都是检出异常，必须要try…catach才能编译通过。</p><p><strong>3. 常用的集合类有哪些？比如List如何排序？</strong></p><p>分两种，一种实现Set接口，一种是实现List接口的。</p><p>Set：TreeSet,HashSet.</p><p>List:ArrayList,LinkedList,Vector(线程安全)。</p><p>JDK7以前用collections.sort(list,Comparator).</p><p>JDK8直接用List.sort(Comparator).</p><p><strong>4. ArrayList和LinkedList内部的实现大致是怎样的？他们之间的区别和各自适应的场景是什么？</strong></p><p>ArrayList,是数组结构：少用与中间的增删。多用于查询，修改。每次增删元素顺序都会操作每个元素。</p><p>LinkedList,是链表结构：多用于中间，开头增删。少用查询，修改。查询时会遍历大量元素。</p><p><strong>5. 内存溢出是怎么回事？</strong></p><p>对象有被指向的引用，但是再也用不到它就是内存溢出了。</p><p>GC机制：复制回收，标记清除，引用计数（如果有循环引用后，会影响垃圾回收，所以JVM虚拟机没有采用此方法进行垃圾回收）。</p><p><strong>6. ClassLoader有什么用？</strong></p><p>类加载器：所有类都需要Classloader来加载。</p><p>BoostrapClassLoader，加载系统（java包下）的类，SystemClassLoader,加载系统扩展类(少用)，AppClassloader应用类加载器，还有针对每个项目的类加载器。</p><p><strong>7. ==和equals的区别？</strong></p><p>==判断对象物理地址。</p><p>equals判断对象Value是否相等。</p><p><strong>8. hashCode方法的作用？</strong></p><p>在hashMap中使用，把一个对象变成一个整型。hashCode规范，如果两个对象的equals返回true，那他们的hashCode必须相等，但是hashCode相等，不一定equals不一定相等。</p><p><strong>9. Object类中有哪些方法？列举3个以上。</strong></p><p>构造方法，toString()，equals，hashCode，getClass,finalize,clone,三个wait(),notify,notifyAll.</p><p><strong>10. NIO是什么？适用于何种场景？</strong></p><p> NIO是newIO,接口都是异步的，非阻塞的。</p><p><strong>12. HashMap数据结构、扩展策略，Hash冲突攻击如何防范，如何实现线程安全的HashMap？</strong></p><p> JDK7以前：数组里面存linkedList,hash冲突，升级到JDK8。</p><p>JDK8,数组里面加集合，如果对象hashCode相同，不可比较时就是linkedList，可比较就会用TreeSet进行排序处理（红黑树先访问小的）。hash冲突不用防范。如果对象不可比较且hash冲突，我们可适当实现可比较接口。</p><p>线程安全：ConcurrentHashMap(系统自带的线程安全的HashMap),Map&lt;Object, Object&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;&gt;()); synchronizedMap 为线程安全的Map.</p><p><strong>16. Java中一个字符占多少个字节，扩展再问int, long, double占多少字节</strong></p><p>一个字符两个字节，int 4 , long double 8 </p><p><strong>17. 创建一个类的实例都有哪些办法？</strong></p><p>new ，反射。</p><p><strong>18. final/finally/finalize的区别？</strong></p><p> final是类，变量，方法的修饰。类被修饰后不能再被继承。变量和方法被修饰不能再被修改</p><p>finally是try…catch后执行的finally，</p><p>finalize,在Object中的方法名，在此对象被回收前会执行这个方法。（当使用文件流时，如果对象被回收，没有关闭流，在底层就会实现内存泄露）</p><p><strong>19. LinkingBlockingQueue与ArrayBlockingQueue的区别，他们的适用场景？</strong></p><p>LinkingBlockQueue 链表实现的阻塞队列，适合一个一个放，一个一个取。</p><p>ArrayBlocakingQueue数组实现的阻塞队列，适合三个放，多个放，只适合多个取，不适合单个取。</p><p><strong>20. Session/Cookie的区别？</strong></p><p>Session存在服务器端。</p><p>Cookie存在客户端（浏览器上）。</p><p><strong>21. String/StringBuffer/StringBuilder的区别，扩展再问他们的实现？</strong></p><p>String 值不可变</p><p>StringBuffer 值可变，线程安全</p><p>StringBuilder 值可变，线程不安全</p><p><strong>22. Servlet的生命周期？</strong></p><p>初始化，服务处理（接收请求，处理请求，返回结果），销毁。</p><p><strong>23. 如何用Java分配一段连续的1G的内存空间？需要注意些什么？</strong></p><p>ByteBuffer.allocateDirect(1024<em>1024</em>1024);</p><p><strong>24. Java有自己的内存回收机制，但为什么还存在内存泄露的问题呢？</strong></p><p><strong>25. Java里面用对象作为Key需要注意些什么？ 如何实现hashcode？</strong> </p><p>对象放进去了hash值不能变。hashCode的值尽量不等。</p><h2 id="java的多态表现在哪里"><a href="#java的多态表现在哪里" class="headerlink" title="java的多态表现在哪里"></a><strong>java的多态表现在哪里</strong></h2><p>主要有两种表现形式：重载和重写</p><p><strong>重载：</strong></p><p>是发生在同一类中，具有相同的方法名，主要是看参数的个数，类型，顺序不同实现方法的重载的，返回值的类型可以不同。</p><p><strong>重写：</strong></p><p>是发生在两个类中（父类和子类），具有相同的方法名，主要看方法中参数，个数，类型必须相同，返回值的类型必须相同。</p><h2 id="List和Set比较，各自的子类比较"><a href="#List和Set比较，各自的子类比较" class="headerlink" title="List和Set比较，各自的子类比较"></a><strong>List和Set比较，各自的子类比较</strong></h2><p><strong>对比一：Arraylist与LinkedList的比较</strong></p><p>1、ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p><p>2、因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p><p>3、LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。</p><p>4、因为LinkedList要移动指针,所以查询操作性能比较低。</p><p><strong>适用场景分析：</strong></p><p>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p><p><strong>对比二：ArrayList与Vector的比较</strong></p><p>1、Vector的方法都是同步的，是线程安全的，而ArrayList的方法不是，由于线程的同步必然要影响性能。因此，ArrayList的性能比Vector好。<br>2、当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样。ArrayList就有利于节约内存空间。</p><p>3、大多数情况不使用Vector，因为性能不好，但是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。</p><p>4、Vector可以设置增长因子，而ArrayList不可以。</p><p><strong>适用场景分析：</strong></p><p>1、Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</p><p>2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</p><p><strong>对比三：HashSet与TreeSet的比较</strong></p><p>1.TreeSet 是二叉树实现的，Treeset中的数据是自动排好序的，不允许放入null值 。</p><p>2.HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 。</p><p>3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例。</p><p><strong>适用场景分析：</strong></p><p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p><hr><h2 id="HashMap和ConcurrentHashMap的区别"><a href="#HashMap和ConcurrentHashMap的区别" class="headerlink" title="HashMap和ConcurrentHashMap的区别"></a><strong>HashMap和ConcurrentHashMap的区别</strong></h2><p>1、HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。</p><p>2、ConcurrentHashMap采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在这个片段上面进行插入，而且这里还需要获取segment锁。</p><p>3、ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。</p><p>至于两者的底层实现，你如果想通过一篇文章就理解了，那就too young了，好好找些博文+看源码去吧。</p><hr><h2 id="HashTable和ConcurrentHashMap的区别"><a href="#HashTable和ConcurrentHashMap的区别" class="headerlink" title="HashTable和ConcurrentHashMap的区别"></a><strong>HashTable和ConcurrentHashMap的区别</strong></h2><p>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p><hr><h2 id="String-StringBuffer和StringBuilder的区别"><a href="#String-StringBuffer和StringBuilder的区别" class="headerlink" title="String,StringBuffer和StringBuilder的区别"></a><strong>String,StringBuffer和StringBuilder的区别</strong></h2><p>1、运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String。</p><p>2、线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。</p><p><strong>适用场景分析：</strong></p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p><hr><h2 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><strong>wait和sleep的区别</strong></h2><p>1、sleep()方法是属于Thread类中的，而wait()方法，则是属于Object类中的。</p><p>2、sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。所以在调用sleep()方法的过程中，线程不会释放对象锁。</p><p>3、调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p><h2 id="BIO、NIO和AIO的区别"><a href="#BIO、NIO和AIO的区别" class="headerlink" title="BIO、NIO和AIO的区别"></a><strong>BIO、NIO和AIO的区别</strong></h2><p>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>Java AIO： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p><em>NIO比BIO的改善之处是把一些无效的连接挡在了启动线程之前，减少了这部分资源的浪费（因为我们都知道每创建一个线程，就要为这个线程分配一定的内存空间）</em></p><p><em>AIO比NIO的进一步改善之处是将一些暂时可能无效的请求挡在了启动线程之前，比如在NIO的处理方式中，当一个请求来的话，开启线程进行处理，但这个请求所需要的资源还没有就绪，此时必须等待后端的应用资源，这时线程就被阻塞了。</em></p><p><strong>适用场景分析：</strong></p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解，如之前在Apache中使用。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持，如在 Nginx，Netty中使用。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持，在成长中，Netty曾经使用过，后来放弃。</p><h2 id="（转发）forward与（重定向）redirect的区别"><a href="#（转发）forward与（重定向）redirect的区别" class="headerlink" title="（转发）forward与（重定向）redirect的区别"></a><strong>（转发）forward与（重定向）redirect的区别</strong></h2><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来,然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址。</p><p>redirect是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL。</p><p>forward转发页面和转发到的页面可以共享request里面的数据。</p><p>redirect不能共享数据。</p><p>redirect不仅可以重定向到当前应用程序的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源。</p><p>forward只能在同一个Web应用程序内的资源之间转发请求。</p><p>forward是服务器内部的一种操作。</p><p>redirect是服务器通知客户端，让客户端重新发起请求。</p><p>forward一般用于用户登陆的时候根据角色转发到相应的模块。</p><p>redirect一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</p><p>forward效率高。</p><p>redirect效率低。</p><h2 id="请写一段栈溢出、堆溢出的代码【数据和方法分别存放在哪里】"><a href="#请写一段栈溢出、堆溢出的代码【数据和方法分别存放在哪里】" class="headerlink" title="请写一段栈溢出、堆溢出的代码【数据和方法分别存放在哪里】"></a><strong>请写一段栈溢出、堆溢出的代码</strong>【数据和方法分别存放在哪里】</h2><p>递归调用可以导致栈溢出<br>不断创建对象可以导致堆溢出</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token class-name">ArrayList</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span> <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         num<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>          <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token class-name">Test</span>  t  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         t<span class="token punctuation">.</span><span class="token function">testHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         t<span class="token punctuation">.</span><span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、JVM"><a href="#二、JVM" class="headerlink" title="二、JVM"></a><strong>二、JVM</strong></h1><ol><li><p>JVM堆的基本结构。</p></li><li><p>JVM的垃圾算法有哪几种？CMS收集算法的流程？</p></li><li><p>JVM有哪些常用启动参数可以调整？</p></li><li><p>如何查看JVM的内存使用情况？</p></li><li><p>Java程序是否会内存溢出？</p></li><li><p><strong>你常用的JVM配置和调优参数都有哪些？分别什么作用？</strong></p></li><li><p>Java内存分代模型，GC算法，JVM常见的启动参数； </p></li><li><p>CMS算法的过程，CMS回收过程中JVM是否需要暂停</p></li><li><p>什么情况下会出现OOM（堆内存，永久区，堆外区，方法栈）</p></li><li><p>Java内存结构（堆结构，新生代[S0/S1/Elden]，年老代，持久代）</p></li><li><p>常用的GC策略，什么时候会触发YGC，什么时候触发FGC </p></li></ol><p><strong>13. JVM内存结构，GC算法，CMS、G1的原理</strong> </p><ol start="14"><li><strong>NIO模型，select/epoll的区别，多路复用的原理</strong></li></ol><h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a><strong>JVM的内存结构</strong></h2><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><p><strong>1、Java虚拟机栈：</strong></p><p>线程私有；每个方法在执行的时候会创建一个栈帧，存储了局部变量表，操作数栈，动态连接，方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。</p><p><strong>2、堆：</strong></p><p>线程共享；被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。</p><p><strong>3、方法区：</strong></p><p>线程共享；被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息，常量，静态变量等。</p><p><strong>4、程序计数器：</strong></p><p>线程私有；是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</p><p><strong>5、本地方法栈：</strong></p><p>线程私有；主要为虚拟机使用到的Native方法服务。</p><h2 id="java中常说的堆和栈，分别是什么数据结构；另外，为什么要分为堆和栈来存储数据"><a href="#java中常说的堆和栈，分别是什么数据结构；另外，为什么要分为堆和栈来存储数据" class="headerlink" title="java中常说的堆和栈，分别是什么数据结构；另外，为什么要分为堆和栈来存储数据"></a><strong>java中常说的堆和栈，分别是什么数据结构；另外，为什么要分为堆和栈来存储数据</strong></h2><p>栈是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。</p><p>堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的。</p><h2 id="为什么要划分堆和栈-堆栈分别是什么作用"><a href="#为什么要划分堆和栈-堆栈分别是什么作用" class="headerlink" title="为什么要划分堆和栈/堆栈分别是什么作用"></a><strong>为什么要划分堆和栈</strong>/堆栈分别是什么作用</h2><p>1、从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。</p><p>2、堆与栈的分离，使得堆中的内容可以被多个栈共享。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p><p>3、栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p><p>4、体现了Java面向对象这一核心特点（也可以继续说一些自己的理解）</p><hr><h2 id="强引用，软引用和弱引用的区别"><a href="#强引用，软引用和弱引用的区别" class="headerlink" title="强引用，软引用和弱引用的区别"></a><strong>强引用，软引用和弱引用的区别</strong></h2><p><strong>强引用：</strong></p><p>只有这个引用被释放之后，对象才会被释放掉，只要引用存在，垃圾回收器永远不会回收，这是最常见的New出来的对象。</p><p><strong>软引用：</strong></p><p>内存溢出之前通过代码回收的引用。软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p><p><strong>弱引用：</strong></p><p>第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。</p><h2 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h2><p>Java语言中一个显著的特点就是引入了垃圾回收机制，这个大家都清楚，垃圾回收的概念这里也不做介绍，重点是垃圾回收是在什么时候开始？对什么东西，做了什么事情？</p><p><strong>GC何时开始：</strong></p><p>所有的回收器类型都是基于分代技术来实现的，那就必须要清楚对象按其生命周期是如何划分的。</p><p><strong>年轻代：</strong>划分为三个区域：原始区(Eden)和两个小的存活区(Survivor)，两个存活区按功能分为From和To。绝大多数的对象都在原始区分配，超过一个垃圾回收操作仍然存活的对象放到存活区。垃圾回收绝大部分发生在年轻代。</p><p><strong>年老代：</strong> 存储年轻代中经过多个回收周期仍然存活的对象，对于一些大的内存分配，也可能直接分配到永久代。</p><p><strong>持久代：</strong> 存储类、方法以及它们的描述信息，这里基本不产生垃圾回收。</p><p><strong>有了以上这些铺垫之后开始回答GC何时开始：</strong></p><p>Eden内存满了之后，开始Minor GC（从年轻代空间回收内存被称为 Minor GC）；升到老年代的对象所需空间大于老年代剩余空间时开始Full GC（但也可能小于剩余空间时，被HandlePromotionFailure参数强制Full GC）</p><p><strong>对什么东西操作，即垃圾回收的对象是什么：</strong></p><p>从root开始搜索没有可达对象，而且经过第一次标记、清理后，仍然没有复活的对象。</p><p><strong>做了什么东西：</strong></p><p>主要做了清理对象，整理内存的工作。具体的引申如下</p><p><strong>垃圾回收器的类型：</strong></p><ul><li>串行垃圾回收器（Serial Garbage Collector）</li><li>并行垃圾回收器（Parallel Garbage Collector）</li><li>并发标记扫描垃圾回收器（CMS Garbage Collector）</li><li>G1垃圾回收器（G1 Garbage Collector）</li></ul><p><strong>垃圾回收算法：</strong></p><ul><li>引用计数法</li><li>标记清除法</li><li>复制算法</li><li>标记压缩算法</li><li>分代算法</li><li>分区算法</li><li>类在虚拟机中的加载过程</li></ul><p>加载Loading：</p><p>通过一个类的全限定名来获取一个二进制字节流、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><p><strong>验证Verification：</strong></p><ul><li>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机的自身安全。</li></ul><p><strong>准备Preparation：</strong></p><ul><li>正式为类变量分配内存并设置类变量初始值。</li></ul><p><strong>解析Resolution：</strong></p><ul><li>虚拟机将常量池内的符号引用替换为直接引用的过程。</li></ul><p><strong>初始化Initialization：</strong></p><ul><li>类加载过程的最后一步，到了这个阶段才真正开始执行类中定义的Java程序代码。</li></ul><p><strong>使用Using：</strong></p><ul><li>根据你写的程序代码定义的行为执行。</li></ul><p><strong>卸载Unloading：</strong></p><ul><li>GC负责卸载，这部分一般不用讨论。</li><li>强引用、软引用、弱引用、虚引用与GC的关系</li><li><strong>强引用：</strong> new出的对象之类的引用，只要强引用还在，永远不会回收。</li><li><strong>软引用：</strong> 引用但非必须的对象，内存溢出异常之前回收。</li><li><strong>弱引用：</strong> 非必须的对象，对象只能生存到下一次垃圾收集发生之前。</li><li><strong>虚引用：</strong> 对生存时间无影响，在垃圾回收时得到通知。</li></ul><h1 id="三、数据结构与算法基础"><a href="#三、数据结构与算法基础" class="headerlink" title="三、数据结构与算法基础"></a><strong>三、数据结构与算法基础</strong></h1><ol><li><p>说一下几种常见的排序算法和分别的复杂度。</p></li><li><p>什么是跳表？</p></li><li><p>如何确认一个链表有环？进一步，确认环的位置。</p></li><li><p>如何遍历一棵二叉树？</p></li><li><p>倒排一个LinkedList。  </p></li><li><p>HashSet的实现方式</p></li></ol><h1 id="四、多线程-并发"><a href="#四、多线程-并发" class="headerlink" title="四、多线程/并发"></a><strong>四、多线程/并发</strong></h1><p><strong>1. Java中常见的锁</strong></p><p>互斥锁，读写锁，信号量</p><p>互斥锁，读写只能一个线程</p><p>读写锁，写只能一个线程，读可以多个线程</p><p>信号量，如停车场，能允许一定量的线程，满了则不能再进入，需要等别的线程释放资源。</p><ol start="2"><li>原子Atomic类，如何保证原子性，CAS硬件指令</li></ol><p>在atomic类底层使用CAS硬件指令，来保证atomic的原子性。CAS在硬件级别实现了原子操作。</p><ol start="3"><li>volatile，可见性问题的原因，硬件架构，L3 Cache，QPI，乐观锁</li></ol><p>volatile：易变的。被修饰的变量在多线程中被改变时，别的线程能知道。</p><ol start="4"><li>如何实现一个线程安全的数据结构</li></ol><p>new 一个volatile 的Atomatic变量，或者使用concurrent类型的集合，ConcurrentHashMap之类的。</p><ol start="5"><li>如何避免死锁</li></ol><p>如果有两个锁的时候，如果先锁住第一个参数，再锁住第二个参数，这种情况就会产生死锁。</p><p>比如，第一个参数是A，第二个参数是B，如果第一个参数先锁，第二个参数后锁。在刚好锁住第一个参数，第二次请求来了，刚好两个参数颠倒了就会锁住第二个参数，那就会造成死锁。</p><p>解决死锁：在需要锁住多个参数的时候，先把参数按固定的顺序排序，然后在对排序后的参数加锁，这样就有效的避免死锁。</p><ol start="6"><li>如何解决ABA问题</li></ol><p>ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</p><p>用另一个标识判断某值是否有改变过。</p><ol start="7"><li>Synchronized关键字的作用？</li></ol><p>对Synchronized（）括号内的对象加互斥锁，不影响父类或者子类的访问。</p><ol start="8"><li>Volatile关键字的作用？</li></ol><p>可见的，当其中一个线程改变了volatile的变量时，别的使用这个变量的线程都能读取到最新值。</p><p><img src="https://images2015.cnblogs.com/blog/735249/201612/735249-20161209104429585-380774315.jpg" alt="img"></p><p>但是，这个并不能解决并发问题。比如第一个线程读取到值是3，第二个线程也读取了3，然后第一个线程+1放入了write区，第二个线程+1也放到了write区，那么两个线程的值都是4，期望值是5，这时候还是会造成并发问题。</p><ol start="9"><li>Java内存模型是怎样的？</li></ol><p><img src="https://images2015.cnblogs.com/blog/735249/201612/735249-20161209104648960-534172466.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">1``. 方法区：``a. 方法区是各线程共享内存的区域。``b. 它存放类的信息、``static``变量、常量（常量池包含于方法区）、即时编译器编译后的代码数据。``c. 它属于非堆部分。`` ` `2``. 堆（先进先出）：``a. 堆是内存最大的一块区域，堆是各线程共享内存的区域。``b. 堆中存放被创建的实例对象、数组。``c. 堆是GC管理的主要区域。`` ` `3``. 栈（先进后出）：``a. 栈是线程私有的，它的生命周期与线程相同。线程生命周期（创建，就绪，运行，阻塞，死亡）``b. 栈是java方法执行的内存模型：``  ``每个方法执行时会在栈中创建一个栈帧（stack frame），用于存放 局部变量表、操作栈、动态链接、方法出口等信息。方法从执行开始就完成了 压栈 到 弹栈 的过程。``  ``局部变量表中存放了基本数据类型（``int``,``short``,``long``,``char``,``byte``,``float``,``double``,``boolean``，其中``long``、``double` `两个``64``位长度的类型会占用两个局部变量空间、其他的只占一个）、对象引用（并非本身，引用指向堆中的对象地址）、方法返回类型。``  ``局部变量表所需控件在编译时就已经确定了，因此方法运行期间不会改变其内存大小。`` ` `4``. 本地方法栈：``a. 与java虚拟机栈功能类似，区别在于服务对象不同，该栈服务于jvm使用的``native``方法。`` ` `5``. 程序计数器：``a. 每条线程执行时都有自己的程序计数器，互不影响。``b. 程序计数器指向该计数器的拥有者（线程）下一步执行的位置。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　</p><ol start="10"><li>HashMap在多线程环境下使用需要注意什么？为什么？</li></ol><p>在多线程环境下，需要使用ConcurrentHashMap，因为HashMap是线程不安全的，如果多线程操作，会造成不可预期的结果。</p><ol start="11"><li>Java程序中启动一个线程是用run()还是start()？</li></ol><p>start()是重新开启一个线程运行。 如果是run()，那就相当于在当前线程运行，并不会新创建一个线程运行。</p><ol start="12"><li>什么是守护线程？有什么用？</li></ol><p>守护线程是运行在后端的线程，当系统停止运行，守护线程也就停止了。</p><p>进行内存回收,垃圾清理等工作</p><ol start="13"><li>什么是死锁？如何避免</li></ol><p>原因：</p><p>（1） 因为系统资源不足。<br>（2） 进程运行推进的顺序不合适。<br>（3） 资源分配不当等。</p><p>死锁必要条件：</p><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p><img src="https://images2015.cnblogs.com/blog/735249/201612/735249-20161209144549163-61957483.png" alt="img"></p><p>A线程锁住的资源被B线程锁住了，然后B线程需要的资源被A线程锁住了，这时候就会造成死锁。</p><p>避免这种死锁的方法，当需要锁住多个资源的时候，那就先对资源进行排序，然后再加锁，就会有效的防止死锁。</p><p>还有饥饿锁，当优先级高的不断获得资源，优先级低的一直获取不到资源，也会造成死锁。</p><p>谦让锁，当几个线程共同获取资源，就会线程先停止，让别的线程先执行。如果每个线程都这样，那就会一起谦让，也会造成死锁。</p><ol start="14"><li>线程和进程的差别是什么？</li></ol><p>线程是进程的实现，进程是线程的体现。进程是独立的，线程运行在进程内。进程内可以有多个线程同时运行着。</p><p>线程是在代码层面上，进程是在服务器CPU内存上。</p><ol start="15"><li><p>Java里面的Threadlocal是怎样实现的？</p></li><li><p>ConcurrentHashMap的实现原理是？</p></li></ol><p>对大数组的每个值进行分离加锁，实现了锁分离。</p><ol start="17"><li>sleep和wait区别</li></ol><p>sleep是占用着cpu阻塞，wait是不占用cpu阻塞。</p><ol start="18"><li>notify和notifyAll区别</li></ol><p>通知处在等待该对象的线程</p><p>notifyAll使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。</p><p>notify是通知其中一个线程，而不会通知别的线程。</p><ol start="19"><li><p>volatile关键字的作用</p></li><li><p>ThreadLocal的作用与实现</p></li><li><p>两个线程如何串行执行</p></li><li><p>上下文切换是什么含义</p></li><li><p>可以运行时kill掉一个线程吗？</p></li><li><p>什么是条件锁、读写锁、自旋锁、可重入锁？</p></li><li><p>什么是协程（用户态线程，减少数据拷贝，降低CPU开销，无callback函数）？</p></li><li><p>线程池ThreadPoolExecutor的实现原理？</p></li><li><p>J.U.C下的常见类的使用。lock, synchronized， ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</p></li><li><p>各种常见锁使用如果上面这些掌握很好，还可以看看更深一点的 False Sharing，Cache Line，可见性与原子性等； </p></li></ol><h2 id="什么是线程死锁？死锁如何产生？如何避免线程死锁？"><a href="#什么是线程死锁？死锁如何产生？如何避免线程死锁？" class="headerlink" title="什么是线程死锁？死锁如何产生？如何避免线程死锁？"></a><strong>什么是线程死锁？死锁如何产生？如何避免线程死锁？</strong></h2><p><strong>死锁的介绍：</strong></p><p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。</p><p><strong>死锁的产生的一些特定条件：</strong></p><p><strong>1、</strong> 互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 。</p><p><strong>2、</strong> 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</p><p><strong>3、</strong> 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用。</p><p><strong>4、</strong> 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。</p><p><strong>如何避免：</strong></p><p><strong>1、</strong> 加锁顺序：</p><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。当然这种方式需要你事先知道所有可能会用到的锁，然而总有些时候是无法预知的。</p><p><strong>2、</strong> 加锁时限：</p><p>加上一个超时时间，若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。但是如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。</p><p><strong>3、</strong> 死锁检测：</p><p>死锁检测即每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p><h2 id="notify和notifyAll区别"><a href="#notify和notifyAll区别" class="headerlink" title="notify和notifyAll区别"></a><strong>notify和notifyAll区别</strong></h2><p><strong>他们的作用都是通知处于等待该对象的线程。</strong></p><p><strong>1、</strong> notifyAll使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。</p><p><strong>2、</strong> notify是通知其中一个线程，不会通知所有的线程。</p><h1 id="五、Linux使用与问题分析排查"><a href="#五、Linux使用与问题分析排查" class="headerlink" title="五、Linux使用与问题分析排查"></a><strong>五、Linux使用与问题分析排查</strong></h1><ol><li><p>硬链接和软链接的区别？</p></li><li><p>inode是什么？</p></li><li><p>Linux常用命令有哪些？</p></li><li><p>怎么看一个Java线程的资源耗用？</p></li><li><p>Load过高的可能性有哪些？</p></li><li><p>/etc/hosts文件什么做用？</p></li><li><p>/etc/resolv.conf文件什么作用？</p></li><li><p>如何快速的将一个文本中所有“abc”替换为“xyz”？</p></li><li><p>你常用的Linux下用来进行网络和磁盘IO分析的工具有哪些？</p></li><li><p>你常用的Linux下用来进行内存和CPU分析的工具有哪些？</p></li><li><p>发现磁盘空间不够，如何快速找出占用空间最大的文件？</p></li><li><p>Java服务端问题排查（OOM，CPU高，Load高，类冲突）</p></li><li><p>Java常用问题排查工具及用法（top, iostat, vmstat, sar, tcpdump, jvisualvm, jmap, jconsole）</p></li><li><p>Thread dump文件如何分析（Runnable，锁，代码栈，操作系统线程ID关联）</p></li><li><p>grep，awk，sed； 是否自己写过shell脚本；</p></li><li><p>常见的cpu load过高，us过高，一般是什么问题。引申出是否用过top，jstat，jstack等。</p></li><li><p>常见的内存问题一般有哪些。 引申出是否用过free，top， jmap等。</p></li></ol><h1 id="六、框架使用"><a href="#六、框架使用" class="headerlink" title="六、框架使用"></a><strong>六、框架使用</strong></h1><ol><li><p>Spring中Bean的生命周期。</p></li><li><p>SpringMVC或Struts处理请求的流程。</p></li><li><p>Spring AOP解决了什么问题？怎么实现的？aop与cglib，与asm的关系。</p></li><li><p>Spring事务的传播属性是怎么回事？它会影响什么？</p></li><li><p>Spring中BeanFactory和FactoryBean有什么区别？</p></li><li><p>Spring框架中IOC的原理是什么？</p></li><li><p>spring的依赖注入有哪几种方式</p></li><li><p>struts工作流程</p></li><li><p>用Spring如何实现一个切面？</p></li><li><p>Spring 如何实现数据库事务？</p></li><li><p>Hibernate和Ibatis这类ORM框架的区别？什么是ORM，解决的痛点是什么？</p></li><li><p>spriong ioc的生命周期，（init-method，intilizingbean接口方法afterPropertiesSet的先后顺序）等。</p></li><li><p>Hibernate对一二级缓存的使用，Lazy-Load的理解；</p></li><li><p>Spring IoC AOP自己用代码如何实现</p></li><li><p>RPC的负载均衡、服务发现怎么做的</p></li><li><p>几种推送模型的区别，long polling，websocket </p></li></ol><h2 id="springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的"><a href="#springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的" class="headerlink" title="springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的"></a><strong>springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的</strong></h2><p><strong>核心：</strong></p><p>控制反转和面向切面</p><p><strong>请求处理流程：</strong></p><p>1、首先用户发送请求到前端控制器，前端控制器根据请求信息（如URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；</p><p>2、页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView（模型数据和逻辑视图名）；</p><p>3、前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；</p><p>4、前端控制器再次收回控制权，将响应返回给用户。</p><p><strong>控制反转如何实现：</strong></p><p>我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。</p><p>spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。</p><p>因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。</p><p>A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。</p><h2 id="说一下spring中Bean的作用域"><a href="#说一下spring中Bean的作用域" class="headerlink" title="说一下spring中Bean的作用域"></a>说一下spring中Bean的作用域</h2><p><strong>singleton：</strong></p><p>Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域。</p><p><strong>prototype：</strong></p><p>每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。</p><p><strong>request：</strong></p><p>在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。</p><p><strong>session：</strong></p><p>在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。</p><p><strong>global Session：</strong></p><p>在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p><p>说一下spring中Bean的生命周期</p><p>实例化一个Bean，也就是我们通常说的new。</p><p>按照Spring上下文对实例化的Bean进行配置，也就是IOC注入。</p><p>如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的是Spring配置文件中Bean的ID。</p><p>如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传递的是Spring工厂本身（可以用这个方法获取到其他Bean）。</p><p>如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文。</p><p>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。</p><p>如果这个Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p><p>如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialization(Object obj, String s)方法。</p><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法。</p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><p>对Spring中依赖注入两种方式的认识</p><p><strong>两种注入方式为：构造方法注入和设值注入</strong></p><p>设值注入与传统的JavaBean的写法更相似，程序员更容易理解、接受，通过setter方式设定依赖关系显得更加直观、明显;</p><p>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而会产生浪费。而使用设置注入，则避免这下问题;</p><p>在某些属性可选的情况下，多参数的构造器更加笨拙，官方更鼓励使用设值注入。</p><p>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p><p>对于依赖关系无须变化的Bean，构造注入更有用处，因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不用担心后续代码对依赖关系的破坏。</p><p>构造注入使依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</p><p>设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。</p><p>建议采用以设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入;而其他的依赖关系的注入，则考虑采用set注入。</p><h2 id="说一下Spring的核心模块"><a href="#说一下Spring的核心模块" class="headerlink" title="说一下Spring的核心模块"></a><strong>说一下Spring的核心模块</strong></h2><p><strong>Spring Core【核心容器】：</strong> 核心容器提供了Spring的基本功能。核心容器的核心功能是用IOC容器来管理类的依赖关系。</p><p><strong>Spring AOP【面向切面】：</strong> Spring的AOP模块提供了面向切面编程的支持。SpringAOP采用的是纯Java实现，采用基于代理的AOP实现方案，AOP代理由IOC容器负责生成、管理，依赖关系也一并由IOC容器管理。</p><p><strong>Spring ORM【对象实体映射】：</strong> 提供了与多个第三方持久层框架的良好整合。</p><p>**Spring DAO【持久层模块】： ** Spring进一步简化DAO开发步骤，能以一致的方式使用数据库访问技术，用统一的方式调用事务管理，避免具体的实现侵入业务逻辑层的代码中。</p><p><strong>Spring Context【应用上下文】：</strong> 它是一个配置文件，为Spring提供上下文信息，提供了框架式的对象访问方法。</p><p><strong>Spring Web【Web模块】：</strong> 提供了基础的针对Web开发的集成特性。</p><p><strong>Spring MVC【MVC模块】：</strong> 提供了Web应用的MVC实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型。</p><h2 id="Spring框架中都用到了哪些设计模式？"><a href="#Spring框架中都用到了哪些设计模式？" class="headerlink" title="Spring框架中都用到了哪些设计模式？"></a><strong>Spring框架中都用到了哪些设计模式？</strong></h2><p><strong>代理模式：</strong> 在AOP和remoting中被用的比较多。</p><p><strong>单例模式：</strong> 在spring配置文件中定义的bean默认为单例模式。</p><p><strong>模板方法模式：</strong> 用来解决代码重复的问题。</p><p><strong>前端控制器模式：</strong> Spring提供了DispatcherServlet来对请求进行分发。</p><p><strong>依赖注入模式：</strong> 贯穿于BeanFactory / ApplicationContext接口的核心理念。</p><p><strong>工厂模式：</strong> BeanFactory用来创建对象的实例。</p><p><strong>BeanFactory 和ApplicationContext的区别</strong></p><p>BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。</p><p>BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。</p><p>ApplicationContext提供的额外的功能：国际化的功能、消息发送、响应机制、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。</p><p>加载方式的区别：BeanFactory采用的是延迟加载的形式来注入Bean；ApplicationContext则相反的，它是在Ioc启动时就一次性创建所有的Bean,好处是可以马上发现Spring配置文件中的错误，坏处是造成浪费。</p><h2 id="mybatis如何处理结果集"><a href="#mybatis如何处理结果集" class="headerlink" title="mybatis如何处理结果集"></a><strong>mybatis如何处理结果集</strong></h2><p>MyBatis的结果集是通过反射来实现的。并不是通过get/set方法。在实体类中无论是否定义get/set()方法，都是可以接收到的。</p><hr><hr><p><strong>接口有什么用</strong></p><p>1、通过接口可以实现不相关类的相同行为，而不需要了解对象所对应的类。</p><p>2、通过接口可以指明多个类需要实现的方法。</p><p>3、通过接口可以了解对象的交互界面，而不需了解对象所对应的类。</p><p>另：Java是单继承，接口可以使其实现多继承的功能。</p><h1 id="七、数据库相关"><a href="#七、数据库相关" class="headerlink" title="七、数据库相关"></a><strong>七、数据库相关</strong></h1><ol><li><p>MySQL InnoDB的特点？</p></li><li><p>乐观锁和悲观锁的区别？</p></li><li><p>数据库隔离级别是什么？有什么作用？</p></li><li><p>MySQL主备同步的基本原理。</p></li><li><p>如何从一张表中查出name字段包含“XYZ”的所有行？</p></li><li><p>索引数据结构（字典+BitTree）</p></li><li><p>如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）</p></li><li><p>SQL什么情况下不会使用索引（不包含，不等于，函数）</p></li><li><p>一般在什么字段上建索引（过滤数据最多的字段）</p></li><li><p>如何从一张表中查出name字段不包含“XYZ”的所有行？</p></li><li><p>MySQL，B+索引实现，行锁实现，SQL优化</p></li><li><p>Redis，RDB和AOF，如何做高可用、集群</p></li><li><p>如何解决高并发减库存问题</p></li><li><p>mysql存储引擎中索引的实现机制；</p></li><li><p>数据库事务的几种粒度；</p></li><li><p>行锁，表锁；乐观锁，悲观锁 </p></li></ol><h2 id="mysql优化经验"><a href="#mysql优化经验" class="headerlink" title="mysql优化经验"></a><strong>mysql优化经验</strong></h2><p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p><p>3、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>4、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>5、避免频繁创建和删除临时表，以减少系统表资源的消耗。诸如此类，等等等等……</p><p>6、什么时候索引会失效</p><h2 id="悲观锁和乐观锁的区别，怎么实现"><a href="#悲观锁和乐观锁的区别，怎么实现" class="headerlink" title="悲观锁和乐观锁的区别，怎么实现"></a><strong>悲观锁和乐观锁的区别，怎么实现</strong></h2><p>悲观锁：一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放。</p><p>乐观锁：一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作。</p><p>悲观锁的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//0.开始事务</span>begin<span class="token punctuation">;</span><span class="token operator">/</span>begin work<span class="token punctuation">;</span><span class="token operator">/</span>start transaction<span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span><span class="token comment">//1.查询出商品信息</span>select status from t_goods where id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> update<span class="token punctuation">;</span><span class="token comment">//2.根据商品信息生成订单</span>insert into t_orders <span class="token punctuation">(</span>id<span class="token punctuation">,</span>goods_id<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.修改商品status为2</span>update t_goods set status<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//4.提交事务</span>commit<span class="token punctuation">;</span><span class="token operator">/</span>commit work<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乐观锁的实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>查询出商品信息select <span class="token punctuation">(</span>status<span class="token punctuation">,</span>status<span class="token punctuation">,</span>version<span class="token punctuation">)</span> from t_goods where id<span class="token operator">=</span>#<span class="token punctuation">{</span>id<span class="token punctuation">}</span><span class="token number">2.</span>根据商品信息生成订单<span class="token number">3.</span>修改商品status为<span class="token number">2</span>update t_goodsset status<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span>where id<span class="token operator">=</span>#<span class="token punctuation">{</span>id<span class="token punctuation">}</span> and version<span class="token operator">=</span>#<span class="token punctuation">{</span>version<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="谈一谈对MySQL-InnoDB的认识"><a href="#谈一谈对MySQL-InnoDB的认识" class="headerlink" title="谈一谈对MySQL InnoDB的认识"></a><strong>谈一谈对MySQL InnoDB的认识</strong></h2><p><strong>介绍：</strong></p><p>InnoDB引擎是MySQL数据库的一个重要的存储引擎,和其他存储引擎相比,InnoDB引擎的优点是支持兼容ACID的事务(类似于PostgreSQL),以及参数完整性(有外键)等。现在Innobase实行双认证授权.MySQL5.5.5以后默认的存储引擎都是InnoDB引擎。</p><p>特点是：</p><p><strong>1、</strong> 具有较好的事务支持：支持4个事务隔离级别，支持多版本读</p><p><strong>2、</strong> 行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响</p><p><strong>3、</strong> 读写阻塞与事务隔离级别相关</p><p><strong>4、</strong> 具有非常高效的缓存特性：能缓存索引，也能缓存数据</p><p><strong>5、</strong> 整个表和主键以Cluster方式存储，组成一颗平衡树</p><p><strong>6、</strong> 所有Secondary Index都会保存主键信息</p><p><strong>适用场景：</strong></p><p><strong>1、</strong> 需要事务支持（具有较好的事务特性）</p><p><strong>2、</strong> 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成</p><p><strong>3、</strong> 数据更新较为频繁的场景</p><p><strong>4、</strong> 数据一致性要求较高</p><p><strong>5、</strong> 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘IO</p><h2 id="谈一谈数据库事务的隔离级别？"><a href="#谈一谈数据库事务的隔离级别？" class="headerlink" title="谈一谈数据库事务的隔离级别？"></a><strong>谈一谈数据库事务的隔离级别？</strong></h2><p><strong>1、</strong> Read uncommitted（读未提交）就是一个事务可以读取另一个未提交事务的数据。</p><p><strong>2、</strong> Read committed（读提交）就是一个事务要等另一个事务提交后才能读取数据。</p><p><strong>3、</strong> Repeatable read（重复读）就是在开始读取数据（事务开启）时，不再允许修改操作。</p><p><strong>4、</strong> Serializable（序列化）在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。是最高的事务隔离级别，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><p>事务的作用就是保证数据的一致性、完整性。事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大，因此很多时候必须在并发性和性能之间做一个权衡。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。</p><h2 id="MySQL主备同步的基本原理"><a href="#MySQL主备同步的基本原理" class="headerlink" title="MySQL主备同步的基本原理"></a><strong>MySQL主备同步的基本原理</strong></h2><p>MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><p>MySQL复制是基于主服务器在二进制日志中跟踪所有对数据库的更改。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器已经记录到日志的数据。</p><p>当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。</p><h1 id="八、网络协议和网络编程"><a href="#八、网络协议和网络编程" class="headerlink" title="八、网络协议和网络编程"></a><strong>八、网络协议和网络编程</strong></h1><ol><li><p>TCP建立连接的过程。</p></li><li><p>TCP断开连接的过程。</p></li><li><p>浏览器发生302跳转背后的逻辑？</p></li><li><p>HTTP协议的交互流程。HTTP和HTTPS的差异，SSL的交互流程？</p></li><li><p>Rest和Http什么关系？ 大家都说Rest很轻量，你对Rest风格如何理解？</p></li><li><p>TCP的滑动窗口协议有什么用？讲讲原理。</p></li><li><p>HTTP协议都有哪些方法？</p></li><li><p>交换机和路由器的区别？</p></li><li><p>什么是VLAN，有什么作用?</p></li><li><p>什么是VXLAN，有什么作用？</p></li><li><p>http协议（报文结构，断点续传，多线程下载，什么是长连接）</p></li><li><p>tcp协议（建连过程，慢启动，滑动窗口，七层模型）</p></li><li><p>webservice协议（wsdl/soap格式，与rest协议的区别）</p></li><li><p>spdy/http2.0协议是否有了解</p></li><li><p>NIO的好处，Netty线程模型，什么是零拷贝 </p></li></ol><h2 id="说说http-https协议"><a href="#说说http-https协议" class="headerlink" title="说说http,https协议"></a><strong>说说http,https协议</strong></h2><p><strong>HTTP：</strong></p><p>是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p><strong>HTTPS：</strong></p><p>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p><strong>区别：</strong></p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><hr><h2 id="说说tcp-ip协议族"><a href="#说说tcp-ip协议族" class="headerlink" title="说说tcp/ip协议族"></a><strong>说说tcp/ip协议族</strong></h2><p>TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p><p>1、数据链路层负责帧数据的传递。</p><p>2、网络层责数据怎样传递过去。</p><p>3、传输层负责传输数据的控制（准确性、安全性）</p><p>4、应用层负责数据的展示和获取。</p><hr><h2 id="tcp五层网络协议"><a href="#tcp五层网络协议" class="headerlink" title="tcp五层网络协议"></a><strong>tcp五层网络协议</strong></h2><p><strong>物理层：</strong></p><p>为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。</p><p><strong>数据链路层：</strong></p><p>为网络层提供数据传送服务。</p><p><strong>网络层：</strong></p><p>路由选择和中继、激活,终止网络连接、在一条数据链路上复用多条网络连接,多采取分时复用技术 、差错检测与恢复、排序,流量控制、服务选择、网络管理 。</p><p><strong>传输层：</strong></p><p>传输层是两台计算机经过网络进行数据通信时,第一个端到端的层次，具有缓冲作用。</p><p><strong>应用层：</strong></p><p>应用层向应用程序提供服务</p><hr><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a><strong>TCP与UDP的区别</strong></h2><p>1、基于连接与无连接</p><p>2、TCP要求系统资源较多，UDP较少；</p><p>3、UDP程序结构较简单</p><p>4、流模式（TCP）与数据报模式(UDP);</p><p>5、TCP保证数据正确性，UDP可能丢包</p><p>6、TCP保证数据顺序，UDP不保证</p><h2 id="TCP和UDP的区别及其适用场景"><a href="#TCP和UDP的区别及其适用场景" class="headerlink" title="TCP和UDP的区别及其适用场景"></a>TCP和UDP的区别及其适用场景</h2><p><strong>首先说一下什么是TCP和UDP：</strong></p><p>TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。</p><p>UDP是用户数据报协议，是一个简单的面向数据报的运输层协议。</p><p>TCP和UDP的区别：</p><p>TCP面向连接的运输层协议，UDP无连接</p><p>TCP是可靠交付，UDP是尽最大努力交付</p><p>TCP面向字节流，UDP面向报文</p><p>TCP是点对点连接的，UDP一对一，一对多，多对多都可以</p><p>TCP适合用于网页，邮件等，UDP适合用于视频，语音广播等</p><p><strong>TCP和UDP的适用场景：</strong></p><p>整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，比如视频、广播等，这时就可以使用UDP。</p><hr><h2 id="cookie和session的区别，分布式环境怎么保存用户状态"><a href="#cookie和session的区别，分布式环境怎么保存用户状态" class="headerlink" title="cookie和session的区别，分布式环境怎么保存用户状态"></a><strong>cookie和session的区别，分布式环境怎么保存用户状态</strong></h2><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><h2 id="分布式环境下的session（举例两种）："><a href="#分布式环境下的session（举例两种）：" class="headerlink" title="分布式环境下的session（举例两种）："></a><strong>分布式环境下的session（举例两种）：</strong></h2><p><strong>服务器session复制</strong></p><p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p><p>优点：可容错，各个服务器间session能够实时响应。</p><p>缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</p><p><strong>session共享机制</strong></p><p>使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。</p><h1 id="九、Redis等缓存系统-中间件-NoSQL-一致性Hash等"><a href="#九、Redis等缓存系统-中间件-NoSQL-一致性Hash等" class="headerlink" title="九、Redis等缓存系统/中间件/NoSQL/一致性Hash等"></a><strong>九、Redis等缓存系统/中间件/NoSQL/一致性Hash等</strong></h1><ol><li><p>列举一个常用的Redis客户端的并发模型。</p></li><li><p>HBase如何实现模糊查询？</p></li><li><p>列举一个常用的消息中间件，如果消息要保序如何实现？</p></li><li><p>如何实现一个Hashtable？你的设计如何考虑Hash冲突？如何优化？</p></li><li><p>分布式缓存，一致性hash</p></li><li><p>LRU算法，slab分配，如何减少内存碎片</p></li><li><p>如何解决缓存单机热点问题</p></li><li><p>什么是布隆过滤器，其实现原理是？ False positive指的是？</p></li><li><p>memcache与redis的区别</p></li><li><p>zookeeper有什么功能，选举算法如何进行</p></li><li><p>map/reduce过程，如何用map/reduce实现两个数据源的联合统计 </p></li></ol><h2 id="redis常用的五种数据类型"><a href="#redis常用的五种数据类型" class="headerlink" title="redis常用的五种数据类型"></a>redis常用的五种数据类型</h2><p><strong>1.String（字符串）</strong></p><p>String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。它是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。</p><p><strong>2.Hash（哈希）</strong></p><p>Redis hash 是一个键值对集合，对应Value内部实际就是一个HashMap，Hash特别适合用于存储对象。</p><p><strong>3.List（列表）</strong></p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p><p>底层实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><p><strong>4.Set（集合）</strong></p><p>Redis的Set是String类型的无序集合，它的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><p><strong>5.zset(有序集合)</strong></p><p>Redis zset 和 set 一样也是String类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数，用来排序</p><h1 id="十、设计模式与重构"><a href="#十、设计模式与重构" class="headerlink" title="十、设计模式与重构"></a><strong>十、设计模式与重构</strong></h1><ol><li><p>你在设计一个工厂的包的时候会遵循哪些原则？</p></li><li><p>你能列举一个使用了Visitor/Decorator模式的开源项目/库吗？</p></li><li><p>你在编码时最常用的设计模式有哪些？在什么场景下用？</p></li><li><p>如何实现一个单例？</p></li><li><p>代理模式（动态代理）</p></li><li><p>单例模式（懒汉模式，恶汉模式，并发初始化如何解决，volatile与lock的使用）</p></li><li><p>JDK源码里面都有些什么让你印象深刻的设计模式使用，举例看看？</p></li><li><p>Reactor模式 </p></li></ol><h1 id="十一、学习与进取心"><a href="#十一、学习与进取心" class="headerlink" title="十一、学习与进取心"></a><strong>十一、学习与进取心</strong></h1><ol><li><p>平时会关注哪些技术？</p></li><li><p>会看那些技术博客和网站？</p></li><li><p>技术上有没有偶像？</p></li><li><p>看过哪些技术书籍？</p></li><li><p>你平常都看些什么书？你去年和今年看的书中印象最深的基本技术书籍和非技术书籍是？</p></li><li><p>（如果不看书）你平常都上哪些技术论坛？最喜欢哪个？为什么？</p></li><li><p>项目或产品中用到了什么新技术或框架</p></li><li><p>最近研究过什么业界流行的技术或框架</p></li><li><p>对现在所做的项目或产品的缺陷是否了解，有何规划</p></li><li><p>是否有带过项目，如何管理项目</p></li><li><p>是否有带过团队，团队管理最大的挑战点是什么 </p></li></ol><h1 id="十二、其他问题"><a href="#十二、其他问题" class="headerlink" title="十二、其他问题"></a><strong>十二、其他问题</strong></h1><ol><li><p>一个大文件4G，里面一行行的数字，这时内存只有256M，如果做排序？</p></li><li><p>如果你部署的应用所在机器硬盘坏了，会发生什么？你的程序要如何处理这种异常？（分布式系统中故障是一种常态，设计要避免单点故障，能容错，保证系统高可用）</p></li><li><p>实现一个消息队列系统</p></li><li><p>如何设计一个高可用的架构</p></li><li><p>多次Hash来解决URL重复访问问题。</p></li><li><p>全局唯一ID问题。</p></li><li><p>秒杀如何设计。</p></li><li><p>如何进行性能优化。</p></li><li><p>发现CPU 100%，如何排查？</p></li><li><p>实现一个分布式打点系统。</p></li><li><p>taobao.com和tmall.com的互相登录的问题。</p></li><li><p>如何快速对一个2亿数据的List进行排序？ </p></li></ol><h1 id="最后：需要记录的内容"><a href="#最后：需要记录的内容" class="headerlink" title="最后：需要记录的内容"></a>最后：需要记录的内容</h1><p>原来薪资情况，当前要求薪资情况，你对该面试人的评价【项目，技术，个人沟通方面】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日记-20210406</title>
      <link href="2021/04/07/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210407/"/>
      <url>2021/04/07/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210407/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="403efda57be5a8b6545e49d1d87fdd8e39188519b42c31921ec47985d76a5734">675ef3242d144ff249cb5b90ca67837646fd777fd546e6fee01bdf2d090e2b667e42e32763a3621bded38e1b49b64ff4a34b62530b8b9fe8286b1cce19eeaa7645e4e90e4d30175550faf501ee731b1330f757b0135904e817d724a999261a1367d9ee90c981c2487c2aab9d95c27b03351a8097d06414c516652bc5c7a5f70dbbe2cacff1b9fb026d968ec10d3a7feb6baf59b83c25196ed45e203ebd14b1f4e59b3fb2189090e760828493f52a7fe25918bd0a765dd41037cd643a477c47cd3f39ddeb58eec488f853618c613f054e9ca5f10b7dd10d936a73b06e7c17803d64d7d45d425238468563bb870ae79c3d0490eb20867ed624e17a70f4fad70b0f1233292eab2aebcf2fbe9c9ada10013724561695bb65f2350a71574fcb33a457155607796053711190f6c34a23b153131cb8666618bc59bfe1597507af7356eed9d17f766423358750354a6ee8d3e1c30ab8838d29867808df8ff0eeace1abc2809dd55707a757a9dd8e478cbc5f9fa59a513cd7a896a4cfdef58ed7105c7736f41595f7713ec8e4e62e10e2b1aa060f8c52166526496263252d9f42e4cbcffd7d0faeddb5958d84541dce04edc6ec6732d627ab9ed34487fdf965567eddee0f10e512c6a01ed4252e2ca3bdd9cf14854b8087de148368565b3bbf2243a8731e76acb54fb62751fc24832f1942f3093ccedc8ad4512c0982430d4525458055b0e88b30b80c41fed1ef857e4a94cd86fe5fc2993b8df8f43d2b3f23cafd8c5722cbf14a2f071de358369dcd5180167a4d3631c5d630d0cda0a69ec4adee3075866b7fb84bb33c48761d2fc5071b27da2ff69f5aed3164dc3a37d434bdaa0e1b59692b149350cec4cb613ddc2ac8fe78e5868b8cbf5f2668579e661ad2d61c1c4508f956e625f2e0cab993b478a1cef171ab644be8e45cc2298e7379b607649b70e6a290ce22290688b533b038a3bbbeb4e56e6d4ff1460ae4fd9d88b76953fd1c508710dfca40143363b29e29ac7db63e73fcc715ce5570c7bd3a377fc5793b3d403e274d7e388a3a095d5538ce1b99c6310c383f82b532b879646d2ef48c2ed5947c67e9e04ed8486a14f989b2a0836267b0dc65a67b6d50c7435e01aeb8c88f4453f7530d0aff9f52b392cd7bcb243b0f7fa2c78cc95490213623cd14d448cc53421d15459d3ff60b0082d6f2a0e80325f1e226c5b0c3d64945938b9d4d1ce61cdb55df3052fa6ad9da96ab064b2d499d4aacc3f88f313b12fed2d5f11226666f8d8da505d61c2ff25e91cf932339e3551a479f9ad520ff7c26fcb8c05c9618e2d5c64697db683783d9c9f5adf8aa87d8b518d7a0acbac0d928100ce916c513e57a7b8b0adf596c789a0b6eb1506b13</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书单</title>
      <link href="2021/04/07/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/"/>
      <url>2021/04/07/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>禅与摩托车维修艺术</p>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记20210406</title>
      <link href="2021/04/06/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020210406/"/>
      <url>2021/04/06/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020210406/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bfbb5048a3e6d0f9242d3e4c31372365a956d06fd429b43442bbab174fe0191e">675ef3242d144ff249cb5b90ca67837646fd777fd546e6fee01bdf2d090e2b66a13a03ac2733411e3afda7f1deee6dc913a1243a23d264f534391d11e5734062756405446cfcf0f5de356c616df07cddbc64cafd6eb46198f4d1fb589f424631f4269f87c29542af612ff2d053be96171949c4f98721b3cbc709a9cddea2346132515a59eed5c28c5e3ffa930433829f160aca4d7cef231c474bd109c2f70e1e744deea9c232dce01da341e90e14916083e544510e1e073fecb139b6b785ae64c2bc755bef16268c4c37585dd9a3edffaa38b95d1a1e847931f04ff015d8ac96145adaf0c6374c661122da071790506e96fa2e9eec1dc7df7dd4ffa828980045e125407282668229a2371cb8cbc4218f72801d6a666373f04b67b9740f1ef5c0ef1ba2770122f9995837fccfdf4de42d566fe9e2b514bc41ed665097adaa3e860173f561ec241ecc33dab78df24c2769ba859ebc280c171f945b385250ce4c1b4a5ed048a227d4d911a21081d171b12bc7c3dcbf51db5943b4e6b049ea9533e49f7a19c78733393be07ceed1c6c6965d555c63655def6d31959eb506b30693bebf88169b36b65e82ac5b570eb6d9a95a6f30762df2771fd039fe897e66c5260698f49a8aaedbce4e2215b690ef3a4f35d8134fd0354f51ba262a88be46d9c793824ab5f1191960188964b482a00dc93272957d900056b8eb766a8093ec1d96fd7685302e1aa56b17909b4f280237c1e5295f91997be4d91a684692c41f0baaf092a37772cf275fe957eb0cfb43972c1128af29cca078c83b1e237ce44e76f7316eecf78256ae9c688891a92465c43281b2e021c86d56675a8e5208fd49e11c1f6df3e1940fcfd708ab5e79ac4bb44518393e87c841730ea4d13fd7e37770d3a1e6447f126f9acdf0568d6d902da569f9958453c4217af4aec2f9501b35497b49cfe8e07e750504008fc66e47de6ce6b2ad256bd66d47ca6464a4950581b3ba85455618b9c9b1d80e233c8adcbee4e65f113c0fb4e74fbd85a0a3e9c390a11c920322583d20d89d392749085badfd5d9421ef4d5a30063e493580249bf7934d6f9487b4eafe19117eee96e21bc5596636b193f37e35aa25c6fa841167572841e8d009c160bd827e876089cec682fe6b32d4e365bb7eb8648db90c0faa0842a65d4813534cb4218c4bf9d09053ecb9b2c57dfa5676a98c235a7c169b9f0c603ab54dfa17fc64c89164709c355505680265a1f988caeccec89033aedd17ec29cef7d48080f97c86e8be73de7794a6087f4fd8f8720ae017e233061ebe70f278692f461a9db144863637fdd0370bae54bcd9212ec733a63e06f2ef3d697245e00967c54beab168fa0cb8c482d731c2b1aa0428e4ddc086d951e4f1c1e6cc1031d7a43e1ce6f57832a932045464412aa72654fd4a7e9ab3f853006d64609cbd10a3cc83192071db4d19cf9176e5272a383505ed97f85e6a925bdc1d331c5f05eb77b7d1aee62a5030803551d8f11d344367bd49af3dc6fabdf8945d14cce0c38511b435396cf209541822af32523a3ba77a7a0a850616c7db67a4c2a4dcc819f999f2f027bd0e8e33d2334af812334c0651d5275b6d1623c6ec6b86db318609c9c4b62b4f0f28b20c47182830c7b67bb2baafc9ec9f451215a0e4570cb5439e97f6c8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记20210403</title>
      <link href="2021/04/03/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210403/"/>
      <url>2021/04/03/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210403/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9844465d685ae4342d3bfa3d923e21491ff7ec2efcb63effc633c5ef54970baf">675ef3242d144ff249cb5b90ca678376d15a33153cbb0389147ac8fc7ccfdf65b08e4dd045ec301da6dc7379ece271aec36c531635f0c7aad42daea4641579c4e61d94f9b48fce2364f4af234413778e97b962d042b3c5182ac7f8a11d728d7fe0c7ca115a60084ed32ed9a1957f39333184d457011b19f08425fffad142af77251fd515eb2e2b031b66beadb272882a9c4aed4887d5114b0ab704c38cf078141920d2cbb2b5d0b5806f5a613be251055c0da47c5c123f1ea999d87de7b063ef033c3eabeabd0c1add7cfbbef2cad1fa258ce79ebc50ec7920f2b0f0a133cc0dae172a839c0545ece9656f15f4bcab0a3f7cb83da9b4fddd2cb5b489ea10a14c897be71f13b9d969d38f936edbc42f67a09a26f4312a21113e32a44d788535f8623dd54ed9ce9b16c6ad3437da93350deb45b25fac832457bf39ad98433b7f39b81401cbbe5275013faa9dd694c7be8c21ccb9dfc78bf111ead20c07bea3c64aff8d791cf24c28147f4db91ddecadc1a7f36367647c63f50d5cfefc17896af721378807156106548dbd1011362535bfade13ef5ee8de9ca552f6da602b5d19f017e62ffbef99ee94d2a452838909adabfbb9fda78af520a54fd5b2fa86b01d97ae8bd5620b801ce98d5d4d911deb0055a085afc35a4d4d6fd959c8116bc26324df988b8abadda2dcefe9b215d51b923e6e55cf6645822afd057e4ce19bde99d6a663a6e3e5e8cc1a3bc08927768a744c930b240015548e3645476f4e129a8dd59ee08007c7ed48ef8504473da1ed13fe8484ed274a6b517a45c796fea4fcd51839cd85f0d206693643b75296d9893ea1881840c53499a268106068d1ea27dbf678df96f1ff7c38759323ece8615df4a3b330caf3aa3a257d0fd44f854d330d5f4ae5aa6ee0d52eebb219e83e6e48e56b1cd685e0d17251e2d543ae1dd04c33836859f6773768539764c1de304979867c372c0b168b990d19bcaa227ba5bc1f3ed4949786e7eba1555da9cb4ff23ada94d2805b2f7b4a1b8b3f95856b4b14356386809a36978f8da6c86d7cc661920f5fc5148554f7304a49a055a3fe68d6ba93371d207e96b33141578b96b9cd6a9c6d7228574566f97d6ef2d533b698bf7c83c058e818b835c081e75a894fa29319f273cbef363952afa8e645449cc475ffba661e31a784fc023b6983739f7d1e5d59cec98263091e5e836d19a081a61345c628adada743a3c24beefd0be942d228085400bed5bc1894cd5b1fd92c629f57db87c30c17c8022cf7be55f915005a0740fb22ffaaa879cacefe9411b6b5c85d202ef8c31289aa06e9567869749d636a1a17d74217848d4a489b1125c00cab0204ec94a3227c5bf915e1b945c1a472393dc227f62c227c41956586220fd906e3639a94fc8b81a4286a0d3246fe23c0314dd9eac43fac107d1218819fb8f769bcd29700e5ee1e870c09bec33402502ade2464a5cce13884243533ec6bd8eef720474809e9c743cc6b15e68dd1a6b665a172d694eee2ba5a5a2d31b31c0b10cd3d3ccb68193844e6dbca11842cb9205428b5b33a859736ef66c371ec880c68fd21c546c0b88086005cc466624e96a295e2dcab7f7ee368533dcae2ebfc302f312eb0903e438726c33676cfe0aa12594b382d1960c5a74b1a7e26658101aa0819cd9f4cd3ab22b42c29a0b18b519c657bc97304d9ecb164679e080076a1341d305b4ccc5af133ab23bca9f51b2bb84dc2ed55c43893d17282a88807b6faacff0c5049ab2624e859719e5e86c9f974a4bfa17b6013bfe3f231bcddadd8aaefa4d2cfa5ee1a982f5219fd1cb90c20c3610afd9905dfeeb93a2618ff9cde4b56ef6fea827681f3845092411bfdd94b755e62709a81132b9eb389a83b75c89d7eb3ee5e13e7889795879b91ee927c4d2e01624e09b6861c42e55d3d000cd77edb894c6cb80f0090566a10dbea36bc180d1de4771715ed8c6e77461454ffec53ae336369cacdbbe3fae0a46aa3b32a4c1b5ee9a8e4660a3b4719a1bda3ef8453d0b82b04c0fa941cbdf7506e330f76576d4446d5acc1b0b0f16f195af33e402a2c2dad17b9383851f446016c4b499131e1908127d43be2549a60e5dcaf007b1b6dc879a3f0583d97c4df6290802a06fc74dd9f39416df52079e671919c3dbfd7046c93da896ef82fb9ae15b48d01c3142c8a2f4a007edc5ef9706ec5e521238023c2169c73ae495bc6141c5cdcb6d004c855c5f53ea3976cf08ec45e6fb0eb30a8cf9e03bd843180a0073139f663eda932768c3d33d96dface65c6af5a4c0dc827fd52cf2339cff1a1e05a7fd740bf97b412bd5ad608e633b21eb2040a325d81ca8c0ac0dc06d15706e6007a8b28e7158dc3bfc99b21b4315edb7dd40090a26f2e816a9147c8f7b39de05d1b1ca651cef51653996251f60ca66d27c323771b81e589249130c5d37b84cfc32611f279fd61b56a47211ace63d43c9676d93e409dfea63d5ba99a339a7cb067298b4cde939d02c52bd329a5ecb91ec1ad31881f6de73ea7d8ea13dde0c4884bcb2a0a31e44bfd70aed8a8f6da0846507d8497ba7c61a87366abbe52447c751e0498d2356dde6f8548f5aaf749bd4b33d3b750a4ca1e2298cb571a736d6b8d52b21ec45cdfd945088e2d8eadc7c6ec16acbe81c71470efc8d786ebee28b28243cf618e046198c83fbb9eadf89a6ce3d4e6d1196da424c907dd93fd3b6f6da0983dca7863420be7baac85f535d3a9293afe1e04a8a15dfbb9a0499ece4377463735bc5ee5ac6a0dc30c34b6ee228498fa9cdf14f060cf72e983070ea68a43540d5619b587514b9d3f43173aa3b7c97129018cec027699715da307c7463605a3f59b9a2f82ce5e40377da35780dbe510b1c9cbe222dd0148be8142abc82f15030d0215464c8473561a7e73a565ba0529b58874291789faea70ff0de06480a6d721853a9120065ddc159b9f4392e1461f2ff2164ed18ccd247cb48301ddb4efcffeaf9026562c5d1af36987b537225e4fc0bad664dcabe98b514d17b68864ea4d9f7d57b898a99a9a896acb75bec214b67da4bf799ce321737cf6e5423fd4f6064a85c4f198787e8619e1e0e2954f31ed7191b4dcb7a80971446eb23a3fdd29555b51320ba440b8c16274079e89063468764ae2549ebbdf0385808fd9be7c599c1da23ed9bb48f09d1053e4ac614f20902089bc42ca63f2d59da20472df3a4d21dbf183c849dceaee942a63dc4ca8dfdb2352e4e4fc264b09ca36a4c60d5f4433829efed6d9f42becc14ce2cf612524ccc45aad98dfa26cc04d8517c493ff2b458dba0ed356fd4c466b09f263de9cc3f1f98bcf03bd28735573a61f32f1a808a5928aa94ffd77e7d4f05a4c851d38c4bcda6e04f7442daac1e49e945b0d5ae639a7e33329f1883ca8ce546ccbca810e218b5f7dca44894e8b2d797c7b1c05e2515cfea5ee743090b8c7f2bab17b941fdce0548f97f37f54390fe3a8ce2fda03850859043ce7b7d607658329e8bc6856f2460c98f5b7fb295075bfcac4f697164077284146b96c4ece49799c9e62a67a34ca5feb0dbf073427e132c90d35cf5a40306c8347bb1b5b4f4d0ac4056bd86b1674d4769705eab2f56edd3f40be304f6a5005fb590c3a70bc22c994d6718ce17a3a1b4e18dd8ac894a96d335f580036ca6441987d739b1f621f4b05b7c9cb792d69deb3d343e9aedbada8e99e1ee181642e6fa82dec836f9fc437b1eac07be118277e97ea046c617c7ba4c78a62b4765235c286dec49ff1d25d73ad91bf0c385daf6b908ce789aa0f4ccd910b1d338d80cdad75308832f466bd3bf030aeeac11164e0d848896a43b8fba2877f5a89d995c580eda031dfc3c296a3a3f64246cec4dbbfa0bf1833e2f112afcf5fabbed01f604b3589140a4a74868ddc09544b72c2d76e267ae6b12740a98ccb85df2a8ac0a6e8cfa923597b263ac702f63dee1ea92ad474dbabd03de7606f390cc3ee01afdcef0813e1f38c95ed89786a0755f64c5223814faf6bb422232d5e01eb0c1167f0b67928ea9d64b31882a3012f264e39e67a2253059c33818ecf64cc5d088fd305c945eea4adee90ad2c5e4af381b8382af00587ea48ce8351f174c8bc6198becaec6580737e3ec50c53bf9ee0c0c1744c71552c84b0a4bf48067333c6074a245d3e3d54974a1f9b45b285feb4ac409eaa05e5aa56c3dd2020b59e2466cf96de6559f06eaacc9411328598b80d8c271ae1cf480e60581e76422251e4e20c42e0f1dc0ffc8f64844b53bce6163404b4a80b8d628c83d384fd4877b7ccd40a4047e3bbb77e346d9e18c6f207f806a7a0ba672c85f3c57a7322e334e5b2bcadb1ddd414395cb50569986988a53fc5f5595af6f01f68384cf91406bbef39a0e6fa9becebfff15376fc13c6e3e209b1b8ca7b7d830aef4f3b1df5c3fc333eb333b948086dec37021449c028fcd6d2ef891f6f3b3fbba33e7251851777d73b489e661c00063b8ea2fada795d3aecab1a1674aee5e8491789bd03782eec9c458201fc9967ca2b83df0a744bbb4702d32e9161ec9f72b4507660eca25b94b94b8f9d4ef790f20dec94f7fb9e3247eb5a4fff7db69869bbb3b3d697956a01449e240a8e421cd9f3a993c5b2b929d1c7f024cbbf62abbfcb968721c6d5cf20d155b2ebd966eafdd6ec6db4bd5087e1e12ae7d261baf40d331b69199fc6743c7c4e813de8c85fec55eb83016aa44b3840a9768e2750659e4a898d93c4b763c3586c107e581712760293850a4821b28d6540c198e452a8fbdfd06064fca7c218bbeda0d8736e2d0c0d03e2426d1aa72b0fa60e438e697c7f5a385cfc4f1f173815e35004f824f749c6b8084e6cba7b9f785ed4d39c763ba1864773271aeb62b2f608395b97dc30ed2321a09a7d83917eb28a162701114dca4c14efcb5c2ae0a38855a6c2615d7794958c185f93fbb592e42e60c5eec688159ac9d686f831283d3f1ef920d5202c5897ab0b4934478f7a519bc3c6b4c6ca4ac9ffd0a52c0f05abeba3d91fd97076fdfae0774387115f786df399a8aaa604ea65fe671e95fb909327724a081174878ab8438ef16783265ae815a128c9b0aaa0d469ded0996910e2ada9ba10a32a838d5d9f271b403e6e8c71e4069f1de1c4f121777f708bd44a521aa863499bd65b031a7d9c9e3e85d38220b6b7d3dc38710ce6affd880dff7af5fe4df0e9fc8966950b007af13745a44c6767fd0654f1c48998ed83d4b2ec3338b827b286f3644003847c934a7213c9a0bff2e1c91cf149f7099a3401a5cc7e60848abbaa317036b22681287befa656600e32317e068c7b96a8af54a4f525f986c8cd525b4df9cee0f19e394eecf18bdcab9dd1a69cb373958db4263773b1f796e0ea8540c092ebedc65dbbcb46295cf7aa479295e59e54759eec7d7e887961d932204f270f3c395bf48dce0f95bdbb3a9944aa6ee652f66d96faa3260a6053beb48f34e6b3bc5c122655c34027a5349dc777554331072d036f05e17415666d00f4b4a7a19d828e61c81ef54a4a6b484001dc63aca30ada59ff17dcdb3ff2e5244d96b723978dda579300be7bffe474213bceeeddf8b1482782db1e6220593232c1924b951422aebaa2f549791c975975f0c9f45d8f4d9c9627a70d9b4fbb59a283cd23351921681220765ab8e6b28fb8bbf396d2ee7d3064be5791ddf7f1d68403c6f51aaf2a9627d430a3a935a086a7bcdb99a74e348742380f27f7b5eccf8561417cade928d7263c6bf8de65cd750431dc80d12f7341af1b4361e013559ca7ec2a5940601ba33e37983cc07af376a5859f30e60a5bb615f04da034a012c6e60b6adab50a82267f37303298b08946cd5526cd1911a62efbbc281c2d32a6e6f6dc432f7d33b6d58dccd5d2b0e016e74c2103089e9136bf3a00d48a7547662367df920b60be0659da21743ab23bfc2ac6ffc3b56904524947414f02e1718bd4b1468b5a404d4da54e40e7f9bd0d5deb89e5ea1a7adf170ff219a711fa298f03e46d105c0e3e5d4cabeea82c4efb54600bba4a8e302ba9b3a3a105e54f159c117d22bb78a04da9e4737226ac3350517b0241f44f609b6d91bd8e806fcf4c2de06df1fb91bbe2092590845aa36b11608eec28be1594c9d7272a6e1ee249485f653f4bd3569675ef6f2d77e2ac3a5f2e64edc31b33ccc491066f1421611980fe939d433ef41f4521020c692c1b4a77051266da2201ae01eaa59851e783d53a2d93aac375de5e34ba6326f2e8ca1d7a3cd34a903d2da9a74f0c9e41eb508e02e5c00a6d310ac8a5982abb7fb6ef82888297293d9d92b223e8b99bde9e128bceccefb13182154eab4f5376f4e71c04d96614c95e4fa3cd4e4e439cffc76a2729817524c9279058225ca133b4a54febfdd3122bcc5e251612d84ff1ced199deff8f32c8381ccbe48d3514d1b02414f1626f4512c616536e8b957ac9588f4adcb3381ba1d5f977820da260beecc1f9116ee52934d635b6903e74a2e667409959f407cd8bc76c94c0294ba8936ea67017e835477e5706e0f81c110ea34a23a3aceb303d90496cd7d35c651943689d96f47551f2fe0abfe038f325fee85bc615ba5166101d142f4e0c24237dc6bae2235e93580e359d07cc7e7573a19f96ed4a4b73de6d8c28626e881b18e5d6f45a808d69fb85559231d2994b0b366908bd67f7baddb20efbdaf41f68a7c06b11361087e5cce0dfca902b0b581da724146f4a14f1391dcd86616ec1aa1f50c4bd2be73352f7374a3ea9befc930c3a37cfe0a001b9e08117a7335dcce9baf53c9bb0b7e31aad33615b00b5c0db31d750afab6521c308eb716e2219d681ae73490f91d4722f9bbfe5324ed37a87799d7b8ca0a8c06769de9a7358e24d93c69e2d7de6da78fccf09dcd4e994138e23c3d5187da41e3809720bf66066dfbd754df497d62ab8d2b02cd2cdbb675cb3b2c4ad6331fc1ca534afd75e5f44332f360b78f4b8b5e938a35d47819dcf303616a0ed4a32db42a8b01361e94d2c140475bc06a817bd6ef5aecbcc636f4998405f5346291144568f67038996a2bb05b6daf1b017ef244bc239c8489abb1974495ebe5469eb4dca91c3c1ae95d99b65e88e424a7920d720aa7f2e85661688fc5212e495d7f698ef454a753699d22d891c19cc42c6dafcbae6736587fa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python入门</title>
      <link href="2021/04/02/python/python%E5%85%A5%E9%97%A8/"/>
      <url>2021/04/02/python/python%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="mac下安装python2和python3"><a href="#mac下安装python2和python3" class="headerlink" title="mac下安装python2和python3"></a>mac下安装python2和python3</h2><p>python安装</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">brew install python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>python3安装</p><pre class="line-numbers language-none"><code class="language-none">brew install python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看安装的目录</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:bin cutie$ which python/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看当前python版本</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:bin cutie$ python --versionPython 2.7.16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> Mac下配置Python2和Python3并相互切换使用</p><pre class="line-numbers language-none"><code class="language-none">open -t ~/.bash_profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入如下内容并进行保存</p><pre class="line-numbers language-none"><code class="language-none"># Setting PATH for Python 2PATH="/System/Library/Frameworks/Python.framework/Versions/2.7/bin:${PATH}"export PATH# Setting PATH for Python 3PATH="cd /usr/local/Cellar/python\@3.9/3.9.0_4/bin:${PATH}"alias python2='/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7'alias python3='/usr/local/Cellar/python\@3.9/3.9.0_4/bin/python3.9'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ide使用</p><p>使用visual studio code来编写python，安装vscode</p><p>hello,world编写</p><p>新建hello-world.py文件，代码如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello,world"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用vscode打开文件，提示是否安装python插件，下面是安装好后的插件</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210402151248.png" alt="image-20210402151248491"></p><p>提示安装pylint，也进行安装。Pylint 是一个 Python 代码分析工具，它分析 Python 代码中的错误，查找不符合代码风格标准和有潜在问题的代码。</p><p>打开vscode自带的terminal，成功运行python的第一行代码</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:helloworld cutie$ python hello-world.py hello,world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一节 应用容器安全</title>
      <link href="2021/04/01/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82-%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"/>
      <url>2021/04/01/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82-%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><h1 id="Java-EE-项目-第十一节-应用容器安全"><a href="#Java-EE-项目-第十一节-应用容器安全" class="headerlink" title="Java EE 项目 - 第十一节 应用容器安全"></a>Java EE 项目 - 第十一节 应用容器安全</h1><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>• Java 劝退师 </p><p>•Apache Dubbo PMC </p><p>•Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><p><strong>议题</strong> </p><p>• Web 安全 </p><p>• 访问控制 </p><p>• 问答互动</p><h2 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a><strong>Web</strong> <strong>安全</strong></h2><h3 id="•-CSRF"><a href="#•-CSRF" class="headerlink" title="• CSRF"></a>• CSRF</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为one-click attack或者 session riding，通常缩写为CSRF 或者XSRF， 是一种挟制用户在当前已登录的Web应 用程序上执行非本意的操作的攻击方法。 </p><p>• 术语解释 </p><p>• CSRF Token </p><p>服务端为客户端生成令牌，该令牌将用于请求合法性校验，一般通过请求头或请求参数 传递到服务端</p><p>• 术语解释 </p><p>• CSRF Token 仓库 </p><p>服务端组件，用于从请求加载或生成 CSRF Token。Spring Security 提供了Cookie 和 </p><p>HttpSession 两种实现。 </p><p>• CSRF 请求校验匹配器 </p><p>服务端组件，用于判断请求是否需要CSRF校验</p><p>• Tomcat CSRF 实现 </p><p>• org.apache.catalina.filters.CsrfPreventionFilter </p><p>• 初始化参数</p><h4 id="•-XSS"><a href="#•-XSS" class="headerlink" title="• XSS"></a>• XSS</h4><p>跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安 全 漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观 看网页时就 会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 </p><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代 码到网页， 使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是 </p><p>JavaScript， 但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通 的HTML。攻击成功后， 攻击者可能得到更高的权限（如执行一些操作）、私密网页内 容、会话和cookie等各种内容。</p><p>• Tomcat HTTP 头安全实现 </p><p>• org.apache.catalina.filters.HttpHeaderSecurityFilter</p><p>小马哥的知识星球有 reactive-stream 规范，先看代码再看规范</p><p>reactive-stream</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h2><h3 id="tomcat-csrf-防控实现"><a href="#tomcat-csrf-防控实现" class="headerlink" title="tomcat csrf 防控实现"></a>tomcat csrf 防控实现</h3><p>todo：url</p><p>spring Security 的 cxrfilter之类的</p><ul><li>Ant风格请求匹配 - RequestMatcher<ul><li>AntRequestMatcher</li><li>RegxRequestMatcher</li></ul></li></ul><p>Included:/user/1/*</p><p>Excluded:/users/1/info</p><p>/user1/detail</p><p>/user/1/info</p><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><h3 id="第一步创建-Context-》-InitialContext（）"><a href="#第一步创建-Context-》-InitialContext（）" class="headerlink" title="第一步创建 Context -》 InitialContext（）"></a>第一步创建 Context -》 InitialContext（）</h3><h4 id="创建context的方式"><a href="#创建context的方式" class="headerlink" title="创建context的方式"></a>创建context的方式</h4><p>1、new InitialContext()</p><p>2、javax.naming.spi.InitialContextFactory</p><p>3、javax.naming.spi.InitialContextFactoryBuilder</p><p>4、javax.naming.spi.NamingManager#getInitialContext 【推荐】</p><p>通过java系统属性 “java.naming.factory.initial”</p><p>Tomcat方法的第一个参数 todo</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>activemq安装</title>
      <link href="2021/03/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/activemq/activemq%E5%AE%89%E8%A3%85/"/>
      <url>2021/03/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/activemq/activemq%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://activemq.apache.org/components/classic/download/">https://activemq.apache.org/components/classic/download/</a></p><p>我的是mac，选择最新的版本进行下载</p><p>![image-20210329164348283](/Users/cutie/Library/Application Support/typora-user-images/image-20210329164348283.png)</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>解压，命令行进入bin/macosx目录进行启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cutiedeMacBook-Pro:macosx cutie$ ./activemq startStarting ActiveMQ Broker<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><p>打开网页，<a href="http://127.0.0.1:8161/admin/">http://127.0.0.1:8161/admin/</a></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210329164326.png" alt="image-20210329164326169"></p><p>用户名密码为admin</p><p>运行成功</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210329164409.png" alt="image-20210329164409351"></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS使用derby数据库</title>
      <link href="2021/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/derby%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
      <url>2021/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/derby%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="http://db.apache.org/derby/derby_downloads.html">derby下载地址</a></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>在命令行中找到bin目录，使用输入ij使用ij工具（或单击ij.bat后启动ij工具）。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cutiedeMacBook-Pro:bin cutie$ ./ijError: JAVA_HOME is not defined correctly.  We cannot execute /System/Library/Frameworks/JavaVM.framework/Home/bin/java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>找不到环境变量中的JAVA_HOME，使用如下命令指定对应的JAVA_HOME进行启动</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:bin cutie$ JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-15.0.2.jdk/Contents/Home ./ijPassword:ij 版本 10.14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看derby数据库的信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cutiedeMacBook-Pro:bin cutie$ <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/Library/Java/JavaVirtualMachines/jdk-15.0.2.jdk/Contents/Home ./sysinfo------------------ Java 信息 ------------------Java 版本：        <span class="token number">15.0</span>.2Java 供应商：      Oracle CorporationJava 主目录：      /Library/Java/JavaVirtualMachines/jdk-15.0.2.jdk/Contents/HomeJava 类路径：      /Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derby.jar:/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbynet.jar:/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbytools.jar:/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbyoptionaltools.jar:/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbyclient.jarOS 名：            Mac OS XOS 体系结构：      x86_64OS 版本：          <span class="token number">10.15</span>.7Java 用户名：      cutieJava 用户主目录：/Users/cutieJava 用户目录：    /Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/binjava.specification.name: Java Platform API Specificationjava.specification.version: <span class="token number">15</span>java.runtime.version: <span class="token number">15.0</span>.2+7-27--------- Derby 信息 --------<span class="token punctuation">[</span>/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derby.jar<span class="token punctuation">]</span> <span class="token number">10.14</span>.2.0 - <span class="token punctuation">(</span><span class="token number">1828579</span><span class="token punctuation">)</span><span class="token punctuation">[</span>/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbytools.jar<span class="token punctuation">]</span> <span class="token number">10.14</span>.2.0 - <span class="token punctuation">(</span><span class="token number">1828579</span><span class="token punctuation">)</span><span class="token punctuation">[</span>/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbynet.jar<span class="token punctuation">]</span> <span class="token number">10.14</span>.2.0 - <span class="token punctuation">(</span><span class="token number">1828579</span><span class="token punctuation">)</span><span class="token punctuation">[</span>/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbyclient.jar<span class="token punctuation">]</span> <span class="token number">10.14</span>.2.0 - <span class="token punctuation">(</span><span class="token number">1828579</span><span class="token punctuation">)</span><span class="token punctuation">[</span>/Users/cutie/workspace/derby/db-derby-10.14.2.0-bin/lib/derbyoptionaltools.jar<span class="token punctuation">]</span> <span class="token number">10.14</span>.2.0 - <span class="token punctuation">(</span><span class="token number">1828579</span><span class="token punctuation">)</span>----------------------------------------------------------------------- 区域设置信息 -----------------------------------------------------------------------------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在./ij连接的控制台中，通过如下命令创建数据库，并与数据库创建连接：connect ‘jdbc:derby:firstdb;create=true’;</p><p>以下为支持的命令</p><pre class="line-numbers language-none"><code class="language-none">支持的命令包括： PROTOCOL 'JDBC 协议' [ AS 标识符 ];                              -- 设置默认或指定的协议 DRIVER '驱动程序类';   -- 加载指定的类 CONNECT '数据库 url' [ PROTOCOL namedProtocol ] [ AS connectionName ];                              -- 连接到数据库 URL                              -- 并可以分配标识符 SET CONNECTION connectionName; -- 切换到指定的连接 SHOW CONNECTIONS;            -- 列出所有连接 AUTOCOMMIT [ ON | OFF ];     -- 为连接设置自动提交模式 DISCONNECT [ CURRENT | connectionName | ALL ];                              -- 删除当前的、指定的或所有连接；                              -- 默认值为 CURRENT SHOW SCHEMAS;                -- 列出当前数据库中的所有方案 SHOW [ TABLES | VIEWS | PROCEDURES | FUNCTIONS | SYNONYMS ] { IN 方案 };                              -- 列出表、视图、过程、函数或同义词 SHOW INDEXES { IN 方案 | FROM 表 };                              -- 列出方案中的索引，或者某个表的索引 SHOW ROLES;                  -- 排序列出数据库中所有定义的角色 SHOW ENABLED_ROLES;          -- 排序列出当前连接的所有已启用                              -- 角色（使用 VALUES CURRENT_ROLE                              -- 可查看当前角色） SHOW SETTABLE_ROLES;         -- 排序列出可以为当前连接                              -- 设置的角色 DESCRIBE 名称;               -- 列出指定表中的列 COMMIT;                      -- 提交当前事务处理 ROLLBACK;                    -- 回退当前事务处理 PREPARE 名称 AS 'SQL-J 文本'; -- 准备 SQL-J 文本 EXECUTE { 名称 | 'SQL-J 文本' } [ USING { 名称 | 'SQL-J 文本' } ] ;                              -- 使用 USING 结果集行中的                              -- 参数值执行语句 REMOVE 名称;                 -- 删除指定的以前的预定义语句 RUN '文件名';              -- 从指定的文件运行命令 ELAPSEDTIME [ ON | OFF ];    -- 设置 ij 的用时模式 MAXIMUMDISPLAYWIDTH integerValue;                              -- 将每一列的最大显示宽度                              -- 设置为 integerValue ASYNC 名称 'SQL-J 文本';     -- 在另一个线程中运行命令 WAIT FOR 名称;               -- 等待 ASYNC'd 命令的结果 GET [SCROLL INSENSITIVE] [WITH  { HOLD | NOHOLD }] CURSOR 名称 AS 'SQL-J 查询';                              -- 在查询上获取游标（JDBC 结果集）                              -- 默认值是具有保持能力的仅正向游标 NEXT 名称;                   -- 从指定游标获取下一行 FIRST 名称;                  -- 从指定滚动游标获取第一行 LAST 名称;                   -- 从指定滚动游标获取最后一行 PREVIOUS 名称;               -- 从指定滚动游标获取上一行 ABSOLUTE 整数名称;       -- 将指定滚动游标定位到绝对行号                              -- （负数表示从最后一行开始的位置。） RELATIVE 整数名称;       -- 将指定的滚动游标相对于当前行进行定位                              --（整数行数） AFTER LAST 名称;             -- 将指定的滚动游标定位到最后一行之后 BEFORE FIRST 名称;           -- 将指定的滚动游标定位到第一行之前 GETCURRENTROWNUMBER 名称;    -- 返回指定滚动游标当前位置的行号                              --（当游标未定位在行上时，返回 0。） CLOSE 名称;                  -- 关闭指定的游标 LOCALIZEDDISPLAY [ ON | OFF ];                              -- 控制受区域设置影响的数据的表示形式 EXIT;                        -- 退出 ij HELP;                        -- 显示此消息任何未识别的命令将作为可能的 SQL-J 命令处理并直接执行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Derby-操作和-Java-访问"><a href="#Derby-操作和-Java-访问" class="headerlink" title="Derby 操作和 Java 访问"></a>Derby 操作和 Java 访问</h1><p>a.创建数据库，并且进行连接(存在则连接，不存在创建后连接)</p><pre class="line-numbers language-none"><code class="language-none">--内嵌模式connect 'jdbc:derby:dedb;user=db_user1;password=111111;create=true'; --服务器模式connect 'jdbc:derby://127.0.0.1:1527/debryDB;user=db_user1;password=111111;create=true';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b.新建系统用户表</p><pre class="line-numbers language-none"><code class="language-none">create table t_user(uuid varchar(32), name varchar(10), age int, address varchar(40));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>c.插入一些测试数据</p><pre class="line-numbers language-none"><code class="language-none">insert into t_user values('B82A6C5244244B9BB226EF31D5CBE508', 'Miachel', 20, 'street 1');insert into t_user values('B82A6C5244244B9BB226EF31D5CBE509', 'Andrew', 35, 'street 1');insert into t_user values('B82A6C5244244B9BB226EF31D5CBE510', 'Orson', 47, 'street 1');insert into t_user values('B82A6C5244244B9BB226EF31D5CBE511', 'Rambo', 19, 'street 1');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  注意：操作 Derby 需要使用 ij 工具(和 oracle 的 plus 差不多)，CMD 下面输入 ij 即可进入 ij 模式；</p><p>​      创建数据库的路径取决于你 CMD 的路径,如 C:\Users\Administrator&gt; 下，创建的 Derby 数据库就在该目录下面；</p><p>​      如果你对 sql 比较熟悉的话，操作 derby 没有任何问题。</p><p>e.在 Java 程序中使用 Derby</p><pre class="line-numbers language-none"><code class="language-none">import java.sql.*;public class DerbyTest {    private static String driver = "org.apache.derby.jdbc.EmbeddedDriver";    private static String protocol = "jdbc:derby:";    String dbName = "E:\\Users\\Workspaces\\Derby\\dedb";    public static void loadDriver() {        try {            Class.forName(driver).newInstance();        } catch (Exception e) {            e.printStackTrace();        }    }    public void getDataFromDerby() {        try {            Connection conn = DriverManager.getConnection(protocol + dbName + ";user=root;password=root;create=true");            Statement statement = conn.createStatement();            ResultSet resultSet = statement.executeQuery("select * from t_user");            while (resultSet.next()) {                System.out.println(resultSet.getString(1));                System.out.println(resultSet.getString(2));            }            conn.close();            statement.close();            resultSet.close();        } catch (Exception e1) {            e1.printStackTrace();        }    }    public static void main(String[] args) {        DerbyTest derbyTest = new DerbyTest();        loadDriver();        derbyTest.getDataFromDerby();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> derby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频剪辑学习</title>
      <link href="2021/03/28/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/28/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第一天-2021-03-28-12-03-00"><a href="#第一天-2021-03-28-12-03-00" class="headerlink" title="第一天 2021-03-28 12:03:00"></a>第一天 2021-03-28 12:03:00</h1><h2 id="初心开始的地方"><a href="#初心开始的地方" class="headerlink" title="初心开始的地方"></a>初心开始的地方</h2><p>早上醒来，时间挺早，然后没有能量地躺在床上刷了一早上的视频，到现在才起来洗脸刷牙结束（明明有很多事情要做，却感觉自己被抽空不想做任何事情）。这两天右下角的智齿那边的牙龈一直很痛，照了照镜子，终于还是验证了昨天一直舔牙怀疑牙齿长歪了的结论，就是我最旁边的那颗智齿，是顶着我的第二颗智齿长的，呈90度地顶着长… </p><p>这个周末颓废了一天半，下午是准备开始干活了。刷到了张晋的视频 <a href="https://www.bilibili.com/video/BV1KK4y1S7Tz?spm_id_from=333.851.b_7265636f6d6d656e64.1">与自己握手言和，发现精彩生活VLOG-16 上海日常</a> ，感觉张晋是真的帅，又有才，又能打（颜值和武打功底）。视频里面说，他自己也是一个宅男，有了相机之后，也会经常出去走走，拍拍视频，过程中会发现很多有趣有意思的人和事，世界上的花，叶，人，事都有自己的故事。<code>在物质世界的边缘，追求心灵的慰藉，对每个人来说都是不容易的，但哪怕只有一刻，也是值得的。</code> 所以，我从现在开始学习视频剪辑了。</p><p>学习剪辑需要达到一个什么效果呢？</p><ul><li>普通视频拍摄后进行简单裁剪，转场拼接</li><li>字幕添加</li><li>配音添加【只能自己配音了】</li></ul><p>在学习网站B站上面找了一个教程 <a href="https://www.bilibili.com/video/BV14x411U7eL?from=search&amp;seid=12130794647948936171">Final Cut Pro X 教程</a> ，Let’s go~</p><h2 id="教程学习记录"><a href="#教程学习记录" class="headerlink" title="教程学习记录"></a>教程学习记录</h2><p>三个学习点：摄影、剪辑、修整和艺术化</p><h3 id="1-1-拍摄的角度"><a href="#1-1-拍摄的角度" class="headerlink" title="1.1 - 拍摄的角度"></a>1.1 - 拍摄的角度</h3><ul><li>平拍：人眼的正常视角<ul><li>客观，真实，有秩序感</li><li>呆板，乏味，无趣</li></ul></li><li>仰拍：呈现出比较宏达遥远的视角<ul><li>将事物的大小，形状，位置打乱，从而眼馋过或者放大某些元素的视觉效果</li></ul></li><li>俯拍：对微观进行拍摄的视角<ul><li>可以拍摄出居高临下或者开启微观世界的效果，从而传递某些特殊的情绪</li></ul></li></ul><h3 id="1-2-特写"><a href="#1-2-特写" class="headerlink" title="1.2 - 特写"></a>1.2 - 特写</h3><ul><li>对主题的局部进行拍摄<ul><li>主要目的是为了增强画面丰富性，展现层第关系，改变单一的镜头效果</li></ul></li></ul><h3 id="1-3-画面元素的远近关系"><a href="#1-3-画面元素的远近关系" class="headerlink" title="1.3 - 画面元素的远近关系"></a>1.3 - 画面元素的远近关系</h3><ul><li>不能单纯拍摄主题目标：<ul><li>而是要展现多维度的视角，使得环境和主体人物的互动关系更为明朗</li><li>在画面中借助多种元素，突出远近关系，可以增强透视效果，极大地提升画面的丰富性</li></ul></li></ul><h3 id="1-4-跟随和牵引拍摄"><a href="#1-4-跟随和牵引拍摄" class="headerlink" title="1.4 - 跟随和牵引拍摄"></a>1.4 - 跟随和牵引拍摄</h3><ul><li>使主体人物移步换景<ul><li>配合良好的构图元素，可以将主体和换景更好地融合在一起</li><li>呈现出具有律动性的画面，简历情绪或者情感上的连接关系</li></ul></li></ul><h3 id="1-5-旋转拍摄"><a href="#1-5-旋转拍摄" class="headerlink" title="1.5 - 旋转拍摄"></a>1.5 - 旋转拍摄</h3><ul><li>通过快速地旋转<ul><li>来调用环境中的所有元素，全方位地展现主体人物当前的处境或者感情</li><li>是一种主动和主体人物进行沟通的拍摄方式，可以表达悠远，深邃，离别，沉默等复杂情绪</li></ul></li></ul><h3 id="1-6-空镜头和固定镜头"><a href="#1-6-空镜头和固定镜头" class="headerlink" title="1.6 - 空镜头和固定镜头"></a>1.6 - 空镜头和固定镜头</h3><ul><li>采用静止或者悬停的方式<ul><li>拍摄没有实际意义，或者没有运动或者运动迹象的镜头</li><li>在特殊的场景中可以制造出寂静，轻悠，停滞，顿悟等特殊效果</li></ul></li></ul><h3 id="1-7-留白的艺术"><a href="#1-7-留白的艺术" class="headerlink" title="1.7 - 留白的艺术"></a>1.7 - 留白的艺术</h3><ul><li>采用大量留白的方式<ul><li>弱化主体在画面中的地位，只给主体留下很少的生存空间</li><li>制造出一种空灵，悠扬，宁静的环境感受</li></ul></li></ul><h3 id="1-8-构图技巧（黄金分割比例）"><a href="#1-8-构图技巧（黄金分割比例）" class="headerlink" title="1.8 - 构图技巧（黄金分割比例）"></a>1.8 - 构图技巧（黄金分割比例）</h3><ul><li>黄金分割比例 - 0.618<ul><li>每个画面的左右上下，其附近都有黄金分割线</li><li>为了便于拍摄，我们可以粗略地理解为黄金分割线位于画面五分之三的位置</li></ul></li></ul><h3 id="1-9-构图技巧（线条关系）"><a href="#1-9-构图技巧（线条关系）" class="headerlink" title="1.9 - 构图技巧（线条关系）"></a>1.9 - 构图技巧（线条关系）</h3><ul><li>线条包含曲线和直线<ul><li>所谓线条，是指在画面中那些具有延长性质的元素</li><li>比如远去的公路，凹凸的海湾，笔直的桥梁，横切的山脉</li><li>除了明显的线条元素之外，还有隐藏的线条元素。比如栅栏，桅杆，墙榐（zhan），墙体等</li><li>运用线条元素，可以使得画面变得丰富，趣味，多变</li></ul></li></ul><h3 id="1-10-构图技巧（边框、层级和遮挡）"><a href="#1-10-构图技巧（边框、层级和遮挡）" class="headerlink" title="1.10 - 构图技巧（边框、层级和遮挡）"></a>1.10 - 构图技巧（边框、层级和遮挡）</h3><ul><li>使得主题目标处于一个”画中画“的状态<ul><li>使任务处于版忽略的状态，约束观看者的目光实现，从而进一步强化任务的情绪和状态</li><li>一般都会采用诸如窗户，孔洞，树丛，枝叶，栏杆等具有空间形状的一般元素</li></ul></li></ul><p><code>今天先到这里有其他事情要做</code></p><p>上面主要学了有几种拍摄的方式，以及他们其实都是可以融合在一起的</p><h3 id="2-1-下载和安装final-cut-pro-x"><a href="#2-1-下载和安装final-cut-pro-x" class="headerlink" title="2.1 - 下载和安装final cut pro x"></a>2.1 - 下载和安装final cut pro x</h3><h3 id="2-2-final-cut-pro界面初探和设置"><a href="#2-2-final-cut-pro界面初探和设置" class="headerlink" title="2.2 - final cut pro界面初探和设置"></a>2.2 - final cut pro界面初探和设置</h3><h3 id="2-3-剪辑概念、意识和基础知识"><a href="#2-3-剪辑概念、意识和基础知识" class="headerlink" title="2.3 - 剪辑概念、意识和基础知识"></a>2.3 - 剪辑概念、意识和基础知识</h3><h3 id="2-4-资源库、事件和项目的综合管理"><a href="#2-4-资源库、事件和项目的综合管理" class="headerlink" title="2.4 资源库、事件和项目的综合管理"></a>2.4 资源库、事件和项目的综合管理</h3><h3 id="2-5-粗剪和时间线"><a href="#2-5-粗剪和时间线" class="headerlink" title="2.5 粗剪和时间线"></a>2.5 粗剪和时间线</h3><h3 id="2-6-精剪和磁性时间线"><a href="#2-6-精剪和磁性时间线" class="headerlink" title="2.6 精剪和磁性时间线"></a>2.6 精剪和磁性时间线</h3><h3 id="2-7-多轨道剪辑"><a href="#2-7-多轨道剪辑" class="headerlink" title="2.7 多轨道剪辑"></a>2.7 多轨道剪辑</h3><h3 id="2-8-转场"><a href="#2-8-转场" class="headerlink" title="2.8 转场"></a>2.8 转场</h3><h3 id="2-9-字幕"><a href="#2-9-字幕" class="headerlink" title="2.9 字幕"></a>2.9 字幕</h3><h3 id="2-10-音画的匹配性调整"><a href="#2-10-音画的匹配性调整" class="headerlink" title="2.10 音画的匹配性调整"></a>2.10 音画的匹配性调整</h3><h3 id="3-1-变换、裁剪、变形和防抖动"><a href="#3-1-变换、裁剪、变形和防抖动" class="headerlink" title="3.1 变换、裁剪、变形和防抖动"></a>3.1 变换、裁剪、变形和防抖动</h3><h3 id="3-2-关键帧的概念和渐进运动"><a href="#3-2-关键帧的概念和渐进运动" class="headerlink" title="3.2 关键帧的概念和渐进运动"></a>3.2 关键帧的概念和渐进运动</h3><h3 id="3-3-速率和方向"><a href="#3-3-速率和方向" class="headerlink" title="3.3 速率和方向"></a>3.3 速率和方向</h3><h3 id="3-4-视频的效果"><a href="#3-4-视频的效果" class="headerlink" title="3.4 视频的效果"></a>3.4 视频的效果</h3><h3 id="3-5-视频的艺术化效果——聚焦、抠像和遮罩"><a href="#3-5-视频的艺术化效果——聚焦、抠像和遮罩" class="headerlink" title="3.5 视频的艺术化效果——聚焦、抠像和遮罩"></a>3.5 视频的艺术化效果——聚焦、抠像和遮罩</h3><h3 id="3-6-音频的效果"><a href="#3-6-音频的效果" class="headerlink" title="3.6 音频的效果"></a>3.6 音频的效果</h3><h3 id="3-7-动画元素"><a href="#3-7-动画元素" class="headerlink" title="3.7 动画元素"></a>3.7 动画元素</h3><h3 id="3-7-动画元素-1"><a href="#3-7-动画元素-1" class="headerlink" title="3.7 动画元素"></a>3.7 动画元素</h3><h3 id="3-8-音频增强"><a href="#3-8-音频增强" class="headerlink" title="3.8 音频增强"></a>3.8 音频增强</h3><h3 id="3-7-动画元素-2"><a href="#3-7-动画元素-2" class="headerlink" title="3.7 动画元素"></a>3.7 动画元素</h3><h3 id="3-9-色彩校正——颜色、饱和度和曝光"><a href="#3-9-色彩校正——颜色、饱和度和曝光" class="headerlink" title="3.9 色彩校正——颜色、饱和度和曝光"></a>3.9 色彩校正——颜色、饱和度和曝光</h3><h3 id="3-10-色彩校正——形状遮罩和颜色遮罩"><a href="#3-10-色彩校正——形状遮罩和颜色遮罩" class="headerlink" title="3.10 色彩校正——形状遮罩和颜色遮罩"></a>3.10 色彩校正——形状遮罩和颜色遮罩</h3><h3 id="番外篇：『iCastle-Pro©系列工具（2-0）』进阶工具-解析指引"><a href="#番外篇：『iCastle-Pro©系列工具（2-0）』进阶工具-解析指引" class="headerlink" title="番外篇：『iCastle Pro©系列工具（2.0）』进阶工具 解析指引"></a>番外篇：『iCastle Pro©系列工具（2.0）』进阶工具 解析指引</h3><h3 id="尾声：其它知识项【Final-Cut-Pro教程】"><a href="#尾声：其它知识项【Final-Cut-Pro教程】" class="headerlink" title="尾声：其它知识项【Final Cut Pro教程】"></a>尾声：其它知识项【Final Cut Pro教程】</h3>]]></content>
      
      
      <categories>
          
          <category> 视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频剪辑 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十节-异步服务</title>
      <link href="2021/03/27/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E8%8A%82-%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1/"/>
      <url>2021/03/27/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%8D%81%E8%8A%82-%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><h1 id="Java-EE-项目-第十节-异步服务"><a href="#Java-EE-项目-第十节-异步服务" class="headerlink" title="Java EE 项目 - 第十节 异步服务"></a>Java EE 项目 - 第十节 异步服务</h1><p>小马哥（mercyblitz）</p><p><strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><h1 id="议题"><a href="#议题" class="headerlink" title="议题"></a><strong>议题</strong></h1><p>• Java Message Service（JMS） </p><p>• 高级消息队列协议（AMQP） </p><p>• 问答互动</p><h1 id="Java-Message-Service（JMS）"><a href="#Java-Message-Service（JMS）" class="headerlink" title="Java Message Service（JMS）"></a>Java Message Service（JMS）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java Message Service，简称JMS，为Java 程序提供一种通用的方式，来创建、发送、 </p><p>接收以及读取企业消息系统的消息。 </p><p>• 规范版本 </p><p>• JMS 1.0.2b (2001年6月26日) </p><p>• JMS 1.1 (2002年4月12日) </p><p>• JMS 2.0 (2013年5月21，维护状态)</p><p>• 面向消息中间件 </p><p>面向消息中间件（Message Oriented Middleware）是一种支持在分布式系统中发送和 </p><p>接受消息软件或者硬件的基础设施。通过非对称平台，MOM让应用模块成为分布式，同 </p><p>时减少了开发跨操作系统和网络接口应用的复杂度。 </p><p>• 优势 - 异步、路由、解耦 </p><p>• 不足 - 性能、可靠性、复杂</p><h2 id="JMS-元素"><a href="#JMS-元素" class="headerlink" title="JMS 元素"></a>JMS 元素</h2><p>• JMS 提供方（Provider）：实现JMS 接口的MOM </p><p>• JMS 客户端（Client）：生产或消费消息的应用或进程 </p><p>• JMS 生产者（Producer）：创建和发送消息的JMS客户端 </p><p>• JMS 消费者（Consumer）：接收消息的JMS客户端 </p><p>• JMS 消息 （Message）：JMS客户端之间的传输数据对象 </p><p>• JMS 队列 （Queue）：包含待读取消息的准备区域 </p><p>• JMS 主题 （Topic）：发布消息的分布机制</p><h2 id="JMS-消息"><a href="#JMS-消息" class="headerlink" title="JMS 消息"></a>JMS 消息</h2><p>• 消息头（Header） </p><p>所有消息支持相同的头字段集合，头字段包含客户端和提供方识别和路由消息的数据。 </p><p>• 消息属性（Properties） </p><p>除标准的头字段以外，提供一种内建机制来添加可选的消息头字段。 </p><p>• 应用特殊属性 </p><p>• 标准属性 </p><p>• 提供方特殊属性 </p><p>• 消息主体（Body） </p><p>JMS定义了多种消息主题类型，覆盖了主要的消息风格</p><h2 id="JMS-消息头字段（Header-Fields）"><a href="#JMS-消息头字段（Header-Fields）" class="headerlink" title="JMS 消息头字段（Header Fields）"></a>JMS 消息头字段（Header Fields）</h2><p>• JMSDestination：消息发送目的地 </p><p>• JMSDeliveryMode：消息传递模式 </p><p>• JMSMessageID：消息ID </p><p>• JMSTimestamp：消息发送时间戳 </p><p>• JMSCorrelationID：提供方特殊ID、应用特殊ID和提供方本地字节数组值</p><p>• JMSReplyTo：消息回复地址，说明消息期待回复，可选值 </p><p>• JMSRedelivered：消息重投递标识 </p><p>• JMSType：消息客户端发送消息时的类型标识 </p><p>• JMSExpiration：消息过期 </p><p>• JMSPriority：消息优先级</p><h2 id="JMS-消息主体（Body）"><a href="#JMS-消息主体（Body）" class="headerlink" title="JMS 消息主体（Body）"></a>JMS 消息主体（Body）</h2><p>JMS提供五种消息主体的形式，每种形式通过消息接口定义： </p><p>• StreamMessage：消息整体主体包含流式Java原生值，它是连续地被填充和读取的 </p><p>• MapMessage：消息整体主体包含键值对集合，其中键为字符串，值为Java原生类型。条目访问可被计算 </p><p>器连续地或者名称随机地访问，它的顺序并不一定 </p><p>• TextMessage：消息整体主体包含一个Java String 对象 </p><p>• ObjectMessage：消息整体主体包含一个Serializable 对象，如果需要使用集合对象，确保JDK 1.2或更高 </p><p>• BytesMessage：二进制字节消息</p><h2 id="JMS-消息确认（Acknowledgment）"><a href="#JMS-消息确认（Acknowledgment）" class="headerlink" title="JMS 消息确认（Acknowledgment）"></a>JMS 消息确认（Acknowledgment）</h2><p>所有JMS消息支持acknowledge方法的使用，当客户端已规定JMS消息将明确地收到。 </p><p>如果客户端使用了消息自动确认的话，调用acknowledge方法将被忽略 </p><h2 id="JMS-消息模型"><a href="#JMS-消息模型" class="headerlink" title="JMS 消息模型"></a>JMS 消息模型</h2><p>• 点对点模型（Point-To-Point Model ） </p><p>• 发布/订阅模型（Publish/subscribe Model）</p><h2 id="高级消息队列协议（AMQP）"><a href="#高级消息队列协议（AMQP）" class="headerlink" title="高级消息队列协议（AMQP）"></a>高级消息队列协议（AMQP）</h2><h3 id="•-介绍"><a href="#•-介绍" class="headerlink" title="• 介绍"></a>• 介绍</h3><p>高级消息队列协议（AMQP），全称Advanced Message Queuing Protocol，是一种针 </p><p>对面向消息中间件的开放标准应用层协议，定义了面向消息、队列、路由、可靠性和安全 </p><p>等特性。 </p><p>• 历史 </p><p>• 1.0 协议：2011年10月30日 </p><p>• 实现 </p><p>• Apache ActiveMQ </p><p>• Pivotal RabbitMQ</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Rpc特定的消息模型"><a href="#Rpc特定的消息模型" class="headerlink" title="Rpc特定的消息模型"></a>Rpc特定的消息模型</h3><ul><li>强类型语言 - java pojo based objects</li><li>弱类型语言 - rest json xml</li></ul><h3 id="面向消息中间件的消息模型"><a href="#面向消息中间件的消息模型" class="headerlink" title="面向消息中间件的消息模型"></a>面向消息中间件的消息模型</h3><ul><li>特定二进制格式，kafka，RabbitMQ</li></ul><h3 id="rpc硬刚（cpu，内存）"><a href="#rpc硬刚（cpu，内存）" class="headerlink" title="rpc硬刚（cpu，内存）"></a>rpc硬刚（cpu，内存）</h3><p>点到点</p><p>重试</p><h3 id="omm缓冲（消息对垒大小，磁盘大小）"><a href="#omm缓冲（消息对垒大小，磁盘大小）" class="headerlink" title="omm缓冲（消息对垒大小，磁盘大小）"></a>omm缓冲（消息对垒大小，磁盘大小）</h3><p>producer -  mom - consumer</p><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><h2 id="Microprofile-reactive-messaging"><a href="#Microprofile-reactive-messaging" class="headerlink" title="Microprofile reactive messaging"></a>Microprofile reactive messaging</h2><p>非常类似于Spring Cloud Stream / spring integration</p><h2 id="Servlet异步"><a href="#Servlet异步" class="headerlink" title="Servlet异步"></a>Servlet异步</h2><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="reactive-streams"><a href="#reactive-streams" class="headerlink" title="reactive streams"></a>reactive streams</h3><h4 id="Java9-flow-api"><a href="#Java9-flow-api" class="headerlink" title="Java9 flow api"></a>Java9 flow api</h4><h4 id="spring-reactor"><a href="#spring-reactor" class="headerlink" title="spring reactor"></a>spring reactor</h4><h4 id="reactive-x"><a href="#reactive-x" class="headerlink" title="reactive.x"></a>reactive.x</h4><h3 id="Reactive-stack"><a href="#Reactive-stack" class="headerlink" title="Reactive stack"></a>Reactive stack</h3><h4 id="vert-x"><a href="#vert-x" class="headerlink" title="vert.x"></a>vert.x</h4><h4 id="Spring-reactive-stack"><a href="#Spring-reactive-stack" class="headerlink" title="Spring reactive stack"></a>Spring reactive stack</h4><h3 id="Java-Messaging-stack"><a href="#Java-Messaging-stack" class="headerlink" title="Java Messaging stack"></a>Java Messaging stack</h3><h4 id="Spring-jms"><a href="#Spring-jms" class="headerlink" title="Spring jms"></a>Spring jms</h4><p>JmsTemplate</p><h4 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring  AMQP"></a>Spring  AMQP</h4><h3 id="javaEE-企业版变化"><a href="#javaEE-企业版变化" class="headerlink" title="javaEE 企业版变化"></a>javaEE 企业版变化</h3><h4 id="java2ee-j2ee"><a href="#java2ee-j2ee" class="headerlink" title="java2ee = j2ee"></a>java2ee = j2ee</h4><h4 id="java-ee"><a href="#java-ee" class="headerlink" title="java ee"></a>java ee</h4><h4 id="Jakarta-EE"><a href="#Jakarta-EE" class="headerlink" title="Jakarta EE"></a>Jakarta EE</h4><p>云原生</p><p>Ops（运维 ） – dev（开发）</p><p>Go：Docker K8s</p><p>Java生态：Java开发框架 + 大数据</p><h3 id="java-ee-规范总结"><a href="#java-ee-规范总结" class="headerlink" title="java ee 规范总结"></a>java ee 规范总结</h3><p>javaee 规范api通常比较底层，并且易学易懂，</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>MQTT协议</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><ul><li>修复本程序 org.geektimes.reactive.streams 包下</li><li>继续完善 my-rest-client POST 方法</li><li>(可选) 读一下 Servlet 3.0 关于 Servlet 异步<ul><li>AsyncContext</li></ul></li></ul><p>作业提交链接：<a href="https://jinshuju.net/f/DRe5aZ"> https://jinshuju.net/f/DRe5aZ</a></p><p>作业提交截至日期：4 月 1 日（含）前</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九节-服务调用</title>
      <link href="2021/03/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B9%9D%E8%8A%82-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
      <url>2021/03/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B9%9D%E8%8A%82-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><p>Java EE 项目 - 第九节 服务调用 </p><p>小马哥（mercyblitz）</p><p><strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><p><strong>议题</strong> </p><p>• 理论基础 </p><p>• REST 架构 </p><p>• JAX-RS 2.0 规范解读 </p><p>• MicroProfile REST Client 介绍 </p><p>• 问答互动</p><p><strong>理论基础</strong> </p><p>• 远程过程调⽤（RPC） </p><p>⼀个计算机通信协议。该协议允许运⾏于⼀台计算机的程序调⽤另⼀台计算机的⼦程序， </p><p>⽽程序员⽆需额外地为这个交互作⽤编程。如果涉及的软件采⽤⾯向对象编程，那么远程 </p><p>过程调⽤亦可称作远程调⽤或远程⽅法调⽤。 </p><p>• 例如 </p><p>• Java RMI（⼆进制协议） </p><p>• WebServices（⽂本协议）</p><p><strong>理论基础</strong> </p><p>• 消息传递 </p><p>RPC 是⼀种请求-响应协议，⼀次 RPC在客户端初始化，再由客户端将请求消息传递到远 </p><p>程的服务器，执⾏指定的带有参数的过程。经过远程服务器执⾏过程后，将结果作为响应 </p><p>内容返回到客户端。 </p><p>• 存根（Stub） </p><p>在⼀次分布式计算 RPC 中，客户端和服务器转化参数的⼀段代码。 由于存根的参数转化， </p><p>RPC 执⾏过程如同本地执⾏函数调⽤。存根必须在客户端和服务器两端均装载，并且保 </p><p>持兼容。</p><p><strong>理论基础</strong> </p><p>• 消息传递 </p><p>RPC 是⼀种请求-响应协议，⼀次 RPC在客户端初始化，再由客户端将请求消息传递到远 </p><p>程的服务器，执⾏指定的带有参数的过程。经过远程服务器执⾏过程后，将结果作为响应 </p><p>内容返回到客户端。 </p><p>• 存根（Stub） </p><p>在⼀次分布式计算 RPC 中，客户端和服务器转化参数的⼀段代码。 由于存根的参数转化， </p><p>RPC 执⾏过程如同本地执⾏函数调⽤。存根必须在客户端和服务器两端均装载，并且保 </p><p>持兼容。</p><p><strong>REST</strong> <strong>架构</strong> </p><p>• 基本概念 </p><p>REST = RESTful = Representational State Transfer，is one way of providing </p><p>interoperability between computer systems on the Internet. </p><p>• 历史 </p><p>REST 来自于Roy Thomas Fielding 2000年的博士论文 - 《Architectural Styles and </p><p>the Design of Network-based Software Architectures》</p><p><strong>REST</strong> <strong>架构</strong> </p><p>• 架构属性 </p><p>• 性能（Performance） </p><p>• 可伸缩性（Scalability） </p><p>• 统一接口简化性（Simplicity of a uniform Interface） </p><p>• 组件可修改性（Modifiability of components） </p><p>• 组件通讯可见性（Visibility of communication between components） </p><p>• 组件可移植性（Portability of component） </p><p>• 可靠性（Reliability）</p><p><strong>REST</strong> <strong>架构</strong> </p><p>• 架构约束 </p><p>• C/S架构（Client-Server） </p><p>• 无状态（Stateless） </p><p>• 可缓存（Cacheable） </p><p>• 分层系统（Layered System） </p><p>• 按需代码（Code on demand） </p><p>• 统一接口（Uniform interface)• 统一接口（Uniform interface) </p><p>• 资源识别（Identification of resources） </p><p>• URI（Uniform Resource Identifier ） </p><p>• 资源操作（Manipulation of resources through representations） </p><p>• HTTP verbs：GET、PUT、POST、DELETE </p><p>• 自描述消息（Self-descriptive messages） </p><p>• Content-Type </p><p>• MIME-Type </p><p>• Media Type： application/javascript、 text/html </p><p>• 超媒体（HATEOAS） </p><p><strong>REST</strong> <strong>架构</strong></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h2><p>主要部分：消息头（Headers）和消息体（Body）</p><p>Headers = Metadata（元数据）</p><p>Body = Data（主要数据）</p><h4 id="存根（Stub）"><a href="#存根（Stub）" class="headerlink" title="存根（Stub）"></a>存根（Stub）</h4><p>大致上等于Proxy、Handler，通常是基于Java接口编程，JDK动态代理</p><h2 id="Servlet请求与线程映射关系"><a href="#Servlet请求与线程映射关系" class="headerlink" title="Servlet请求与线程映射关系"></a>Servlet请求与线程映射关系</h2><p>ServletRequest和Thread一对一的映射关系</p><p>ServletRequestListener可以在requestInitialized方法中将对象保存在ThreadLocal中，</p><p>requestDestroyed方法中移除threadLocal引用</p><p>Servlet容器（引擎）线程实现基于线程池，当请求消亡后，但是线程还在复用</p><h2 id="REST规范"><a href="#REST规范" class="headerlink" title="REST规范"></a>REST规范</h2><h3 id="URI范例"><a href="#URI范例" class="headerlink" title="URI范例"></a>URI范例</h3><blockquote><p><a href="http://www.baidu.com/?q=mercyblitz#p">http://www.baidu.com/?q=mercyblitz#p</a></p></blockquote><p>Scheme = http</p><p>host=<a href="http://www.baidu.com/">www.baidu.com</a></p><p>Port = 80</p><p>Path = /a/b/c</p><p>Query = “q=mercyblitz”</p><p>Fragment = p</p><h3 id="REST请求基本步骤"><a href="#REST请求基本步骤" class="headerlink" title="REST请求基本步骤"></a>REST请求基本步骤</h3><p>1.构建URI - 请求资源  </p><p>UriBuilder</p><p>2.确定你请求方法 - GET、POST </p><p>@HttpMethod</p><p>3.设置请求头和参数 - Headers、Patameters</p><p>Header Name 和Header Value（多值）</p><p>Parameter  Name 和Parameter Value（多值）</p><p>数据结构：<code>Map&lt;String, List&lt;String&gt;&gt;    </code></p><p>4.设置请求主体（可选） - Body</p><p>二进制流 - 可以转化为Reader</p><p>5.URI -&gt; 设置到请求中</p><ul><li>http客户端发送<ul><li>JDK HttpURLConnection</li><li>Apache Httpclient 3.x</li><li>Apache HttpComponents</li><li>OkHttp</li></ul></li></ul><p>6.执行请求（发送到Server服务端）</p><ul><li>Servlet程序(Tomcat、jetty、Undertown)</li><li>Spring WebFlux（Netty Web Server）</li><li>Vert.x</li></ul><p>7.处理响应</p><p>​    1.正确响应（200，2xx）</p><ul><li>状态码</li><li>响应头<ul><li>数据结构：<code>Map&lt;String, List&lt;String&gt;&gt;    </code></li></ul></li><li>响应主体<ul><li>二进制</li></ul></li></ul><p>​    2.异常响应</p><p>​        1.请求有误（4xx）</p><p>​        2.服务器问题（5xx）</p><p>​        3.请求转移（3xx）</p><h2 id="JAX-RS规范"><a href="#JAX-RS规范" class="headerlink" title="JAX-RS规范"></a>JAX-RS规范</h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>基于Servlet Container</li><li>基于Standalone（独立）</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>UriBuilder</p><p>构建Java标准的java.net.URI</p><p>URI -&gt; UriBuilder#build()前提，获取UriBuilder实例</p><p>UriBuilder的静态方法获取UriBuilder实例</p><p>RuntimeDelegate</p><p> <a href="https://github.com/mercyblitz/jsr.git">https://github.com/mercyblitz/jsr.git</a></p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>创建客户端 client<ul><li>将</li><li>获取clientbuilder示例  javax.ws.rs.client.clientbuiler#newbuilder</li><li>Clientbuilder#newclient</li><li>实现javax.es.rs.client.client<ul><li>实现target方法<ul><li>实现RuntimeDelegate#createUriBulder()</li><li>实现webtarget</li></ul></li></ul></li></ul></li><li>获取web资源目标 webtarget</li><li>执行请求 suncinvoker</li><li>获取响应对象 response</li></ul><p>基于JDK httpurlconnection</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210325202322.png" alt="image-20210325202322664"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八节 持续集成和持续交付</title>
      <link href="2021/03/23/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%85%AB%E8%8A%82-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
      <url>2021/03/23/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%85%AB%E8%8A%82-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><h1 id="Java-EE-项目-第八节-持续集成和持续交付"><a href="#Java-EE-项目-第八节-持续集成和持续交付" class="headerlink" title="Java EE 项目 - 第八节 持续集成和持续交付"></a>Java EE 项目 - 第八节 持续集成和持续交付</h1><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>• Java 劝退师 </p><p>•Apache Dubbo PMC </p><p>•Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><p><strong>议题</strong> </p><p>• 持续集成 </p><p>• 持续交付 </p><p>• CI/CD 工具 </p><p>• Jenkins 运用和管理 </p><p>• 问答互动</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a><strong>持续集成</strong></h2><h2 id="•-基本概念"><a href="#•-基本概念" class="headerlink" title="• 基本概念"></a>• 基本概念</h2><p>一种软体工程流程，是将所有软件工程师对于软体的工作副本持续整合到共用主线 （mainline）的一种举措。该名称最早由葛来迪·布区（Grady Booch）在他的布区方法中提出，在测试驱动开发（TDD）的作法中，通常还会搭配自动单元测试。持续整合的 </p><p>提出主要是为解决软体进行系统整合时面临的各项问题，极限编程称这些问题为集成地狱 </p><p>（integration hell）。</p><p><strong>持续集成</strong> </p><h2 id="•-理论基础"><a href="#•-理论基础" class="headerlink" title="• 理论基础"></a>• 理论基础</h2><p>持续整合的宗旨是避免整合问题，如同在极限编程(XP)方法学中描述的整合地狱。持续整 </p><p>合并非普遍接受是用来改善整合频率的方法，因此重要的是区分两者所带来的效益。 </p><p>在极限编程方法学，持续整合需要达到最佳成果，必须依靠著自动化整合单元测试并通过 </p><p>测试驱动开发。首先必须设想在上线运作之前，已在开发环境完成并通过所有的单元测试。 </p><p>这将帮助避免一个开发者的作业流程，导致其他开发者作业的中断。如果有需要，可以在 </p><p>完整上线运作之前进用部分已完成的功能，例如使用功能切换。</p><p>接著进行CI伺服器建置概念的阐述、自动化执行单元测试的周期与每次测试需要提交给开 </p><p>发者的报告。建置CI伺服器的用途(不一定要执行单元测试) 已经开始在极限编程(XP)社群 </p><p>之外的团队练习。如今，许多企业组织已经开始采用持续性整合，而非采用完整的极限编 </p><p>程(XP)。 </p><p>除了自动化单元测试，组织在运用持续性整合(CI)一般会建置CI伺服器来维护持续性套用 </p><p>品质控制的程序-小部分的影响，并且经常性使用。除了执行单元与整合测试之外，还有 </p><p>额外的静态与动态测试，量测与描述效能，从程式来源码摘录与文件格式与促成手动品质 </p><p>保证(QA)程序。</p><p>持续性品质控制应用程式用意在提升软体品质以及减少交付的时间，在完成所有开发后， </p><p>取代传统软体上线品质控制机制。此非常相似进行频繁整合的最初概念让整合得以在QA </p><p>程序上更容易地达成。 </p><p>同样的道理，持续性交付的最佳实践进一步扩展了持续性整合(CI)，以确保软体检核在主 </p><p>要程序上并且能够布署到使用者以确保实际的布署流程可以非常快速。</p><p><strong>持续集成</strong> </p><h2 id="•-工作流程"><a href="#•-工作流程" class="headerlink" title="• 工作流程"></a>• 工作流程</h2><p>当从事变更时，开发者会从目前基础程式码库复制以进行作业，其他开发者提交程式码的 </p><p>变更至来源程式码库，并透过副本的方式取代来源程式码库的程式码。不只变更目前的程 </p><p>式码库，新的程式码也可以新增成为程式库、其它共用资源与潜在冲突。 </p><p>当分支程式码保持在取出状态时间越长，当分支程式码开发者进行主线重新整合时，就愈 </p><p>容易遭遇整合多重冲突的风险以及失败。当开发者将程式码提交到程式码库时，首先必须 </p><p>更新程式码以反映他们在程式码库中的更改，因为他们拿到了副本。程式码库包含的更改 </p><p>越多，开发人员在提交自己的更改前必须执行的工作越多。</p><p><strong>持续集成</strong> </p><h2 id="•-工作流程-1"><a href="#•-工作流程-1" class="headerlink" title="• 工作流程"></a>• 工作流程</h2><p>终于，该程式库也许变成非常不同于开发者的目标程式码，他们进入有时候被称为合并地 </p><p>狱或整合地狱的阶段，这时候开发者所花费的整合时间，将超过最初程式码开发的时间。 </p><p>持续性整合涉及预先整合与预先与经常性的整合，借此来避免踩到整合地狱的陷阱，实践 </p><p>的目标是减少重工、减少成本与时间。 </p><p>持续性整合补充的实践是在提交成果之前，每个开发人员必须执行一个完整的构建与执行 </p><p>及通过所有的单元测试、整合测试，这些都是当持续性整合伺服器侦测到程式码有新的提 </p><p>交时，必须经常性与自动化的进行。</p><p><strong>持续集成</strong> </p><h2 id="•-历史"><a href="#•-历史" class="headerlink" title="• 历史"></a>• 历史</h2><p>葛来迪·布区于1994年出版的《Object-Oriented Analysis and Design with </p><p>Applications》第二版中，首次提出持续整合这个名词。 </p><p>1997年，肯特·贝克与Ron Jeffries建立了极限编程方法，将持续整合作为极限编程的 </p><p>一部份。</p><h2 id="•-最佳实践"><a href="#•-最佳实践" class="headerlink" title="• 最佳实践"></a>• 最佳实践</h2><p>持续性整合–经常将新的或改变的程式码与现有的程式码库进行汇集，这作业应该频繁地 </p><p>发生，在提交和构建之间不存在中间窗口，并且没有错误可以在没有开发人员注意到并立 </p><p>即纠正的情况下产生。最佳的做法是透过每次提交一个程式库来触发建构，而不是定期预 </p><p>定的版本才进行建构。在快速提交的多开发者环境实践是这样的：在每次提交之后的短时 </p><p>间内触发，然后在时间到期后开始建构，或者在上次建构间隔一段时间之后。许多自动化 </p><p>工具都有提供相关的自动化排程。另一个要因是建构一个支援原子提交的版本控制系统， </p><p>此系统可以让开发人员的每次变更都可成为单一提交操作，但如试图从只有改变一半的档 </p><p>案进行构建没有意义。</p><h2 id="•-最佳实践-1"><a href="#•-最佳实践-1" class="headerlink" title="• 最佳实践"></a>• 最佳实践</h2><h3 id="•-维护一个代码库"><a href="#•-维护一个代码库" class="headerlink" title="• 维护一个代码库"></a>• 维护一个代码库</h3><p>这种做法意味著使用专案来源程式码版本控制系统。所有专案相关的程式码都需要储存在 </p><p>该程式码库中，在这种做法的控制界中，依惯例该系统应该可以从新取出的进行构建并且 </p><p>不需要额外的作业。提倡极限编程法的马丁·福勒也主张，必须有简单的工具来支援程式 </p><p>开发的分支作业。相反的，最好将所有变更整合起来而不是同时维护多个版本的软体。简 </p><p>单的说，这是将软体开发工作版本化的地方。</p><h3 id="•-自动构建"><a href="#•-自动构建" class="headerlink" title="• 自动构建"></a>• 自动构建</h3><p>透过一个单一指令来达成系统建构。许多的建构工具软体如MAKE已存在许多年，其他较 </p><p>新的工具程式都频繁的使用在持续性整合环境。建构的自动化应该包含自动化作业与整合 </p><p>作业，并且通常包含正式环境的布署。在许多案例中，程式码的建构不仅仅只是编译二进 </p><p>位元，通常总是伴随的文件的产生、网站的建构、状态数据与布署的封装媒体。(如 </p><p>Debian的DEB、Red Hat的RPM与微软的MSI档案)。</p><h3 id="•-让构建时会自我测试"><a href="#•-让构建时会自我测试" class="headerlink" title="• 让构建时会自我测试"></a>• 让构建时会自我测试</h3><p>一旦代码编辑好，下一个阶段应该要进行所有的测试，以确保软体开发的成果符合预期。 </p><p>• 每人每天都应提交一次 </p><p>透过定期的承诺，每个提交者都能够减少变更冲突的数量。一次检查一个星期的工作成果 </p><p>时，遭遇到整合冲突的风险相对交高，这时排解的困难性也相对升高。早期性系统的局部 </p><p>冲突，将可以让系统团队及时因应与进行调整建构的方向。 </p><p>一天至少提交一次(每个功能构建一次)通常被定义为持续整合的一部分。此外，建议每晚 </p><p>在提交之后立即进行建构，以上都是下限值，实际上的频率往往要高出许多。</p><h3 id="•-每份提交都应进行建置"><a href="#•-每份提交都应进行建置" class="headerlink" title="• 每份提交都应进行建置"></a>• 每份提交都应进行建置</h3><p>系统应该要在每次提交之后，针对当下的版本进行建构以确认程式可正确的整合。通常实 </p><p>务上会使用自动化进行持续整合，也许这个也可以手动进行。在许多时候，持续整合是使 </p><p>用自动化持续整合的代名词，透过持续整合伺服器或应用程序监视版本控制系统的变化， </p><p>然后自动进行建构的过程。 </p><h3 id="•-维持快速建置"><a href="#•-维持快速建置" class="headerlink" title="• 维持快速建置"></a>• 维持快速建置</h3><p>每个建置必须要维持快速完成，如此一来便可以避免整合问题。</p><h3 id="•-用线上环境的复本测试"><a href="#•-用线上环境的复本测试" class="headerlink" title="• 用线上环境的复本测试"></a>• 用线上环境的复本测试</h3><p>拥有一个测试环境并不能保证一切顺利，也会在布署上线时产生错误，因为测试环境和正 </p><p>式环境或许存在很大的差距。然而，如果要建置一份与线上环境一模一样的测试环境，还 </p><p>需要成本考量。相反的，测试环境或是独立的预备环境应该要建置实际正式环境的扩展版 </p><p>本，以在可容许的成本内同时达到维护堆叠结构技术与细微化。在那些测试环境中，服务 </p><p>虚拟化是通常运来获得，随需求存取超出团队控制的依赖关系(如API、第三方应用程式、 </p><p>第三方服务与大型主机系统)、持续演变或者因太复杂无法在虚拟实验室中还原的情境。</p><h3 id="•-让取得最新发布版本更容易"><a href="#•-让取得最新发布版本更容易" class="headerlink" title="• 让取得最新发布版本更容易"></a>• 让取得最新发布版本更容易</h3><p>使建置容易让利益关系人与测试者使用，能够减少许多因为建置的成果不合乎需求的重工 </p><p>状况。此外，提早测是能够在提早程式布署前知道变更的缺陷。在某些情况下，也可以提 </p><p>前查出错误，从而减少解决问题所需的工作量。所有程式设计师都应该从储存库更新项目 </p><p>来开始新的一天。这样，他们将可保持该程式储存库的最新状态。 </p><h3 id="•-任何人都可以检视最后建置的结果"><a href="#•-任何人都可以检视最后建置的结果" class="headerlink" title="• 任何人都可以检视最后建置的结果"></a>• 任何人都可以检视最后建置的结果</h3><p>系统应该要让任何人都可以容易寻找出建构是否中断，并且可以显示何人正在变更相关程 </p><p>式。</p><h3 id="•-自动部署"><a href="#•-自动部署" class="headerlink" title="• 自动部署"></a>• 自动部署</h3><p>大部分的持续整合系统允许在建置完成后自动执行程式码。因此能够写一段程式码来布署 </p><p>应用程式至任何人都可以观察的测试伺服器。在持续性整合未来的思考发展成像持续性布 </p><p>署迈进。持续性布署将要求直接将软体布署至测试环境中，这通常需要额外的自动化机制 </p><p>来防止程式缺陷。</p><h2 id="•-成本与效益"><a href="#•-成本与效益" class="headerlink" title="• 成本与效益"></a>• 成本与效益</h2><p>持续整合目的在产生以下效益： </p><p>• 及早发现整合错误，且由于修订的内容较小所以易于追踪，这可以节省专案的时间与 </p><p>成本。 </p><p>• 避免发布日期的前一分钟发生混乱，当每个人都会尝试为他们所造成的那一点点不相 </p><p>容的版本做检查。 </p><p>• 当单元测试失败或发生错误，若开发人员需要在不除错的情况下还原程式码库到一个 </p><p>没有问题的状态，只需要放弃一小部份的更改 (因为整合的次数频繁)。 </p><p>• 让 “最新” 的程式可保持可用的状态供测试、展示或发布用。 </p><p>• 频繁的提交程式码会促使开发人员建立模组化，低复杂性的程式码。</p><p>关于持续性自动化测试的效益： </p><p>• 强制执行频繁的自动化测试纪律 </p><p>• 当改变对全系统造成影响时立即反馈 </p><p>• 自动化测试和持续性整合产生的软件度量(如程式码覆盖度量，程式码复杂度和功能完 </p><p>整性等)标准将开发人员集中在开发功能性，高品质的程式码上，并帮助开发团队发展。</p><p>持续整合的缺点包含： </p><p>• 构建一个自动化测试套件需要大量的工作，包括不断努力以覆盖新功能，并依照特定情 </p><p>境进行程式码修改。 </p><p>• 建置系统需要一些工作，而且可能变得复杂，难以灵活修改。 </p><p>• 如果范围很小或包含无法测试的旧版程式码，持续性整合不一定有价值。 </p><p>• 增加的价值取决于测试的品质以及程式码的真实可测性。 </p><p>• 较大的团队意味著不断将程式码添加到整合队列中，因此追踪交付（同时保持品质）很 </p><p>困难，而排队可能会减慢所有人的进度。</p><p>持续整合的缺点包含： </p><p>• 构建一个自动化测试套件需要大量的工作，包括不断努力以覆盖新功能，并依照特定情 </p><p>境进行程式码修改。 </p><p>• 无论是否采用持续性整合，测试被认为是软体开发的最佳实践，测试必须依循软体布署的最佳 </p><p>实务。自动化是诸如测试驱动开发之类项目方法的一个组成部分。 </p><p>• 持续性整合可以在不需要测试套件下执行，但是如果必须手动和经常地完成，生产产品的品质 </p><p>保证成本将会提高。 </p><p>• 建置系统需要一些工作，而且可能变得复杂，难以灵活修改。 </p><p>• 如果范围很小或包含无法测试的旧版程式码，持续性整合不一定有价值。</p><p>持续整合的缺点包含： </p><p>• 增加的价值取决于测试的品质以及程式码的真实可测性。 </p><p>• 较大的团队意味著不断将程式码添加到整合队列中，因此追踪交付（同时保持品质）很 </p><p>困难，而排队可能会减慢所有人的进度。 </p><p>• 通过一天的多次提交和合并，功能的部分程式码可以轻松推送，如此一来整合测试将会 </p><p>失败直到整个功能开发完成。<strong>持续交付</strong> </p><p>• 基本概念 </p><p>一种软件工程手法，让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、 </p><p>持续的保持在随时可以释出的状况。它的目标在于让软件的建置、测试与释出变得更快以 </p><p>及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。</p><h2 id="•-与DevOps的关系"><a href="#•-与DevOps的关系" class="headerlink" title="• 与DevOps的关系"></a>• 与DevOps的关系</h2><p>持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。 </p><p>DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的 </p><p>合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续 </p><p>交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地 </p><p>执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。</p><h2 id="•-与持续部署的关系"><a href="#•-与持续部署的关系" class="headerlink" title="• 与持续部署的关系"></a>• 与持续部署的关系</h2><p>有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产 </p><p>环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可 </p><p>以选择不部署。如果要实施持续部署，必须先实施持续交付。</p><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a><strong>持续交付</strong></h2><p>• 原则<strong>CI/CD</strong> <strong>工具</strong> </p><p>• 流行工具 </p><p>• Jenkins - <a href="https://www.jenkins.io/">https://www.jenkins.io/</a> </p><p>• GitLab CI/CD - <a href="https://docs.gitlab.com/ee/ci/">https://docs.gitlab.com/ee/ci/</a> </p><p>• CircleCI - <a href="https://circleci.com/">https://circleci.com/</a> </p><p>• Github Build and Test</p><h2 id="持续集成工具"><a href="#持续集成工具" class="headerlink" title="持续集成工具"></a><strong>持续集成工具</strong></h2><p>• Jenkins（Hudson） </p><p>Jenkins是一款由Java编写的开源的持续集成工具。在与Oracle发生争执后，项目从 </p><p>Hudson项目复刻。 </p><p>Jenkins提供了软件开发的持续集成服务。它运行在Servlet容器中（例如Apache </p><p>Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、 </p><p>Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache </p><p>Maven的项目，以及任意的Shell脚本和Windows批处理命令。Jenkins的主要开发者是川 </p><p>口耕介。Jenkins是在MIT许可证下发布的自由软件。 </p><p>可以通过各种手段触发构建。例如提交给版本控制系统时被触发，也可以通过类似Cron的 </p><p>机制调度，也可以在其他的构建已经完成时，还可以通过一个特定的URL进行请求。</p><p>• Jenkins 安装 </p><p>Jenkins 提供多种安装方式，包括： </p><p>• Docker </p><p>• Kubernetes </p><p>• Linux </p><p>• Windows </p><p>• macOS </p><p>• WAR 文件</p><p>• Jenkins 基础功能 </p><p>Jenkins 支持不少的基础功能，包括： </p><p>• 安全认证 </p><p>• 搜索 </p><p>• 国际化 </p><p>• 时区 </p><p>• 远程控制 API </p><p>• Agent </p><p>• 插件整合</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h1 id="第八节-持续集成和持续交付"><a href="#第八节-持续集成和持续交付" class="headerlink" title="第八节 持续集成和持续交付"></a><strong>第八节 持续集成和持续交付</strong></h1><h2 id="大型互联网公司质量保证基本模式"><a href="#大型互联网公司质量保证基本模式" class="headerlink" title="大型互联网公司质量保证基本模式"></a><strong>大型互联网公司质量保证基本模式</strong></h2><h3 id="项目开发工作流程平台"><a href="#项目开发工作流程平台" class="headerlink" title="项目开发工作流程平台"></a><strong>项目开发工作流程平台</strong></h3><p>新建应用（基本信息） -&gt; 申请代码权限（Git、SVN）-&gt; 初始</p><p>化代码 -&gt; 提及集成 -&gt; 申请测试环境 -&gt; 验收测试环境 -&gt; 发布</p><p>预发布环境 -&gt; 预发布验收 -&gt; 线上做灰度测试（发布） -&gt; 全</p><p>面发布</p><p>发布频率，一个应用每周至少发布一次</p><p>带病上线，小步快跑，拥抱变化</p><h3 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a><strong>代码托管</strong></h3><p>SVN</p><p>GitGitLab（基于开源实现，Ruby）</p><p>项目 Rebase</p><p>开发模式</p><p>分支开发（Master 稳定）</p><p>主干为主，非稳定</p><p>Code Review</p><p>for-each lambda</p><p>CI</p><p>GitLab CI</p><h3 id="云效平台"><a href="#云效平台" class="headerlink" title="云效平台"></a><strong>云效平台</strong></h3><p>代码编辑器</p><p>代码管理</p><p>Code Review</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h3><p>类的测试覆盖度（9成）</p><p>Assert.assert( 1 == 1 );</p><p>行的测试覆盖度</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h3><p>Junit 4 - 最常用</p><p>Junit 5 - 支持并发测试（多次重复测试）</p><p>TestNG - 支持并发测试</p><p>Mock 工具</p><p>Mockito - 面向接口 Mock - 动态代理</p><p>字节码提升</p><h3 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a><strong>测试驱动开发</strong></h3><p>特性</p><p>测试 -&gt; 测试用例 -&gt; 业务逻辑稳定</p><p>现实中的互联网</p><p>业务不稳定</p><p>业务评审 -&gt; 业务需求文档确定 -&gt; 测试用例（描述性） -&gt; 开</p><p>发（测试用例实现）</p><h3 id="持续集成工具-1"><a href="#持续集成工具-1" class="headerlink" title="持续集成工具"></a><strong>持续集成工具</strong></h3><p>流水线 -&gt; 工作流程 -&gt; 阶段性运行</p><p>Pipeline -&gt; Valve（阀门）</p><p>自动化</p><p>事件触发（主动）</p><p>周期性触发</p><p>变化性触发（被动）</p><h3 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a><strong>工具推荐</strong></h3><p>TravisCI</p><p>通过 YML 配置初始化环境，构建虚拟资源（Docker 镜</p><p>像），执行任务</p><p>CircleCI</p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><strong>Jenkins</strong></h3><p><strong>运行方式**</strong>可执行** <strong>WAR</strong></p><p>java -jar jenkins.war</p><p><strong>初始化设置</strong></p><p><a href="https://www.jenkins.io/doc/book/installing/initial-setting">https://www.jenkins.io/doc/book/installing/initial-setting</a></p><p>s/</p><p><strong>插件安装和管理</strong></p><p><strong>JDK</strong> <strong>安装</strong></p><p>在 Global Configuration Tool</p><p><strong>Maven</strong> <strong>安装</strong></p><p><strong>创建工程**</strong>流行架构**</p><p><strong>Serverless</strong> <strong>架构</strong></p><p>Web IDE</p><p>特别依赖于 CI/CD</p><p>Jenkins 被包装</p><p>内核</p><p>Web GUI</p><p>JMeter</p><p><strong>国内外的项目管理差异</strong></p><p>国外</p><p>人力成本高（工具）</p><p>国内</p><p>人工发布 -&gt; 半自动化 -&gt; 自动化（aone）</p><p>智能运维</p><p>AI 运维</p><h2 id="个人开发偏好"><a href="#个人开发偏好" class="headerlink" title="个人开发偏好"></a><strong>个人开发偏好</strong></h2><p>任何事件都是独立的，即使是靠谱的人，也有不靠谱的时</p><p>候</p><p>功能开发都要确保单元测试和集成测试（可选）单元测试类的覆盖度 &gt;= 90%，行覆盖度 &gt;= 80%</p><p>文档不能太少，基本要与代码持平（尤其是帮助文档）</p><p>用户输入是不可靠的，所以需要验证所有的条件分支</p><p><strong>项目经历</strong></p><p>TAE（Taobao Application Engine），参考 GAE，K8s</p><p>DevOps</p><p>Code Base（Git、SVN）</p><p>GUI 管理界面</p><p>Code workspace</p><p>自动化（CI/CD）</p><p>Tools</p><p>TAE SDK</p><p>语言支持</p><p>PHP - Cauous</p><p>Java</p><p>Groovy</p><p>Scala</p><p>Ruby - JRuby</p><p>Python - Jython</p><p>JavaScript</p><h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a><strong>推荐资料</strong></h2><p><strong>书籍推荐</strong></p><p>企业整合模式</p><p>敏捷开发</p><p>XP</p><p>迭代开发（Integration）</p><p>人月神话</p><p>TDD（测试驱动开发）</p><p>互联网开发 - 简单粗暴，快速上线</p><p>SOFA - 基于 Spring Framework + OSGI</p><p>1.xml ( a.jar )</p><p><bean id="interceptor" class="..."></bean></p><p>2.xml ( b.jar )</p><bean id="container"> <property name="list"> <bean id="interceptor1" class="..."> </bean> </property> </bean><h2 id="本次作业"><a href="#本次作业" class="headerlink" title="本次作业"></a><strong>本次作业</strong></h2><ol><li><p>完善 my dependency-injection 模块</p><p>脱离 web.xml 配置实现 ComponentContext 自动初始化</p><p>使用独立模块并且能够在 user-web 中运行成功</p></li><li><p>完善 my-configuration 模块</p><p>Config 对象如何能被 my-web-mvc 使用</p><p>​    可能在 ServletContext 获取</p><p>​    如何通过 ThreadLocal 获取</p></li><li><p>去提前阅读 Servlet 规范中 Security 章节（Servlet 容器安全）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 Maven 项目管理</title>
      <link href="2021/03/23/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%83%E8%8A%82-Maven-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>2021/03/23/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%83%E8%8A%82-Maven-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><h1 id="Java-EE-项目-第七节-Maven-项目管理"><a href="#Java-EE-项目-第七节-Maven-项目管理" class="headerlink" title="Java EE 项目 - 第七节 Maven 项目管理"></a>Java EE 项目 - 第七节 Maven 项目管理</h1><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>• Java 劝退师 </p><p>•Apache Dubbo PMC </p><p>•Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者<strong>议题</strong> </p><p>• Maven 基础 </p><p>• Maven 生命周期 </p><p>• Maven 常用插件 </p><p>• Maven 插件扩展 </p><p>• 问答互动</p><h2 id="Maven-基础"><a href="#Maven-基础" class="headerlink" title="Maven 基础"></a><strong>Maven</strong> <strong>基础</strong></h2><h2 id="•-什么是-Maven？"><a href="#•-什么是-Maven？" class="headerlink" title="• 什么是 Maven？"></a>• 什么是 Maven？</h2><p>Maven是一个意思是知识积累者的Yiddish词，开始试图简化 Jakarta Turbine 项目的 </p><p>构建过程。有几个项目，每个项目都有自己的 Ant 构建文件，这些都略有不同。罐子被 </p><p>检查成CVS。我们想要一种标准的方式来构建项目，明确定义项目组成内容，发布项目信 </p><p>息的简便方法，以及在多个项目中共享JAR的方法。 Maven 现在可以用于构建和管理任 </p><p>何基于Java的项目。我们希望我们已经创建了一些能够使Java开发人员的日常工作更容 </p><p>易，并且通常有助于理解任何基于Java的项目。</p><h2 id="•-Maven-的目标"><a href="#•-Maven-的目标" class="headerlink" title="• Maven 的目标"></a>• Maven 的目标</h2><p>Maven的主要目标是让开发人员在最短的时间内理解开发工作的完整状态。为了实现这 </p><p>一目标，Maven处理了几个值得关注的领域： </p><p>• 使构建过程变得简单 </p><p>• 提供统一的构建系统 </p><p>• 提供高质量的项目信息 </p><p>• 鼓励更好的发展实践</p><p>• 使构建过程变得简单 </p><p>虽然使用Maven并没有消除了解底层机制的需要，但Maven确实为开发人员提供了许多 </p><p>细节。 </p><p>• 提供统一的构建系统 </p><p>Maven使用其项目对象模型（POM）和一组插件构建项目。一旦你熟悉了一个Maven项 </p><p>目，你就知道所有Maven项目都是如何构建的。这可以在导航许多项目时节省时间。</p><p>• 提供高质量的项目信息 </p><p>Maven提供有用的项目信息，部分来自POM，部分来自项目来源。例如，Maven可以提 </p><p>供</p><p>• 直接从源码控制创建更改日志 </p><p>• 交叉引用的来源 </p><p>• 由项目管理的邮件列表 </p><p>• 项目使用的依赖关系 </p><p>• 单位测试报告，包括覆盖范围</p><p>• 鼓励更好的发展实践 </p><p>Maven旨在收集最佳实践开发的当前原则，并轻松指导项目朝这个方向发展。例如，单 </p><p>元测试的规范，执行和报告是使用Maven的正常构建周期的一部分。目前的单位测试最 </p><p>佳实践被用作指导方针： </p><p>• 将测试源代码保存在单独但并行的源树中 </p><p>• 使用测试用例命名约定来定位和执行测试 </p><p>• 让测试用例设置他们的环境，而不是自定义构建以进行测试准备</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-功能列表"><a href="#•-功能列表" class="headerlink" title="• 功能列表"></a>• 功能列表</h2><p>• 遵循最佳实践的简单项目设置-在几秒钟内启动新项目或模块 </p><p>• 所有项目的一致使用-意味着新开发人员没有时间进入项目 </p><p>• 高级依赖管理，包括自动更新，依赖闭包（也称为传递依赖关系） </p><p>• 能够轻松地同时处理多个项目 </p><p>• 一个庞大且不断增长的图书馆和元数据存储库，用于开箱即用，并与最大的开源项目 </p><p>进行安排，以便实时提供最新版本 </p><p>• 可扩展，能够轻松地用Java或脚本语言编写插件 </p><p>• 即时访问几乎没有或没有额外配置的新功能 </p><p>• Ant 任务的依赖管理和部署在Maven之外</p><p>• 基于模型的构建：Maven能够基于项目的元数据将任意数量的项目构建到预定义的输 </p><p>出类型中，例如JAR，WAR或分发，而在大多数情况下无需执行任何脚本 </p><p>• 项目信息的一致站点：使用与构建过程相同的元数据，Maven能够生成网站或PDF， </p><p>包括您要添加的任何文档，并添加到该标准报告中有关项目开发状态的报告。此信息 </p><p>的示例可以在“项目信息”和“项目报告”子菜单下的该站点左侧导航的底部看到 </p><p>• 发布管理和分发发布：如果没有太多额外的配置，Maven将与您的源码控制系统（如 </p><p>SVN或Git）集成，并基于某个标签管理项目的发布。它还可以将其发布到分发位置以 </p><p>供其他项目使用。Maven能够发布单个输出，例如JAR，包含其他依赖项和文档的存 </p><p>档，或作为源码分发</p><p>• 依赖管理：Maven鼓励使用JAR和其他依赖项的中央存储库。Maven提供了一种机 </p><p>制，您的项目客户端可以使用该机制从中央JAR存储库下载构建项目所需的任何JAR， </p><p>就像Perl的CPAN一样。这允许Maven的用户在项目之间重用</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-什么是-POM？"><a href="#•-什么是-POM？" class="headerlink" title="• 什么是 POM？"></a>• 什么是 POM？</h2><p>项目对象模型（POM）是Maven的基本工作单元。它是一个XML文件，包含有关项目的 </p><p>信息和Maven用于构建项目的配置详细信息。它包含大多数项目的默认值。例如build目 </p><p>录，它是target；source目录，它是src/main/java；test source目录，它是 </p><p>src/test/java；等等。当执行任务或目标时，Maven在当前目录中查找POM。它读取 </p><p>POM，获取所需的配置信息，然后执行目标。POM中可以指定的一些配置包括项目依赖 </p><p>项、可以执行的插件或目标、构建概要文件等等。还可以指定其他信息，如项目版本、描 </p><p>述、开发人员、邮件列表等。</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-项目继承"><a href="#•-项目继承" class="headerlink" title="• 项目继承"></a>• 项目继承</h2><p>POM中合并的元素如下： </p><p>• dependencies </p><p>• developers and contributors </p><p>• plugin lists (including reports) </p><p>• plugin executions with matching ids </p><p>• plugin configuration </p><p>• resources</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-项目聚合"><a href="#•-项目聚合" class="headerlink" title="• 项目聚合"></a>• 项目聚合</h2><p>项目聚合类似于项目继承。但是它不是从模块中指定父POM，而是从父POM中指定模块。 </p><p>通过这样做，父项目现在知道了它的模块，如果对父项目调用了Maven命令，那么 </p><p>Maven命令也将被执行到父项目的模块中。要进行项目聚合，必须执行以下操作： </p><p>• 将父POMs packaging更改为值“pom”。 </p><p>• 在父POM中指定其模块（子POM）的目录。</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-项目继承-V-S-项目聚合"><a href="#•-项目继承-V-S-项目聚合" class="headerlink" title="• 项目继承 V.S 项目聚合"></a>• 项目继承 V.S 项目聚合</h2><p>如果您有几个Maven项目，并且它们都具有相似的配置，那么您可以通过提取这些相似 </p><p>的配置并生成父项目来重构您的项目。因此，您所要做的就是让Maven项目继承父项目， </p><p>然后这些配置将应用于所有这些项目。 </p><p>如果您有一组一起生成或处理的项目，则可以创建一个父项目，并让该父项目将这些项目 </p><p>声明为其模块。这样做，您只需构建父级，其余的就可以了。</p><p>当然，您可以同时拥有项目继承和项目聚合。也就是说，您可以让您的模块指定父项目， </p><p>同时让父项目指定那些Maven项目作为其模块。你只需要应用这三条规则： </p><p>• 在每个子POM中指定其父POM是谁。 </p><p>• 将父POMs packaging更改为值“pom”。 </p><p>• 在父POM中指定其模块（子POM）的目录</p><h2 id="•-项目插值和变量"><a href="#•-项目插值和变量" class="headerlink" title="• 项目插值和变量"></a>• 项目插值和变量</h2><p>Maven鼓励的一个做法是不要重复你自己。但是，在某些情况下，您需要在多个不同的 </p><p>位置使用相同的值。为了帮助确保值只指定一次，Maven允许您在POM中使用自己的和 </p><p>预定义的变量。 </p><p>需要注意的一个因素是，如上所述，这些变量是在继承之后处理的。这意味着，如果父项 </p><p>目使用变量，那么最终使用的将是它在子项目中的定义，而不是父项目中的定义。</p><h2 id="•-可用变量"><a href="#•-可用变量" class="headerlink" title="• 可用变量"></a>• 可用变量</h2><p>作为单个值元素的模型的任何字段都可以作为变量引用。例如${项目.groupId}, ${项目.版 </p><p>本}, ${project.build.source目录}等等。请参阅POM参考以查看完整的属性列表。 </p><p>这些变量都由前缀“project”引用。你也可以看到pom的引用。作为前缀，或完全省略 </p><p>前缀-这些形式现在已被弃用，不应使用。</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-构建配置（Build-Profiles）"><a href="#•-构建配置（Build-Profiles）" class="headerlink" title="• 构建配置（Build Profiles）"></a>• 构建配置（Build Profiles）</h2><p>Apache Maven竭尽全力确保构建是可移植的。除此之外，这意味着允许在POM内进行 </p><p>构建配置，避免所有文件系统引用（在继承、依赖项和其他位置），并且更加依赖于本地 </p><p>存储库来存储实现这一点所需的元数据。 </p><p>然而，有时可移植性并不是完全可能的。在某些情况下，插件可能需要配置本地文件系统 </p><p>路径。在其他情况下，需要稍微不同的依赖集，并且项目的工件名称可能需要稍微调整。 </p><p>还有一些时候，甚至可能需要在构建生命周期中包含一个完整的插件，具体取决于检测到 </p><p>的构建环境。</p><p>为了解决这些情况，Maven支持构建概要文件。概要文件是使用POM本身中可用的元素 </p><p>子集（加上一个额外的部分）指定的，并以各种方式触发。它们在构建时修改POM，并 </p><p>用于互补集合中，为一组目标环境提供等效但不同的参数（例如，提供开发、测试和生产 </p><p>环境中appserver根的路径）。因此，概要文件很容易导致团队中不同成员的不同构建结 </p><p>果。但是，如果使用得当，可以在保持项目可移植性的同时使用概要文件。这也将最小化 </p><p>maven的-f选项的使用，该选项允许用户创建另一个具有不同参数或配置的POM来构建， </p><p>这使得它更易于维护，因为它只使用一个POM运行。</p><p>• 不同类型的配置（Profiles） </p><p>• 单个工程 </p><p>在POM本身中定义(pom.xml文件) </p><p>• 单个用户 </p><p>在Maven设置（%USER\u HOME%/.m2）中定义/设置.xml) </p><p>• 全局 </p><p>Defined in the global Maven-settings (${maven.home}/conf/settings.xml)</p><p>• 激活配置（Profiles） </p><p>配置文件可以通过多种方式激活： </p><p>• 从命令行 </p><p>• 通过Maven设置 </p><p>• 基于环境变量 </p><p>• 操作系统设置 </p><p>• 存在或缺少文件</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-标准目录结构"><a href="#•-标准目录结构" class="headerlink" title="• 标准目录结构"></a>• 标准目录结构</h2><p>拥有一个公共目录结构，让熟悉一个Maven项目的用户能够在另一个Maven项目中立即 </p><p>感到宾至如归。其优点类似于采用全站式外观和感觉。 </p><p>• src/main/java - 应用程序/库源代码 </p><p>• src/main/resources - 应用程序/库资源 </p><p>• src/main/webapp - Web应用程序源 </p><p>• src/test/java - 测试源代码 </p><p>• src/test/resources - 测试资源 </p><p>• src/it - 集成测试（主要针对插件） </p><p>• src/assembly - 程序集描述符</p><p>• src/site - 站点 </p><p>• LICENSE.txt - 项目许可证 </p><p>• NOTICE.txt - 项目所依赖的库所需的通知和属性 </p><p>• README.txt - 项目自述</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-依赖机制"><a href="#•-依赖机制" class="headerlink" title="• 依赖机制"></a>• 依赖机制</h2><p>依赖关系管理是Maven的一个核心特性。管理单个项目的依赖关系很容易。管理由数百 </p><p>个模块组成的多模块项目和应用程序的依赖关系是可能的。Maven在定义、创建和维护 </p><p>具有良好定义的类路径和库版本的可复制构建方面提供了很大的帮助。</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-可传递依赖"><a href="#•-可传递依赖" class="headerlink" title="• 可传递依赖"></a>• 可传递依赖</h2><p>Maven通过自动包含可传递的依赖项，避免了发现和指定您自己的依赖项所需的库的需 </p><p>要。</p><p>通过从指定的远程存储库读取依赖项的项目文件，可以简化此功能。通常，这些项目的所 </p><p>有依赖项都会在您的项目中使用，就像项目从其父项目或其依赖项继承的任何依赖项一样， </p><p>依此类推。 </p><p>可以从中收集依赖项的级别数量没有限制。只有在发现循环依赖时才会出现问题。 </p><p>有了可传递的依赖关系，包含的库的图可以很快变大。因此，还有一些附加功能限制了包 </p><p>含哪些依赖项：</p><p>• 依赖仲裁（Dependency mediation）- 这决定了当多个版本作为依赖项遇到时，将选 </p><p>择工件的哪个版本。Maven选择“最接近的定义”。也就是说，它使用依赖关系树中 </p><p>与项目最接近的依赖关系的版本。您可以通过在项目的POM中显式声明来保证一个版 </p><p>本。请注意，如果两个依赖关系版本在依赖关系树中处于同一深度，则第一个声明获胜 </p><p>• 依赖管理（Dependency management）- 这允许项目作者直接指定在可传递依赖项 </p><p>或未指定版本的依赖项中遇到的工件的版本。在上一节中的示例中，依赖项直接添加到 </p><p>了，即使a没有直接使用它。相反，a可以将D作为依赖项包含在其 </p><p>dependencyManagement节中，并直接控制在引用D时使用哪个版本的D</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-可传递依赖-1"><a href="#•-可传递依赖-1" class="headerlink" title="• 可传递依赖"></a>• 可传递依赖</h2><h2 id="•-依赖作用域（Dependency-scope）"><a href="#•-依赖作用域（Dependency-scope）" class="headerlink" title="• 依赖作用域（Dependency scope）"></a>• 依赖作用域（Dependency scope）</h2><ul><li>这允许您只包含适用于构建的当前阶段的依赖项。 </li></ul><p>下面将对此进行更详细的描述 </p><p>• 排除依赖（Excluded dependencies）- 如果项目X依赖于项目Y，而项目Y依赖于项目 </p><p>Z，那么项目X的所有者可以使用“exclusion”元素显式排除项目Z作为依赖项 </p><p>• 可选依赖（Optional dependencies） - 如果项目Y依赖于项目Z，那么项目Y的所有者 </p><p>可以使用“optional”元素将项目Z标记为可选依赖项。当项目X依赖于项目Y时，X将 </p><p>只依赖于Y而不依赖于Y的可选依赖项Z。然后，项目X的所有者可以根据自己的选择显 </p><p>式地添加对Z的依赖项。（将可选依赖项视为“默认排除”可能会有所帮助。）</p><p>依赖作用域用于限制依赖项的可传递性，并确定依赖项何时包含在类路径中。共有6个作 </p><p>用域： </p><p>• compile - 如果没有指定，则使用默认范围。编译依赖项在项目的所有类路径中都可用。 </p><p>此外，这些依赖关系被传播到依赖项目 </p><p>• provided - 这很像compile，但表示您希望JDK或容器在运行时提供依赖关系。例如， </p><p>在为javaenterpriseedition构建web应用程序时，您可以将对Servlet API和相关 </p><p>javaeeapi的依赖关系设置为提供的范围，因为web容器提供了这些类。具有此作用域 </p><p>的依赖项将添加到用于编译和测试的类路径，而不是运行时类路径。它是不可传递的</p><p>• runtime - 此范围表示编译时不需要依赖项，但执行时需要依赖项。Maven在运行时和 </p><p>测试类路径中包含具有此范围的依赖项，但在编译类路径中不包含 </p><p>• test - 此范围表示应用程序的正常使用不需要依赖关系，仅在测试编译和执行阶段可用。 </p><p>此范围不可传递。通常这个范围用于测试库，比如JUnit和Mockito。如果非测试库 </p><p>（如apachecommons IO）用于单元测试（src/test/java），而不用于模型代码 </p><p>（src/main/java），那么它也可以用于这些库</p><p>• system - 这个范围与provided类似，只是您必须提供显式包含它的JAR。工件总是可 </p><p>用的，不会在存储库中查找 </p><p>• import - 只有<dependencymanagement>部分中pom类型的依赖项才支持此范围。 </dependencymanagement></p><p>它表示将用指定POM的<dependencymanagement>部分中的有效依赖项列表替换依 </dependencymanagement></p><p>赖项。因为它们被替换了，所以具有导入范围的依赖项实际上并不参与限制依赖项的可 </p><p>传递性• 依赖作用域 </p><p>每个作用域（ import 除外）都以不同的方式影响可传递依赖项，如下表所示。如果将依 </p><p>赖项设置为左列中的范围，则该依赖项的可传递依赖项（该依赖项的范围在顶行中）将导 </p><p>致主项目中的依赖项（该依赖项的范围在相交处列出）。如果没有列出任何范围，则表示 </p><p>忽略了依赖关系 </p><p><strong>Maven</strong> <strong>基础</strong> </p><p>compile provided runtime test </p><p>compile compile(*) - runtime - </p><p>provided provided - provided - </p><p>runtime runtime - runtime - </p><p>test test - test -</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-依赖管理"><a href="#•-依赖管理" class="headerlink" title="• 依赖管理"></a>• 依赖管理</h2><p>依赖关系管理部分是一种集中依赖关系信息的机制。当您有一组从公共父级继承的项目时， </p><p>可以将有关依赖关系的所有信息放在公共POM中，并对子POM中的工件进行更简单的引 </p><p>用</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-可选依赖"><a href="#•-可选依赖" class="headerlink" title="• 可选依赖"></a>• 可选依赖</h2><p>当无法（无论出于何种原因）将项目拆分为子模块时，使用可选依赖项。其思想是，某些 </p><p>依赖项仅用于项目中的某些特性，如果不使用该特性，则不需要这些依赖项。理想情况下， </p><p>这样一个特性将被分解成一个子模块，该子模块依赖于核心功能项目。这个新的子项目只 </p><p>有非可选依赖项，因为如果您决定使用子项目的功能，那么您将需要它们。 </p><p>但是，由于项目不能拆分（无论出于何种原因，再次），这些依赖项被声明为可选的。如 </p><p>果用户想要使用与可选依赖项相关的功能，他们必须在自己的项目中重新声明该可选依赖 </p><p>项。这不是处理这种情况的最清晰的方法，但是可选的依赖项和依赖项排除都是权宜之计。</p><p><strong>Maven</strong> <strong>基础</strong> </p><h2 id="•-依赖排除"><a href="#•-依赖排除" class="headerlink" title="• 依赖排除"></a>• 依赖排除</h2><p>由于Maven以传递方式解析依赖项，因此不需要的依赖项可能会包含在项目的类路径中。 </p><p>例如，某个较旧的jar可能存在安全问题，或者与您正在使用的Java版本不兼容。为了解 </p><p>决这个问题，Maven允许您排除特定的依赖关系。排除是在POM中的特定依赖项上设置 </p><p>的，并且针对特定的groupId和artifactId。在构建项目时，不会通过声明排除的依赖项将 </p><p>该工件添加到项目的类路径中。</p><p><strong>Maven</strong> <strong>生命周期</strong> </p><h2 id="•-构建生命周期"><a href="#•-构建生命周期" class="headerlink" title="• 构建生命周期"></a>• 构建生命周期</h2><p>Maven基于构建生命周期的核心概念。这意味着构建和分发特定工件（项目）的过程是 </p><p>明确定义的。 </p><p>对于构建项目的人来说，这意味着只需要学习一小部分命令就可以构建任何Maven项目， </p><p>POM将确保他们获得所需的结果。 </p><p>有三个内置的构建生命周期：default、clean和site。默认生命周期处理项目部署，清理 </p><p>生命周期处理项目清理，而站点生命周期处理项目站点文档的创建。</p><p><strong>Maven</strong> <strong>生命周期</strong> </p><h2 id="•-生命周期阶段"><a href="#•-生命周期阶段" class="headerlink" title="• 生命周期阶段"></a>• 生命周期阶段</h2><p>每个构建生命周期都由不同的构建阶段列表定义，其中构建阶段表示生命周期中的一个阶 </p><p>段。例如，默认生命周期由以下阶段组成： </p><p>• validate - 验证项目是否正确，所有必要的信息是否可用 </p><p>• compile - 编译项目的源代码 </p><p>• test - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求打包或部署代码</p><p>• package - 把编译好的代码打包成可分发的格式，比如JAR </p><p>• verify - 对集成测试的结果进行检查，以确保符合质量标准 </p><p>• install - 将包安装到本地存储库中，作为本地其他项目的依赖项使用 </p><p>• deploy - 在构建环境中完成，将最终包复制到远程存储库，以便与其他开发人员和项目共享</p><p><strong>Maven</strong> <strong>常用插件</strong> </p><h2 id="•-常用-Maven-插件"><a href="#•-常用-Maven-插件" class="headerlink" title="• 常用 Maven 插件"></a>• 常用 Maven 插件</h2><p>• compiler </p><p>• source </p><p>• javadoc </p><p>• deploy </p><p>• shade </p><p>• flatten </p><p>• surefire</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h1 id="第七节-Maven-项目管理"><a href="#第七节-Maven-项目管理" class="headerlink" title="第七节 Maven 项目管理"></a><strong>第七节</strong> <strong>Maven</strong> <strong>项目管理</strong></h1><h2 id="Maven-artifact-发布"><a href="#Maven-artifact-发布" class="headerlink" title="Maven artifact 发布"></a><strong>Maven artifact</strong> <strong>发布</strong></h2><p>MAVAE_HOME/conf/settings.xml 文件配置远程信息（地</p><p>址、用户名和密码）</p><p>通过 mvn deploy 上传到远程 Maven 仓库</p><p>SNAPSHOT 不需要确认</p><p>正式发布确认（需要配置是否要再次确认）</p><p>Maven 中央仓库（中心节点）</p><p>开源软件发布内容</p><p>开源软件自己仓库</p><p>Maven 镜像（aliyun）</p><h2 id="Maven-Profiles"><a href="#Maven-Profiles" class="headerlink" title="Maven Profiles"></a><strong>Maven Profiles</strong></h2><p>通过命令</p><p>mvn -P my-profile-1optional 主要是控制当前依赖是否传递，需要对高层应用将</p><p>这个 optional 依赖单独引入（解决 jar 冲突的问题）</p><p>provided 是决定打包后的jar 或 war 是否将这个依赖作为包</p><p>的一部分</p><h2 id="Maven-常见"><a href="#Maven-常见" class="headerlink" title="Maven 常见"></a><strong>Maven</strong> <strong>常见</strong></h2><h3 id="flatten-maven-plugin"><a href="#flatten-maven-plugin" class="headerlink" title="flatten-maven-plugin"></a><strong>flatten-maven-plugin</strong></h3><p>用于静态替换 pom.xml 中的占位符</p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a><strong>相关技术</strong></h2><h2 id="Java-构建工具"><a href="#Java-构建工具" class="headerlink" title="Java 构建工具"></a><strong>Java</strong> <strong>构建工具</strong></h2><h3 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a><strong>Ant</strong></h3><h3 id="Ivy-Based-Ant"><a href="#Ivy-Based-Ant" class="headerlink" title="Ivy + Based Ant"></a><strong>Ivy + Based Ant</strong></h3><h3 id="Antx"><a href="#Antx" class="headerlink" title="Antx"></a><strong>Antx</strong></h3><p>Maven 编译完成 jar -&gt; a.xml ${user.name} -&gt; 解压 -&gt; a.xml</p><p>abc -&gt; 加压 -&gt; jar 或 war</p><p>Velocity</p><p>antx.properties</p><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a><strong>Web</strong> <strong>框架</strong></h2><h3 id="Servlet-技术栈框架"><a href="#Servlet-技术栈框架" class="headerlink" title="Servlet 技术栈框架"></a><strong>Servlet</strong> <strong>技术栈框架</strong></h3><p>Apache Struts 1.x &amp; 2.x</p><p>Wiket</p><p>JSF</p><p>Spring MVC</p><beans> <p>#if() </p><p><bean></bean> </p><p>#else </p><p><bean></bean> </p></beans> <p>user.name = abc多视图实现</p><p>ViewResolver</p><p>JSP - InternalResourceViewResolver</p><p>Velocitty - VelocityViewResolver</p><p>FreeMarker - FreemarkerViewResolver</p><p>Alibaba Webx</p><p>Turbine</p><p>Velocity</p><p>Spring 扩展</p><p>Velocity</p><p>“借鉴” Apache Commons（Fork）</p><p>Turbine</p><p>多视图渲染</p><p>JSP</p><p>Java 编译时字节码</p><p>Velocity</p><p>字节码在运行时（通过反射）</p><p>阿里 Web 框架 - Webx</p><p>Java v.s GOJava VS RUST</p><p>Java Native 内存少、启动快 -&gt; Serverless</p><p>APT = Annotation Processing Tool</p><p>Lombok</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 监控管理</title>
      <link href="2021/03/13/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%85%AD%E8%8A%82%20%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86/"/>
      <url>2021/03/13/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%85%AD%E8%8A%82%20%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><p>Java EE 项目 - 第六节 监控管理 </p><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><p><strong>议题</strong> </p><p>• JMX 基础 </p><p>• JMX 工具 </p><p>• 问答互动</p><p>• JMX 介绍 </p><p>JMX 全称 Java Management Extensions，技术提供构建分布式、Web、模块化的工 </p><p>具，以及管理和监控设备和应用的动态解决方案。从 Java 5 开始，JMX API 作为 Java </p><p>平台的一部分。 </p><p>• 规范 </p><p>• JSR 3：JMX 1.0、JMX 1.1和 1.2（作为Java 5的一部分） </p><p>• JMX 1.4：2006.11.09（作为Java 6的一部分） </p><p>• JSR 255：JMX 2.0 </p><p>• JSR 160：JMX Remote API 1.0 </p><p>• JSR 262：JMX Remote API for Web Services </p><p><strong>JMX</strong> <strong>基础</strong></p><p><strong>**</strong>JMX** <strong>基础</strong> </p><p>• JMX 优势 </p><p>• 激活应用管理无需大量投资 </p><p>• 提供伸缩性管理架构 </p><p>• 整合现有的管理解决方案 </p><p>• 对现有的Java技术起到杠杆作用 </p><p>• 能够扛起未来管理概念 </p><p>• 定义面向接口管理<strong>JMX</strong> <strong>基础</strong> </p><p>• JMX 架构概况 </p><p>• 设备级别（Instrumentation Level） </p><p>• 代理级别（Agent Level） </p><p>• 分布式服务级别（Distributed Services Level） </p><p>• 可添加管理协议API</p><p><strong>JMX</strong> <strong>基础</strong> </p><p>• JMX 架构概况• JMX 设备级别 </p><p>• 管理Bean（MBeans） </p><p>• 标准 MBeans </p><p>• 动态 MBeans </p><p>• 开放 MBeans </p><p>• 模型 MBeans </p><p>• 通知模型（Notification Model） </p><p>• MBean 元数据类（MetaData Class） </p><p><strong>JMX</strong> <strong>基础</strong></p><p>*JMX** <strong>基础</strong> </p><p>• JMX 管理Bean（MBeans） </p><p>• 标准 MBeans </p><p>设计和实现最为简单，Bean的管理 通过接口方法来描述。MXBean 是一种特殊标准MBean，它使用开放 </p><p>MBean的概念，允许通用管理，同时简化编码 </p><p>• 动态 MBeans </p><p>必须实现指定的接口，不过它在运行时能让管理接口发挥最大弹性 </p><p>• 开放 MBeans </p><p>动态 MBean，提供通用管理所依赖的基本数据类型以及用户友好的自描述信息 </p><p>• 模型 MBeans </p><p>同样也是动态MBean，在运行时能够完全可配置和自描述，为动态的设备资源提供带有默认行为的MBean泛 </p><p>型类<strong>JMX</strong> <strong>基础</strong> </p><p>• JMX 管理Bean（MBeans） </p><p>• 标准 MBeans </p><p>设计和实现最为简单，Bean的管理 通过接口方法来描述。MXBean 是一种特殊标准MBean，它使用开放 </p><p>MBean的概念，允许通用管理，同时简化编码 </p><p>• 动态 MBeans </p><p>必须实现指定的接口，不过它在运行时能让管理接口发挥最大弹性 </p><p>• 开放 MBeans </p><p>动态 MBean，提供通用管理所依赖的基本数据类型以及用户友好的自描述信息 </p><p>• 模型 MBeans </p><p>同样也是动态MBean，在运行时能够完全可配置和自描述，为动态的设备资源提供带有默认行为的MBean泛 </p><p>型类</p><p><strong>JMX</strong> <strong>基础</strong> </p><p>• 通知模型（Notification Model） </p><p>通知模型允许MBean 广播管理事件，这种操作称之为通知。管理应用和其他对象注册成 </p><p>监听器 </p><p>• MBean 元数据类（Metadata Class） </p><p>元信息类包含描述所有MBean 管理接口的组件接口，其中包括： </p><p>• 属性（Attribute） </p><p>• 操作（Operation） </p><p>• 通知（Notification） </p><p>• 构造器（Constructor）</p><p><strong>JMX</strong> <strong>基础</strong> </p><p>• 代理级别（Agent Level） </p><p>• MBean 服务器 </p><p>MBean 服务器是一个在代理上的MBean的注册器。它仅用作暴露MBean 的管理接口，而非其引用对象 </p><p>• 代理服务 </p><p>代理服务是在MBean服务器上能够执行已注册MBean的管理操作，其中包括一下代理服 </p><p>务：</p><p>• 动态类加载 </p><p>• 监控 </p><p>• 定时器 </p><p>• 服务关系• 标准 MBeans </p><p>• MBean </p><p>接口的类名称必须以“MBean”为后缀，如MBean 定义为 “XXXMBean”,那么它的实现类名必须是 </p><p>“XXX” </p><p>• MXBean </p><p>• 接口的类名称必须以“MXBean”为后缀 </p><p>• 举例：java.lang.management.MemoryManagerMXBean </p><p>• 接口标记@javax.management.MXBean注解 </p><p><strong>JMX</strong> <strong>基础</strong></p><p>• 动态 MBeans </p><p>• 管理资源实现 javax.management.DynamicMBean接口 </p><p>• 简化API：javax.management.StandardMBean </p><p><strong>JMX</strong> <strong>基础</strong></p><p><strong>JMX</strong> <strong>基础</strong> </p><p>• MBean 元信息类（Meta Data Class） </p><p>• 属性：javax.management.MBeanAttributeInfo </p><p>• 操作：javax.management.MBeanOperationInfo </p><p>• 构造器：javax.management.MBeanConstructorInfo </p><p>• 参数：javax.management.MBeanParameterInfo </p><p>• 通知：javax.management.MBeanNotificationInfo </p><p>• Bean：javax.management.MBeanInfo</p><p><strong>JMX</strong> <strong>基础</strong> </p><p>• 开放 MBeans </p><p>• 基本数据类型</p><p><strong>JMX</strong> <strong>基础</strong> </p><p>• 开放MBean 元信息类（Meta Data Class） </p><p>• 属性：javax.management.openmbean.OpenMBeanAttributeInfo </p><p>• 操作：javax.management.openmbean.OpenMBeanOperationInfo </p><p>• 构造器：javax.management.openmbean.OpenMBeanConstructorInfo </p><p>• 参数：javax.management.openmbean.OpenMBeanParameterInfo </p><p>• 通知：javax.management.openmbean.OpenMBeanNotificationInfo </p><p>• Bean：javax.management.openmbean.OpenMBeanInfo</p><p>• 模型 MBeans </p><p>• 参考规范 - <a href="https://github.com/mercyblitz/jsr/tree/master/JMX">https://github.com/mercyblitz/jsr/tree/master/JMX</a> </p><p>• 代理相关（Agent） </p><p>• MBean 服务器：javax.management.MBeanServer </p><p>• 管理工厂：java.lang.management.ManagementFactory </p><p><strong>JMX</strong> *<em>基础**</em></p><p>*JMX** <strong>工具</strong> </p><p>• JConsole </p><p>• VisualVM </p><p>• JMX Remote API（JSR-160）</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul><li>需求一（必须）<ul><li>整合 <a href="https://jolokia.org/">https://jolokia.org</a><ul><li>实现一个自定义JMX MBean，通过Jolokia做Servlet代理</li></ul></li></ul></li><li>需求二<ul><li>继续完成Microprofile config API中的实现<ul><li>拓展org.eclipse.microprofile.config.spi.ConfigSource实现，包括OS环境变量，以及本地配置文件</li><li>拓展org.eclipse.microprofile.config.spi.Converter实现，提供String类型到简单类型</li></ul></li><li>通过 org.eclipse.microprofile.config.spi.Config读取当前应用名称<ul><li>应用名称 property name = “application.name”</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧目java面试题目20210308</title>
      <link href="2021/03/08/java/%E9%9D%A2%E8%AF%95/%E5%B7%A7%E7%9B%AEjava%E9%9D%A2%E8%AF%95%E9%A2%9820210308/"/>
      <url>2021/03/08/java/%E9%9D%A2%E8%AF%95/%E5%B7%A7%E7%9B%AEjava%E9%9D%A2%E8%AF%95%E9%A2%9820210308/</url>
      
        <content type="html"><![CDATA[<p>参考网址：</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402971648033">廖雪峰java</a></p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><ul><li>hashmap1.7跟1.8？优化点？红黑树化为什么是8？退化为什么？</li><li>dp怎么玩？回溯怎么玩？递归怎么玩？stack能解决啥问题？fifo能解决啥问题？dfs怎么玩？bfs怎么玩？</li><li>双亲委派模型。JDBC和双亲委派模型关系</li><li>TCP四次挥手，TIME_WAIT发生在哪一方 TIME_WAIT过多如何处理</li><li>HashMap底层结构 put操作讲一下,HashMap、HashMap如何保证线程安全、ConcurrentHashMap</li><li>从ConcurrentHashMap一路问到锁&amp;锁优化-&gt;LongAdder-&gt;伪共享-&gt;缓存行填充-&gt;cas等诸多技术细节；</li><li>观察者模式与中介者模式有什么区别？</li><li>手写一个基于懒汉式的双重检测的单例。</li><li>HashMap相关?为什么要引入红黑树？ 如何在红黑树中插入一个节点。 链表是如何转换为红黑树的？</li><li>对ConcurrentHashMap的理解，⽐如在什么地⽅会涉及到线程安全问题以及ConcurrentHashMap是如何解决的？</li><li>Http请求的完全过程</li><li>HashMap扩容的触发条件是什么</li><li>HashMap的实现原理，什么是hash碰撞，怎样解决hash碰撞？</li><li>mysql的sql本身没问题的情况下，没走索引原因</li><li>mysql快照是怎么实现的</li><li>mysql分页有什么优化</li><li>讲一下Http，HTTP安全不？HTTPS如何解决的？HTTP的数字证书如何认证？TCP与UDP区别？TCP为什么要四次？ 为什么TIME_WAIT 等待的时间是 2MSL？已经主动关闭连接了为什么还要保持资源一段时间呢？ TIME_WAIT 过多有什么危害？如果已经建⽴了连接，但是客户端突然出现故障了怎么办？保活机制说一下？</li><li>说一下undolog， redolog MySQL如何保证redo log和binlog的数据是一致的，如果一个sql执行很慢，你能分析一下原因吗？ 为什么数据库会选错了索引</li><li>对乐观锁和悲观锁的理解；</li><li>hashMap什么情况下会出现循环链表？concurrentHashMap写的时候用什么锁？</li><li>定义Integer x=20 Integer y=200 在内存里是个什么过程？ volite关键字的原理？它能保证原子性吗？AtomicInteger底层怎么实现的？</li><li>threadLocal关键字有用过吗？如果没有重写initialValue方法就直接get会怎样？</li><li>1.java的基本数据类型与包装类； 2、final修饰变量类方法； 3、String为什么是不可变的，以及new String(“abc”)创建了几个对象； 4、String、StringBuffer、以及StringBuilder的区别； 5、static修饰变量，方法，代码块； 6、重写跟重载的区别； 7、接口跟抽象类； 8、反射、继承、枚举、异常等知识点； 9、为什么要重写hashcode和equals方法，以及hashcode相同equals是否相同</li><li>集合相关 1、ArrayList的底层实现、扩容过程、add过程、Fail-Fast机制； 2、ArrayList与Linkedlist、Vectot的区别； 3、如何获得一个线程安全的List； 4、CopyOnWriteArrayList是如何实现线程安全的； 5、Linkedlist的底层实现，以及如何使用LinkedList实现一个LRU； 6、TreeSet、HashSet、LinkedHashSet的底层实现以及之间的区别； 7、PriorityQueue、LinkedBlockingQueue、ArrayBlockingQueue的实现以及区别； 8、HashMap的底层实现，扩容过程，达到阈值一定会扩容吗、put过程、树化过程，如何确定负载因子、以及为什么线程不安全和1.8做了哪些优化； 9、HashMap与HashTable的区别，如何获得一个线程安全的Map； 10、ConcurrentHashMap为什么是线程安全的，以及1.8做了哪些优化； 11、LinkedHashMap的底层实现，以及如何实现LRU； 12、TreeMap的底层实现； 13、迭代器的实现；</li><li><ol><li>面向对象的特点有哪些？ 2. 列举几个java常用的package及其作用 3. 接口和抽象类有什么联系和区别 4. 重载和重写有什么区别 5. java有哪些基本数据类型？ 6. Java支持的数据类型有哪些？什么是自动拆装箱？ 7. int 和 Integer 有什么区别 8. 数组有没有length()方法？String有没有length()方法？ 9. Java中符号&gt;&gt;和&gt;&gt;&gt;有什么区别？ 10. Java类的实例化顺序 11. 什么是值传递和引用传递 （1）值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. （2）引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 12. String能被继承吗？为什么？ 13. String和StringBuilder、StringBuffer的区别？</li></ol></li><li>深拷贝和浅拷贝。</li><li>Integer a1 = new Integer(2); Integer a2 = new Integer(2); a1.equals(a2)的结果？？</li><li>为什么在重写equals方法的时候要重写hashcode的方法？</li><li>HTTP 1.0 和 HTTP 2.0 的区别 HTTP 2.0 做了哪些优化</li><li>JDK中偏向锁、自旋锁、轻量级锁、重量级锁的区别？ JDK锁自旋的自旋阈值了解吗？如何调整自旋次数？</li><li>如果相等hash对象太多，那么怎么解决迭代的影响？</li><li>服务器CPU数量及线程池数量的关系？</li><li>一亿条记录，内存中肯定放不下，要怎么找出其中最大的十条？</li><li>为什么要用读写锁而不用synchronized这种同步锁？</li><li>事务隔离性的理解，为什么会有脏读，可重复读，提交读等。</li><li>了解哪些设计模式，6个设计原则分别是什么？每种设计原则体现的设计模式是哪个？</li><li>如何实现session共享？用Redis该如何实现？</li><li>常见的stackoverflowexception,outofmemoryexception是怎么回事；</li><li>top和jstack命令用过没，jstack命令的nid是什么意思，怎么查看java某个进程的线程？</li><li>ABA怎么发生的，怎么解决ABA问题</li><li>Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？</li><li>什么是死锁？ 2.死锁产生的条件？ 3.怎样避免死锁？</li><li>TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么 .TIME_WAIT和CLOSE_WAIT的区别 .说说你知道的几种HTTP响应码</li></ul><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>链表，常见的面试题有写一个链表中删除一个节点的算法、单链表倒转、两个链表找相交的部分，这个一般必须得完全无误的情况下写出来；</li><li>给出两个链表的头结点，找出这两个链表的交点。</li><li>java 中数组和链表的区别，各自优势 如何设计拥有高效的随机读取能力的的链表（跳表） 设计跳表，跳表插入开销，跳表随机读取过程</li><li>给你一个单向链表，给这个链表做K反转，例如 k=3 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 反转后为： 3 -&gt; 2 -&gt; 1 -&gt; 6 -&gt; 5 -&gt; 4 链表长度保证为K的倍数</li><li>给定一个链表，返回链表开始入环的第一个节点</li><li>n个降序的链表返回前K个大的节点构成的链表</li><li>链表合并：给出n个有序的链表，将他们合并为一个有序链表。</li><li>有k个有序单链表，怎么合并成一个有序单链表？</li><li>链表逆序，不能用修改指针的方法，用递归如何实现。</li><li>反转单链表</li><li>知道双向链表怎么翻转吗</li><li>有两个数字非常大已经超出了long型的范围，现在以链表的方式存储其中链表头表示最高位，例如1-&gt;2-&gt;3-&gt;4表示1234，请设计一个算法求出两数之和；</li><li>反转数字，不能把数字变成字符串</li><li>链表找环的入口</li><li>单链表的逆序</li><li>两个链表合并，最长公共子串问题</li><li>单链表逆序，快排，数组中找两个数和等于目标值</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>在M个大小的数组中找到第K大的数（最大堆）</li><li>我现在有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，•[2,1,4,3]。。。。你这个算法的时间复杂度是多少</li><li>数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数 •先说下你的思路 •下一个奇数？怎么找？ •有思路么？ •你这样时间复杂度有点高，如果要求O(N)要怎么做</li><li>手写算法，两个有序数组的合并。</li><li>十万行二维数组，每行长度为10，每个数组降序，找出最大的15个数。先跟面试官说了思路，然后又在白纸上写了出来</li><li>对一个数组进行绝对值排序的算法；</li><li>非降序数组，打印某个值最后出现的位置</li><li>找出数组中超过半数的那个数字（摩尔投票）</li><li>一个数组反转，o(logn)复杂度用什么排序算法；</li><li>一个 100长度数组, 里面是 固定的随机数, 要求列出重复的数字的最优算法.；</li><li>给定两个数组，每个数组中都有重复的数字。不用类库函数，对这两个数组排序。</li><li>给定一个数组，求该数组所有的自子数组 去掉一个字符串中的所有空格</li><li>给定一个数组，元素的大小0~25，有重复元素。按出现频次的高低输出所有的数字</li><li>给定一个乱序数组，求数组内最大连续的数；</li><li>无序数组找第k大的数</li><li>给一个数组，和k，求数组中的哪两个数之和为k，除了双层for循环和字典的方式还能用什么方式实现；</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>写二分查找算法</li><li>有主字符串A，子字符串B，在A中查找B</li><li>手撕一个有序数组的二分查找算法</li><li>请说出二分查找的实现思路及时空复杂度。</li><li>用二分法查找一个长度为18的，排好的线性表，当查找不成功时，最多需要比较多少次</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>快排怎么实现的，快速排序（包括算法步骤、平均算法复杂度、最好和最坏的情形）</li><li>5亿整数的大文件，怎么排？</li><li>两个1G排好序的文件，按序合并</li><li>手写归并排序。 两个有序数组合并。</li><li>常见的排序算法有哪些？各种排序算法的平均时间复杂度和最坏情况下的时间复杂度？</li><li>写出你熟悉的排序算法，并说明其优缺点</li><li>给了长度为N的有重复元素的数组，要求输出第10大的数。</li><li>手写一下快速排序吧，我看你参加过ACM，所以用非递归实现一下。</li><li>快排听过吗？他是怎么实现的？</li><li>如果是单链表的快速排序，你怎么做？</li><li>快排时间空间复杂度，最好最坏的情况，优化方案？</li><li>手写了冒泡排序</li><li>手写递归排序等</li><li>两个排序好的数组，构思算法把一个按序插入另一个数组</li><li>手工实现一个快速排序算法</li><li>列举数据的几个排序算法</li><li>快速排序？快速排序是稳定的么？ 如何实现一个快速排序的稳定性？</li><li>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</li><li>快排会吗？知道原理吗？</li><li>排序算法，介绍一下快速排序，快速排序时间复杂度，是不是稳定排序，介绍几种你所知道的稳定排序算法</li><li>10亿个数选最大的K个，用什么方法，复杂度多少</li><li>说一下冒泡排序的原理</li><li>请对3个有序数组进行归并排序</li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>AVL树和B树的概念、细节，比如会问mysql数据库的索引的实现原理，基本上就等于问你B树了。</li><li>红黑树，这个基本上必问的一个数据结构，包括红黑树的概念、平均算法复杂度、最好最坏情况下的算法复杂度、左右旋转、颜色变换。</li><li>找出二叉树中任意两个节点的最低公共根节点, 如果树是BST呢. 深度优先搜索+二分查找树性质</li><li>B+树如何分裂？</li><li>二叉树前中后遍历 二叉树层次遍历 二叉树深度优先遍历(递归、非递归) 二叉树广度优先遍历(递归、非递归) 和为n的二叉树路径 二叉树深度 二叉树是否对称 链表反转</li><li>红黑树有啥特性?</li><li>二叉树层序遍历输出，每一层输出数组（手写算法）。</li><li>JDK1.8采用的红黑树特性，以及采用红黑树的理由而不采用AVL和B树的原因？</li><li>一个二叉搜索树，找出某两个节点的公共祖先。</li><li>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 例如，输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li><li>平衡二叉树的基本概念 简单介绍一下b+树</li><li>多叉树的生成 给定一个数组【[a,b]、[c,b]、[e,a]、[h,a]、[k,h]】，数组前一个代表子节点、后一个代表父节点，生成一颗多叉树，返回根节点</li><li>按照Z字形分层遍历二叉树，要求bug free，并且构造二叉树进行测试</li><li>二叉树的右视图。</li><li>写一个二叉树的深度遍历</li><li>二叉树翻转</li><li>二叉树的s型遍历，层序遍历的变种，简单，不过要写测试用例，等于还要写一个数组转二叉树的函数</li><li>一颗非平衡二叉树，如何最快的方式找到距离最远的两个叶子节点。</li><li>给一个二叉树和一个目标值，找到和等于这个值的所有路径</li><li>B和B+树，B+树的搜索次数、为什么不用二叉树。</li><li>红黑树最差旋转几次</li><li>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。 最近公共祖先是两个节点的公共的祖先节点且具有最大深度。 假设给出的两个节点都在树中存在。</li><li>层次遍历二叉树，返回一个二维数组，每行表示一层</li><li>不用迭代方法计算树的高度；</li><li>假设一棵二叉树的后序遍历序列为DFGGEBHICA,中序遍历序列为：DBFEGAHCI,则前序遍历序列为？</li><li>多叉树的第n层 层次遍历 2.递归太深会怎样？答栈溢出。为什么会栈溢出？python函数中的临时变量存在哪？那很深的时候，用循环会怎样呢？为什么不会栈溢出？</li><li>给定一个二叉树，依次打印出每一行</li><li>前序遍历 中序遍历 后序遍历 知道那些可以恢复二叉树，只知道前序和后序可以吗？</li><li>有N个节点的满二叉树的高度</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>哈希表，对哈希表的细节要求很高，比如哈希表的冲突检测、哈希函数常用实现、算法复杂度；比如百度二面就让我写一个哈希表插入元素算法，元素类型是任意类型。</li><li>找出两个有序数组中的重复项，分析时间和空间复杂度，然后就是不断优化优化优化。。 要是数组长度非常大会出现什么情况？</li><li>俩线程分别持续打印奇数和偶数，实现俩线程的交替打印（从小到大）</li><li>给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: s = “3[a]2[bc]”, 返回 “aaabcbc”. s = “3[a2[c]]”, 返回 “accaccacc”. s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.</li><li>leetcode213 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 输入: [1,2,3,1] 输出: 4 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。</li><li>有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒</li><li>看你简历提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？</li><li>根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</li><li>一个二维数组，每一列的数字从左往右增大，每一行从上往下增大，求一个指定的数字在这个数组中的位置</li><li>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li><li>股票买卖的一道题 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li><li>给你一个 n * m 的二维整数数组，数字都是大于等于0，现在要你对数组做一种操作，对于所有0，将0所在的行和列全部变为0。要求使用尽量少的空间和时间。</li><li>给你一个整数数组，数组中的元素定义一种距离 d[i] 为将数组排序后，该元素移动的距离，现在给你一个K数组，即数组中所有元素的距离d &lt;= k，对这个K数组排序，希望尽量小的时间复杂度。</li><li>输入一个不含相同整数的整数集合，输出所有子集 输入：[1,2,3] 输出：[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]] 有三十瓶水，十个桶，每个桶能放0-10瓶水，有多少种方案</li><li>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = “abcdefg”, k = 2 输出: “bacdfeg” 要求: （1）该字符串只包含小写的英文字母。 （ 2）给定字符串的长度和 k 在 [1, 10000]范围内。</li><li>翻转字符串，反转句子等。</li><li>判断一串字符串里括号的最大有效长度。用动态规划实现</li><li>给一个字符串，找出连续相同的字符，如果有两个以上相同的，取ASCII码小的。</li><li>给一个字符串，删除最大连续相同的字符串并返回</li><li>有一组未排序的整形数组，你设计一个算法，对数组的元素两两配对，然后输出最大的绝对值差和最小的绝对值差的”对数”</li><li>m*n二维数组整体有序，查找value</li><li>返回一个数字数组的排序值，比如数据[6,2,5,0]的返回是[4,2,3,1]；</li><li>一个正数数组，长度为N，且数组元素&lt;N，统计每个正数出现的次数，要求时间复杂度O(n)，空间复杂度O(1)；</li><li>实现一个fibonacci函数，输入数字n，输出fibonacci数列的第n项数字，并给该函数加入缓存功能。</li><li>100G文本找某个单词出现的频率</li><li>是否连接红黑树 •</li><li>是否了解数据结构的“堆”</li><li>斐波拉契数列非递归实现</li><li>算法n的阶乘末尾0的个数</li><li>我一个文件,有45亿个阿拉伯数字,如何进行去重啊?如何找出最大的那个数啊?</li><li>写一个fibnaccio的相关例子</li><li>输入两个字符串str1 str2和整数n，要求两个数以n进制相加，然后输出字符串str3</li><li>就是二位数组如何进行螺旋输出 然后第二道的算法题是如何从25匹马中通过赛马的形式找到最快的3匹，每次最多只能5匹马参赛，问最少需要赛几次？答案是7次，我思路对了，不过我把次数给弄错了，多了2次没必要的比赛。</li><li>6个元素1.2.3.4.5.6的顺序进栈，请问下列哪个不是合法的出栈序列？ a:345261 b:436521 c:245316 d:124653 e:543612</li><li>图的最短路径问题</li><li>算法题（爬楼梯，问一个人爬楼梯，每次只能爬一个台阶或两个台阶，问有N个台阶，总共能有多少种爬法）；</li><li>实现一个random(m,n)方法，返回m到n的随机数</li><li>64只球队找到最强的，找前二强的，前k强的</li><li>就是m*n的矩形从左上面到右下面的路径有多少条</li><li>求N内的所有素数</li><li>判断字符串是否是一个数字</li><li>当一个文本文件中有200万行数据，如何在在每一行的尾部追加一个字符；</li><li>求一个字符串中最长不重复子串的长度</li><li>三个有符号的整型（long）数a, b, c，怎么判断a+b &gt; c?实现并且设计测试用例（在main函数中调用，打印结果） （考虑同号越界问题）</li><li>给一个字符串和一个k，要求找到不超过k个不同字符的最长子串的长度</li><li>10进制转16进制（紧张了，有点费时间，啧啧啧）</li><li>f(0)=0;f(1)=1; f(n)=f(n-1)+f(n-2) 求f（n）</li><li>有主字符串A，子字符串B，在A中查找B</li></ul><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="多线程类的使用"><a href="#多线程类的使用" class="headerlink" title="多线程类的使用"></a>多线程类的使用</h2><ul><li>java线程同步有哪些方法、各自的优缺点</li><li>synchronized 和ReentrantLock区别，可重入锁是什么？</li><li>threadlocal有什么用</li><li>Java中创建线程有几种方式？分别是？ 当主线程执行结束后，子线程还会继续执行下去吗？</li><li>JUC中有哪些常用的集合？（项目中用到的）</li><li>CopyOnWriteArrayList的实现原理？主要应用什么场景下？优缺点分别是？</li><li>HashMap不是线程安全的，在高并发环境中做插入会出现什么情况？为什么？</li><li>jdk1.8以前ConcurrentHashMap是如何实现线程安全的？jdk1.8以后呢？（1.8synchronized加CAS，并引入了红黑树）</li><li>当调用ConcurrentHashMap的size方法时，有元素并发插入，ConcurrentHashMap是怎么处理的？</li><li>synchronized和java.util.concurrent.locks.Lock的比较。 AtomicInteger原理，为什么要用CAS而不是synchronized？ 银行的后端如果出现多人想一个账户大钱的情况，会碰到什么问题？</li><li>什么是CAS操作，如何实现一个自定义锁</li><li>Synchronized的实现，锁的升级过程。</li><li>AQS锁了解么？</li><li>wait()、notify必须在什么情况下使用</li><li>线程、进程、协程的关系。</li><li>对volatile的理解</li><li>详细的说一下concurrentHashMap put流程</li><li>你是如何理解同步/异步，并发/并行的概念的</li><li>那谈谈Lock接口的API以及其实现类相关的了解？</li><li>那么ReentrantLock中的lock和unlock之间的同步如何进行线程间的通信？</li><li>Semaphore类的了解？</li><li>JUC包下的计数锁？CountDownLatch？</li><li>CyclicBarrier的理解？</li><li>ReadWriteLock与ReentrantReadWriteLock的理解和区别？</li><li>你还了解ReentrantReadWriteLock哪些特性？</li><li>ReentrantLock如何实现公平和非公平锁是如何实现？ CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？</li><li>乐观锁和悲观锁的区别？ 如何实现一个乐观锁？</li><li>AQS是如何唤醒下一个线程的？</li><li>ConcurrentHashMap是如何让多线程同时参与扩容？get需要加锁么，为什么？</li><li>Disruptor框架的用法，实现</li><li>Future的异步调用过程是咋样的？Future超时的情况？无限递归会造成jvm内存的什么问题？</li><li>Java8之后的ConcurrentHashMap为什么舍弃分段锁？</li><li>线程池一整套（实现类及对应的阻塞队列、拒绝策略、具体参数、ScheduledThreadPool有三种构造方法，分别代表什么含义？）</li><li>synchronized分别修饰在实例方法上和静态方法上，多线程并发时是否会竞争锁？synchronized修饰在方法上和代码块上有什么区别，底层是怎么实现的？</li><li>并发编程中的生产者消费者模式代码。［最简单的方式就是使用wait和notify去阻塞唤醒，当然还可以使用可重入锁(ReentrantLock)，使用锁计数器(CountdownLatch)等等］</li><li>为什么要用读写锁而不用synchronized这种同步锁</li><li>如何实现控制线程在某段时间内完成，不完成就撤销。</li><li>参照ConcurrentHashMap，如果在多线程场景下使用HashMap，有什么手段提高效率又保证线程安全吗？</li><li>对Java内存模型的理解，以及其在并发中的应用；指令重排序，内存栅栏等</li><li>Java 有什么锁类型？</li><li>并发容器有哪些,并发容器和同步容器的区别？</li><li>CLH同步队列是怎么实现非公平和公平的？</li><li>HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。</li><li>Lock接口有哪些实现类，使用场景是什么。</li><li>可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment）</li><li>CountDown有了解过吗？CountDown和CycliBarrier的区别是是什么？在使用上有啥区别？</li><li>volatile从指令重排序，内存屏障，聊到总线风暴</li><li>问了父子线程怎么共享数据</li><li>List是非线程安全的，你如何把他变成线程安全的？</li><li>synchronized可否在运行当前线程时运行其它线程</li><li>什么叫守护线程，用什么方法实现守护线程？如何停止一个线程？</li><li>并发编程问的很细。多个线程达到同一个状态然后再一起执行，达到某一个状态之后再继续并发执行，这种怎么实现？</li><li>如何实现控制线程在某段时间内完成，不完成就撤销</li><li>读写锁中加读锁后如何避免写线程饿死</li><li>线程池的一些原理，锁的机制升降级</li><li>问自旋锁实现的方式是什么 问指针指向的地址是虚拟地址还是物理地址。 问页表置换的算法有哪些，以及现如今哪种算法比较高效。 问缺页异常置换的过程。 如果一个线程修改一个数据，但这时候需要把当前页表置换出去，操作系统如何处理。</li><li>进程与线程的区别，怎么根据硬件确定你最大创建的线程数（线程池需要考虑）</li><li>JDK锁自旋的自旋阈值了解吗？如何调整自旋次数？</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>线程池 什么时候到达最大线程数 到达最大线程后继续提交的表现 用过哪些锁</li><li>线程池有哪些核心参数？简单描述下线程池的原理？</li><li>创建线程池的方式？</li><li>线程池线程的提交方式和优缺点。</li><li>如果我们在线程池中使用无界队列会造成什么影响呢？</li><li>多个核心线程去take阻塞队列中线程，谁能拿到了？</li><li>线程池怎么实现复用线程的</li><li>JDK中偏向锁、自旋锁、轻量级锁、重量级锁的区别？ JDK锁自旋的自旋阈值了解吗？如何调整自旋次数？</li><li>你们系统中下单的时候为什么要用线程池？可以用其他的实现方案吗？</li></ul><h2 id="多线程的扩展"><a href="#多线程的扩展" class="headerlink" title="多线程的扩展"></a>多线程的扩展</h2><ul><li>分布式锁zookeeper的使用场景—— 实现分布式锁的方式———-redis分布式锁和zookeeper分布式锁</li><li>你会如何处理高并发场景，例如商城秒杀？</li><li>数据库的并发策略</li><li>高并发时如何限流</li><li>场景模拟:假设有一个场景，系统需要某个特定时间内响应用户请求，比如说100ms内完成用户请求，但是在最高峰的时候每单位时间几百万的用户请求，也就是高并发，但我必须要实现系统响应及时，而且高可用，假如你是架构师，你该如何架构这个系统，聊聊你的方案。</li><li>线程编程题： 写两个线程，一个往数组加数据，一个往数组减数据，要求数据不会越界。其实就是生产消费者</li><li>秒杀系统如何设计？</li><li>如果处理并发时候出现死锁？</li></ul><h1 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h1><h2 id="字节码相关"><a href="#字节码相关" class="headerlink" title="字节码相关"></a>字节码相关</h2><ul><li>知道字节码吗?字节码都有哪些?</li></ul><h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><ul><li>说说JVM的主要组成部分以及作用?</li><li>jvm内存模型，内存屏障</li><li>对象一定分配在堆栈对象不一定分配在堆上，JIT可以实现栈上分配</li><li>java线程模型和jvm线程模型区分</li><li>Java堆的内存结构？ 在什么地方会发生OOM？ 如何分析OOM发生的原因？ 让你自己实现OOM，你会怎么做？</li><li>什么东西分配在堆上和栈上？</li><li>一个对象从创建到销毁都是怎么在这些部分里存活和转移的？</li><li>JVM 运行时区域 常见的堆内存溢出情况</li><li>栈溢出的情形（递归，调节-Xss</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>什么是双亲委派模型？</li><li>类加载器的本质</li><li>类加载器为什么有三层结构</li><li>怎么自定义类加载器做容器隔离？</li><li>讲讲类加载机制呗?都有哪些类加载器,这些类加载器都加载哪些文件?</li><li>手写一下类加载Demo</li><li>Classloader作用</li><li>讲一讲类加载器工作机制？你知道强引用、弱引用和软引用吗?为什么要有这些东西？他们有什么作用？你在项目中用过吗？</li><li>说一下java类加载器的工作机制？类加载在那个区域进行的？</li><li>你自己定义的类能被最顶级的类加载器加载吗？为什么？ 自定义的类会被什么类加载器加载？ 如何加载一个不在根目录下的类？</li><li>什么是双亲委派模型？为什么Java的类加载器要使用双亲委派模型？ 15、如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？</li><li>什么是tomcat/jboss类加载机制？</li><li>类加载机制，一个类加载到虚拟机中一共有几个步骤，这些步骤的顺序哪些是固定的，哪些是不固定的，为什么不固定？</li><li>说一下双亲委派模型？如何破坏双亲委派模型？知道Tomcat中是如何违背双亲委派模型的吗？</li><li>Java为什么要设计双亲委派模型？ •什么时候需要自定义类加载器？</li></ul><h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><ul><li>简单阐述下垃圾回收机制</li><li>堆的原理和分代了解吗</li><li>GC方式有哪些？它们的原理是什么？</li><li>CMS和G1各自使用的算法以及优缺点</li><li>内存分配策略（如何在Eden和老年代中分配）、回收策略（Minor GC、Full GC）</li><li>谈谈你对上面GC中回收对象中提出的对象有什么理解？回收那些对象，需要怎么分辨？</li><li>你了解的垃圾收集算法有哪些？</li><li>你了解那些垃圾收集器？</li><li>线上发送频繁fullgc如何处理?</li><li>新生代，老年代说下？</li><li>一般新生代逃过几次gc()会被划分到老年代？</li><li>survivor区作用</li><li>jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等</li><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS</li><li>新生代垃圾收集是否会停顿 ,cms是否会停顿，在什么时候停顿</li><li>讲讲 GC，清除，整理，交换（survivor 区域），CMS 执行的过程</li><li>什么情况会导致内存泄露，内存溢出，你怎么解决的。</li><li>gc怎么回收对象的，用了什么算法 说一下分治算法思想</li><li>JVM垃圾回收机制，何时触发MinorGC等</li><li>新生代和老生代的内存回收策略 ,Eden和Survivor的比例分配等</li><li>Java 8的内存分代改进</li><li>GC的可达性分析中那些算是GC roots</li><li>简述java内存分配与回收策略以及Minor GC和Major GC?</li><li>内存溢出一般发生在哪个区？永久代会不会导致内存溢出？</li><li>栈溢出一般抛出什么异常？jvm设置栈的大小，参数？</li><li>说说GC的过程 强制young gc会有什么问题？ 知道G1么？ 回收过程是怎么样的？</li><li>CMS GC有什么问题？ 怎么避免产生浮动垃圾？</li><li>如果web服务器突然出现频率很高的FullGC，可能是什么原因?你会怎么去排查呢？</li><li>“只对堆进行gc ”这句话对不对？调用system.gc()马上就执行gc吗？</li><li>GC的机制是什么？垃圾回收器的基本原理是还说呢么？是否可以立即回收内存？怎么样主动的通知JVM进行垃圾回收？</li><li>频繁老年代回收怎么分析和解决？</li><li>什么时候一个对象会被GC？ 接着问为什么要在这种时候对象才会被GC？ GC策略都有哪些分类？这些策略分别都有什么优劣势？都适用于什么场景？ 举个实际的场景，让选择一个GC策略？然后问什么要选择这个策略？</li><li>内存的哪些部分会参与GC的回收？</li><li>线程池中的线程为什么不会被GC回收</li><li>JVM 简述 G1，可预测停顿时间，是怎么做到的？</li><li>CMS和G1的区别，讲一讲CMS垃圾收集的步骤，哪些步骤是并发哪些是并行。知道哪些垃圾收集算法</li><li>触发Full GC 的场景有哪些？ 说说G1垃圾回收器？老年代，年轻代如何分配？</li><li>垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数 内存区域：能说清jvm的内存划分 常见问题 CMS GC回收分为哪几个阶段？分别做了什么事情？ CMS有哪些重要参数？ Concurrent Model Failure和ParNew promotion failed什么情况下会发生？ CMS的优缺点？ 有做过哪些GC调优？ 为什么要划分成年轻代和老年代？ 年轻代为什么被划分成eden、survivor区域？ 年轻代为什么采用的是复制算法？ 老年代为什么采用的是标记清除、标记整理算法 什么情况下使用堆外内存？要注意些什么？ 堆外内存如何被回收？</li><li>g1收集器用的具体算法？ 遇到过什么线上问题？线程池用法不对，频繁full GC怎么处理的？回答内存dump，定位问题</li><li>GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势</li><li>标记清除和标记整理算法的理解以及优缺点。</li><li>eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。</li><li>JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。</li><li>强软弱虚引用的区别以及GC对他们执行怎样的操作</li><li>Java是否可以GC直接内存</li><li>JVM 内存分配策略 FullGC 的触发条件有哪些</li><li>虚拟机栈默认设置的大小</li><li>CMS有哪些重要参数？ Concurrent Model Failure和ParNew promotion failed什么情况下会发生？</li><li>一个对象从新生代到老年代的过程你可以说一下吗？ 那你知道它经过几轮回收到达老年代吗？也就是它的年龄。 新生代三个区域比例是多少</li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><ul><li>请问你做过哪些JVM优化?使用什么方法?达到什么效果?</li><li>当出现了内存溢出，你怎么排错?</li><li>用过哪些命令查看JVM的状态、堆栈信息？</li><li>jvm内存调优用过哪些工具，jstate做什么用的？如何dump出当前线程状态？</li><li>应用服务器的jvm调优实际经验，如何做的，在哪里用到的</li><li>对象比较大，生命周期短，GC参数怎么调优</li><li>平时遇到内存溢出的情形，处理 答：-Xms和-Xmx,-XX:+HeapDumpOnOutMemoryError，让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。</li><li>如果一个固定的堆内存，当创建线程数很多的时候，你JVM参数怎么配置。</li><li>gc,cpu过高如何定位问题；</li><li>频繁老年代回收怎么分析和解决？</li><li>top和jstack命令用过没，jstack命令的nid是什么意思，怎么查看java某个进程的线程</li></ul><h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><ul><li>mysql索引的数据结构，加索引的原则</li><li>InnoDB和myiasm的区别，以及常见的mysql优化方案</li><li>sql查询优化</li><li>说说Mysql的sql优化</li><li>mysql的索引，b+树索引是否支持范围查询，联合索引的失效情况</li><li>开发中用了那些数据库？回答mysql，储存引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。</li><li>数据库索引原理</li><li>mysql索引 B+树原理</li><li>mysql索引是怎么实现的？b+树有哪些特点？真实的数据存在哪里？ 哪些情况下建索引？解释下最左匹配原则？ 现在一个表有三列a b c，组合索引(a,b,c)查询的时候where a like ? and b=? and c=?能用到这个组合索引吗？为什么</li><li>explain执行计划看过没有？其中type字段都有哪些值？分别代表什么？ 26.你有哪些sql调优经验？</li><li>分库分表应该怎么分？怎么解决数据迁移的问题？</li><li>数据库索引，多级索引</li><li>数据库事务的隔离级别有哪些？Mysql默认的隔离级别？不同的隔离级别是通过什么实现的？mysql的explain有用过吗？讲一讲数据库的慢查询？数据库的悲观和乐观锁都说一下吧，什么时候用乐观锁比较合适？什么时候用悲观锁呢？</li><li>谈一下MySQL常见的两种存储引擎，适用场景——MyISAM和InnoDB的对比</li><li>谈谈你对数据库索引的理解</li><li>如何保证缓存和数据库双写的一致性</li><li>mysql数据库默认存储引擎，有什么优点 MySQL的事务隔离级别，分别解决什么问题。 说说事务特性（ACID）？</li><li>MySQL有哪些锁？ 解释一下ACID都是什么 Innodb中索引的实现 B+树</li><li>AUTO_INCREMENT原理（考察并发情况） 数据库的索引有哪几种？为什么要用B+树来做索引？组合索引和几个单个的索引有什么区别？数据库的大表查询优化了解吗？MVCC机制了解不？MVCC机制有什么问题？怎么去解决这个问题？mysql慢语句调优做过吗？说说你是怎么做的</li><li>说一下数据库优化思路？</li><li>你知道回表吗？</li><li>索引的实现原理？B树和B+树的区别？</li><li>说下索引结构，为什么使用B+树？</li><li>mysql的隔离级别，有什么区别？ 索引的几种类型？ 索引的存储结构？ 使用B+树的好处？ 索引值改变了，树的结构如何改变？</li><li>主键索引与二级索引的区别 主键索引存储什么数据 为什么主键用auto_increment 如何生成唯一主键 A:UUID UUID的缺点 mysql如何实现事务中持久性</li><li>Mysql 事务隔离级别、锁、索引的数据结构、聚簇索引和非聚簇索引、最左匹配原则、查询优化（explain等命令） 常见问题 Mysql(innondb 下同) 有哪几种事务隔离级别？ 不同事务隔离级别分别会加哪些锁？ mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？ 说说什么是最左匹配？ 如何优化慢查询？ mysql索引为什么用的是b+ tree而不是b tree、红黑树 分库分表如何选择分表键 分库分表的情况下，查询时一般是如何做排序的？</li><li>数据库调优思路的思路。</li><li>说说你都做过哪些优化或者优化的思路？ 数据库的索引了解吗？说一下索引的原理？聚集索引和非聚集索引了解吗？了解mysql的回表吗？ mysql实现分布式锁了解吗？还有没有其他更好的方式？ 说一下事务的一些东西？你对事务的了解有哪些？说说数据库的乐观锁和悲观锁？</li><li>数据库事务？数据库的并发策略？</li><li>介绍下mysql的回表和覆盖索引？ 回表简单来说就是数据库根据索引（非主键）找到了指定记录所在行后，还需要根据主键再次到数据库里获取数据。 如果一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’。即只需扫描索引而无须回表。</li><li>mysql索引了解吗，为什么用索引；有哪些索引；如果没有主键的话会怎么样；聚簇索引和非聚簇索引的区别；myisam和innodb哪个会保存表的总记录数，为什么；为什么用联合索引；bc会走abc联合索引吗； mysql锁有哪些，意向锁的原理； mysql隔离级别，分别解决了哪些问题，脏读、不可重复读、幻读是什么意思，可重复读是怎么实现的； mysql主从节点怎么保证数据的一致性；</li><li>聚簇索引和非局促索引的区别。 mysql的存储引擎。 innodb和myisam的区别 为什么myisam支持事务 ,innodb是如何支持的事务 ,为什么myisam不采用和innodb相同的方案来解决事务问题 ,为什么数据量大的时候会出现慢sql？ 慢sql如何解决。 如何sql优化。 分库分表如何做的？ 分库分表如何不同库表间数据不重复。</li><li>MySQL作为相对于雪花算法全局唯一性id的缺点除了性能问题，还有什么？</li><li>mysql两种存储引擎的区别 2.如果由大量的增删操作，那么应该选择哪个存储引擎，为什么？</li><li>hash和B+树的区别？分别应用于什么场景？哪个比较好？</li><li>为什么MyISAM查询性能好？ 说说事务特性（ACID）？ mysql数据库默认存储引擎，有什么优点 MySQL的事务隔离级别，分别解决什么问题。 SQL慢查询的常见优化步骤是什么？ 说下乐观锁，悲观锁（select for update），并写出sql实现？</li><li>MySQL的慢sql优化一般如何来做？除此外还有什么方法优化？</li><li>mysql的explain有用过吗？讲一讲数据库的慢查询？数据库的悲观和乐观锁都说一下吧，什么时候用乐观锁比较合适，什么时候用悲观锁比较合适？</li><li>数据库事务的隔离级别有哪些？Mysql默认的隔离级别？不同的隔离级别是通过什么实现的？</li><li>mysql,innodb引擎，b+树存储结构，索引，事务原理，分库分表，弹性库自动扩容原理</li><li>Sql调优经验</li><li>mysql为什么是b+树索引。b+高度一般多少，什么量级。</li><li>mysql幻读不可重复读区别</li><li>为什么InnoDB用的多？ 数据库锁知道吗，有几种，加锁和解锁的场景，给一句SQL和隔离级别，能分析加什么锁吗？索引下推原理</li><li>一条sql语句被提交后，mysql是怎么执行这条sql的？</li><li>两个数据库表复制数据库有什么方式？</li><li>mysql索引、从主原理</li><li>联合索引，若(a,b,c)是主键，根据b,c查询会不会用到索引，怎么知道？做索引需要有哪些条件？</li><li>平时建mysql表的时候会考虑一些什么？ 13、写sql语句的时候where会考虑什么？</li><li>数据库方面有mysql的innodb引擎锁的底层实现、以及回表、怎么避免索引覆盖</li><li>如何定位一个慢查询，一个服务有多条SQL你怎么快速定位？ 聚集索引和非聚集索引知道吗？什么情况用聚集索引什么情况用非聚集索引？ Nosql引擎用的什么存储结构，关系型数据库和NoSQL各自的优劣点是什么，如何技术选型？</li><li>mysql同步机制原理，有哪几种同步方法？ 数据库主从同步如何实现，事务如何实现？</li><li>还问了一个关于数据库优化流程的问题（索引，Mysql的查询缓存，Mysql分库分表方案） 伪共享问题的原理，mysql不同存储引擎的所使用的数据结构的不同</li><li>mysql联合索引，判断是否使用了索引 mysql索引结构 间隙锁 mysql处理死锁机制是怎么样的 mysql MVCC 线程池的参数理解</li><li>mysql主从复制主要有几种模式？</li><li>mysql行锁最大并发数？（秒杀项目指出）</li><li>2.数据库底层有了解吗 3.讲下聚簇索引 4.怎么解决慢查询 5.索引底层 6.b+树跟b树有啥区别 7.你说b+树能范围查询，怎么实现的 8.b+树的高度怎么计算 9.b树和b+树的叶子节点和非叶子节点都存什么 10.mysql最多能存多少数据 11.Mysql默认的事务隔离级别是什么，有什么缺点 12.什么是幻读 13.怎么解决幻读 14.Mysql的log有哪些，分别用来解决什么问题 15.怎么看mysql有没有执行索引 16.explain的时候最关心哪些字段，分别是什么含义</li><li>怎么定位死锁；</li><li>MySQL的查询机制</li><li>结构数据库和非结构数据库区别，你了解的非结构数据库有哪些？ 频繁的增删数据量某个表，数据库最终数据只有几万或者更少，为什么查询会变慢？ 数据如果出现了阻塞，你是怎么排查的</li><li>Mysql数据库默认的隔离机制。</li><li>mysql的索引，b+树索引是否支持范围查询，联合索引的失效情况</li><li>mysql 隔离级别有哪些，分别能解决哪些问题（脏读，幻读…）如何解决；</li><li>事务是什么，什么特征，事务如何实现原子性和一致性的 e. 索引是什么，接着就是红黑，B B+ 三连问（实现原理，区别，优缺点）； 那什么是聚集索引，讲讲原理，有什么优缺点。</li><li>说一下mysql索引 了解数据库锁吗 你怎么做sql优化的 了解MVCC吗 某个字段加了索引比不加索引快多少倍</li><li>mysql索引是怎么实现的？b+树有哪些特点？真实的数据存在哪里？ 哪些情况下建索引？解释下最左匹配原则？ 现在一个表有三列a b c，组合索引(a,b,c)查询的时候where a like ? and b=? and c=?能用到这个组合索引吗？为什么？</li><li>自增锁、共享锁、排他锁、意向锁、插入意向锁、记录锁、间隙锁是什么；</li><li>事务的四大特性、并发一致性导致的问题、四种隔离级别解决的问题以及如何实现的（加了什么锁）；</li><li>范式的概念</li></ul><h1 id="Dubbo和Spring-Cloud相关"><a href="#Dubbo和Spring-Cloud相关" class="headerlink" title="Dubbo和Spring Cloud相关"></a>Dubbo和Spring Cloud相关</h1><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><ul><li>你说你了解dubbo，能讲一下dubbo的基本原理吗？</li><li>dubbo支持的通信协议和序列化协议？ dubbo负载均衡和集群容错策略有哪些？dubbo的spi思想dubbo进行的服务治理、服务降级、失败以及重试。服务端怎么知道客户端要调用的算法的？</li><li>阐述下dubbo的架构</li><li>dubbo支持的注册中心有哪些，分别的优缺点</li><li>dubbo执行流程？</li><li>dubbo和springclond的架构区别和优劣？</li><li>说一下dubbo的实现过程?注册中心挂了可以继续通信吗?</li><li>dubbo复制均衡策略和高可用策略都有哪些啊?动态代理策略呢?</li><li>Dubbo服务调用的概述 consumer每次都要去拉注册中心provider的信息吗 consumer会缓存所有的provider元信息吗</li><li>为什么要进行系统拆分啊?拆分不用dubbo可以吗?dubbo和thrift什么区别啊?</li><li>Dubbo的服务请求失败怎么处理 •重连机制会不会造成错误</li><li>Dubbo相比webservice等方式的优势</li><li>Dubbo的RpcContext是怎么传递的？</li><li>dubbo默认使用什么传输协议</li><li>dubbo和ZK使用时给ZK提交些什么信息？用户是直接调用dubbo还是ZK？</li><li>Dubbo超时重试；Dubbo超时时间设置；</li><li>dubbo调用端怎么在jvm中生成对应服务？dubbo服务端和调用端超时时间设置和区别、dubbo长连接</li><li>dubbo服务治理是怎样的；</li><li>dubbo如何一条链接并发多个调用。Dubbo的原理，序列化相关问题</li><li>dubbo怎么知道服务器状态有什么内部机制？</li><li>使用dubbo进行远程调用时消费端需要几个线程。</li><li>dubbo支持的注册中心有哪些，分别的优缺点-</li><li>dubbo调用其他服务如何做到不检查；</li></ul><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><ul><li>spring cloud基本概念</li><li>SpringCloudy 容器化</li><li>讲讲springcloud个组件原理，zuul、Hystrix</li><li>讲一讲springcloud的eureka组件？</li><li>gateway和zuul做网关的区别？</li><li>Spring cloud相关： （1）Eureka服务注册发现，对比其他组件。 （2）Hystrix熔断与降级</li><li>网关选型 Zuul 和 Spring Cloud Gateway Eureka 服务发现的原理 服务发现选型应该要考虑的因素有哪些？</li><li>什么是Eureka的自我保护模式</li><li>服务发现是怎么实现的 熔断是怎么实现的</li></ul><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ul><li>分布式锁zookeeper的使用场景，实现分布式锁的方式，redis分布式锁和zookeeper分布式锁结合项目来说 以上两种方式的实现和异同</li><li>描述下ZooKeeper的选举机制</li><li>ZooKeeper的监听原理是什么？</li><li>ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群中最少需要几台？</li><li>ZooKeeper常用命令</li><li>zookeeper的核心是什么?</li><li>zk原理知道吗?zk都可以干什么?Paxos算法知道吗?说一下原理和实现?</li><li>在你的项目中spring是如何管理zookeeper的？</li><li>看了zookeeper源码，你的收获是什么？</li><li>zookeeper宕机与dubbo直连的情况？</li><li>zookeeper是保存数据的流程</li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul><li>nginx限流模块；</li><li>nginx有哪些模块？你比较熟悉哪个？</li><li>nginx负载均衡策略有哪几种？</li><li>谈下你对nginx和uwsgi的理解、为什么要用wsgi？</li><li>nginx负载均衡有哪些，如果其中一台服务器挂掉,报警机制如何实现</li></ul><h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><ul><li>微服务设计问题，rpc实现方式简单介绍；</li><li>dubbo、RPC介绍原理 限流算法 zk挂了怎么办 分布式锁的实现方式，zk实现和Redis实现的比较 秒杀场景设计，应付突然的爆发流量 分布式数据一致性 一致性哈希</li><li>分布式服务接口的幂等性如何设计</li><li>你们项目中分布式的session如何实现?实际就是分布式系统中的session共享 关于分布式事务、以及分布式事务问题</li><li>聊一聊SOA和微服务。soa和微服务的区别</li><li>项目中怎样使用微服务？ 两个服务之间调用的流程 rpc与http的区别 设计rpc协议需要注意什么</li><li>作为调用方和被调用放如何对避免服务雪崩？ rpc接口的超时时间时如何设置得？服务容灾是如何做的,你们工作中采用的微服务是如何部署的？</li><li>实现RPC框架需要注意什么？</li><li>什么是节流与防抖，如何实现</li><li>服务容灾是如何做的？</li><li>作为调用方和被调用放如何对避免服务雪崩? rpc接口的超时时间时如何设置得？</li><li>负载均衡有哪些算法？</li><li>分布式一致性协议raft，paxos 了解吗？Zookeeper中的ZAB协议，选主算法；</li><li>实现负载均衡和顺序轮询机制；（考虑并发）</li><li>RPC服务的概念，RPC服务一般都怎么做序列化？怎么处理传输层的字节流？</li><li>分布式锁的实现原理和有多少种实现方式？</li><li>远程服务框架:dubbo的通信过程，服务发现过程，序列化反序列过程原理理解；分布式协调算法：zk的paxos协议原理,zab原理，metaq的raft协议原理；</li><li>服务器雪崩是怎么造成的？之前有这样的经历吗？怎么防备？</li><li>如何实现何高并发下的削峰，限流？</li><li>client调用A服务，A服务依赖于B服务，在不知道B是否高可用的情况下，怎么保证A的高可用？</li><li>分布式任务调度怎么做？</li></ul><h2 id="dubbo扩展"><a href="#dubbo扩展" class="headerlink" title="dubbo扩展"></a>dubbo扩展</h2><p>以下有关dubbo的面试题来自知识星期【芋道源码】</p><ul><li>说说 Dubbo 的整体架构？有哪些角色，怎么交互的？ps：先不用回答到内部的调用链路。</li><li>请说说 Dubbo 一次完整调用的过程？越详细越好，最好画个图</li><li>Dubbo 需要考虑优雅上线么？是和否的原因是什么？</li><li>Dubbo 有哪些负载均衡策略？默认是哪一种。</li><li>43.Duboo 集群容错策略有哪些？如何选择？</li><li>Dubbo 的 SPI 机制是什么？为什么需要 SPI 机制？</li><li>可以使用 Spring 作为 Dubbo 的 SPI 机制么？可以使用 Java SPI 作为 Dubbo 的 SPI 机制么？ps：这个是换一个思路，看看候选人在 Dubbo SPI 的理解。</li><li>Dubbo Filter 机制是否了解？</li><li>你有实现过 Dubbo 自定义 Filter 么？</li><li>日常开发 Dubbo 服务时，怎么开发调试？</li><li>阅读 Dubbo 的标签路由功能，思考有没更好的 Dubbo 调试便利性。</li><li>Dubbo 有哪些序列化组件？你们目前使用哪个？原因是？</li><li>如何实现一个 Dubbo 本地调试的封装？</li><li>在 Dubbo 中，可以使用那些中间件实现链路追踪？知道实现原理么？</li><li>什么是 Dubbo 隐式传参？有什么用途？</li><li>如果使用 Redis 作为 Dubbo 的注册中心，需要考虑哪些东东？</li></ul><h1 id="MQ和分布式事务"><a href="#MQ和分布式事务" class="headerlink" title="MQ和分布式事务"></a>MQ和分布式事务</h1><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><ul><li>项目中RabbitMQ实现了at least once,包括mq反馈provider,消息持久化,consumer主动反馈mq.线程池消费防止消息积压等</li><li>mq 通知时，消费者没消费到怎么办</li><li>简单聊聊消息中间件？</li><li>你了解那些具体的消息中间件产品？</li><li>mq的消费端是怎么处理的？ 整理一下你的消费端的整个处理逻辑流程，然后说说你的ack是在哪里返回的。按照你这样画的话，如果数据库突然宕机，你的消息该怎么确认已经接收？ 那如果发送端的服务是多台部署呢？你保存消息的时候数据库就一直报唯一性的错误？</li><li>rocketmq用在什么场景。 如果消费者组A下面有两个消费者组A1,A2,问消费者A1和A2能否消费不同的topic ?rocketmq如何保证的事务。</li><li>kafka,activemq,rabbitmq,rocketmq都有什么优点,缺点啊?</li><li>如果让你写一个消息队列，该如何进行架构设计啊?说-下你的思路</li><li>用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗 ?MQ系统的数据如何保证不丢失</li><li>mq 通知时，消费者没消费到怎么办</li><li>mq的p2p模式</li><li>mq消息的幂等性如何保证？ mq如何保证顺序消费？</li><li>MQ怎样保证消息的可靠性以及当时如何做消息幂等处理的</li><li>如何确保消息正确地发送至RabbitMQ？ 如何确保消息接收方消费了消息？ 如何避免消息重复投递或重复消费？ 消息基于什么传输？ 消息如何分发？ 消息怎么路由？ 如何确保消息不丢失？ 使用RabbitMQ有什么好处？ rabbitmq的集群。 mq的缺点</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>首先来一个具体的解决方案的示例</p><blockquote><pre class="line-numbers language-none"><code class="language-none">*  1、两阶段提交（2PC） 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交. 第二阶段：事务协调器要求每个数据库提交数据。 优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致） 缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。 * 2、补偿事务（TCC） 针对每个操作，都要注册一个与其对应的确认和补偿（撤销）。Try、Confirm、Cancel 优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些 缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。 * 3、本地消息表（异步确保） 核心思想是将分布式事务拆分成本地事务进行处理，消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。 优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。 缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。 * 4、MQ事务消息 RocketMQ支持，RabbitMQ 和 Kafka 都不支持，一次发送消息和一次确认消息，生产方需要实现一个check接口（确认消息或者回滚） 优点： 实现了最终一致性，不需要依赖本地数据库事务。 缺点： 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。 * 5、Sagas事务模型 长时间运行的事务，该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>分布式事务了解吗？有哪些处理方法？</li><li>项目中有分布式事务处理吗？有哪些常见的分布式事务处理方式？说一下你们在项目中怎么用的。</li><li>分布式情况下如何保证事务。 如何设计实现一个分布式事务</li><li>分布式事务的各种方案及你的最佳方案</li><li>分布式事务是什么</li><li>什么是分布式事务？分布式事务如何保证数据一致性？</li><li>分布式事务知道吗?你们怎么解决的?TCC?那若出现网络原因,网络连不通怎么办啊</li><li>对分布式事务的理解</li><li>分布式事务的原理，如何使用分布式事务</li><li>多个服务之间调用的数据一致性问题，A服务中调用B服务 、C服务，B成功 C失败怎么解决？ 其实归根到底就是分布式事务的数据一致性解决方案，失败了数据怎么回滚</li><li>分布式事务的实现方式，分布式锁，分布式一致性，redis分布式锁；</li><li>分布式事务了解吗？你们项目中都用到了哪些分布式事务？都有哪些优缺点？</li><li>简单实现分布式事务</li></ul><h1 id="NIO和Netty面试题"><a href="#NIO和Netty面试题" class="headerlink" title="NIO和Netty面试题"></a>NIO和Netty面试题</h1><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><ul><li>阐述 NIO原理？</li><li>BIO/NIO/AIO有什么区别？有那些实现？</li><li>讲讲NIO的原理与实现？NIO用到了哪个经典技术思想？JDK1.8中NIO有做什么优化</li><li>了解多路复用机制 常见问题 同步阻塞、同步非阻塞、异步的区别？</li><li>select、poll、eopll的区别？</li><li>Linux网络IO模型</li><li>哪些库或者框架用到NIO？</li><li>redis的事件驱动多路复用底层实现；引申到NIO编程</li><li>NIO解决了什么问题</li><li>有了解过mina？</li><li>NIO的核心是什么？（IO线程池） ，问IO包的设计模式（装饰器模式），为什么要这样设计？有没有更好的设计？</li><li>NIO模型，特别是其中的selector的职责和实现原理</li><li>select、poll 和 epoll 的区别</li><li>NIO过程介绍，NIO怎么做到多路复用的</li></ul><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><ul><li>Netty 分布式任务调度怎么做？</li><li>Netty 的优势在哪？有什么问题吗？</li><li>NIO，Netty，网络协议，涉及到的OS交互</li><li>Netty nio问题，问了流程</li><li>Netty的 API gate 设计</li><li>Netty线程模型（源码拷问）</li><li>Netty的几种线程模型和架构</li></ul><h1 id="ORM框架-Mybatis-Hibernate和JPA"><a href="#ORM框架-Mybatis-Hibernate和JPA" class="headerlink" title="ORM框架 Mybatis,Hibernate和JPA"></a>ORM框架 Mybatis,Hibernate和JPA</h1><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul><li>Mybatis怎么实现Dao的一系列操作?原理简单介绍</li><li>ORM框架如何配置主从数据源，Mybatis原理</li><li>如果让你实现Mybatis，你会怎么设计？ Mybatis常用的标签有哪些？ sql注入怎么预防？ sql一般怎么优化？ 数据量多大的情况下考虑分表呢？ sql语句是怎么样执行的？（不知道，不过我猜应该会先校验sql语句的正确性，然后再放入执行引擎中取执行）。</li><li>MyBatis中#{}和${}的区别？</li><li>Mybatis的缓存？一级、二级缓存？</li><li>MyBatis框架的理解？</li><li>对于XML映射文件和Mapper接口对应，这Mapper接口的原理是什么？</li><li>Mybatis如何进行分页？</li><li>MyBatis是如何将sql执行结果封装为目标对象并返回的？</li><li>Mybatis的延迟加载以及实现原理？</li><li>介绍下Mybatis/Hibernate的缓存机制。</li><li>Mybatis的mapper文件中resultType和resultMap的区别。 Hibernate和Mybatis的区别。</li><li>Mybatis中DAO层接口没有写实现类，Mapper中的方法和DAO接口方法是怎么绑定到一起的，其内部是怎么实现的。</li><li>Mybatis如何找到指定的Mapper的，如何完成查询的。</li><li>Mybatis工作流程。 Mybatis与Hibernate区别。 Mybatis框架传递参数方式</li><li>Mybatis 二级缓存原理</li></ul><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><ul><li>Hibernate的缓存级别。 hibernate是什么，工作原理。 hibernate如何实现延迟加载。 hibernate如何怎样类之间的关系</li><li>Hibernate的数据有哪几种状态？状态是如何进行切换的？简单描述下Hibernate的缓存机制？二级缓存是怎么实现的？</li><li>Hibernate如何优化的？</li><li>Hibernate中多对多的关系处理；Hibernate的继承是否了解</li><li>Hibernate对一二级缓存的使用，Lazy-Load的理解；</li><li>对Hibernate缓存机制理解及看法；</li></ul><h1 id="Redis-和MongoDB及应用"><a href="#Redis-和MongoDB及应用" class="headerlink" title="Redis 和MongoDB及应用"></a>Redis 和MongoDB及应用</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>redis优化策略</li><li>redis除了做缓存还能做什么？</li><li>说说redis持久化方式？分别优缺点是什么？redis更新策略是什么？</li><li>redis的数据结构存储？以及应用场景？如何实现集群和高可用？</li><li>业务中redis如何保证可用性 怎么实现分布式锁（redis）</li><li>分布式锁的实现方式，zk实现和Redis实现的比较</li><li>redis支持的数据类型到跳跃表，redis同步策略 ,如何自己实现lru</li><li>什么是缓存击穿，redis的hotkey如何处理？如何保证数据库与缓存双写的一致性。</li><li>redis缓存过期策略，准备同步，哨兵机制和集群的区别</li><li>遇到的问题就是“缓存穿透”和“缓存击穿”，“缓存雪崩”，双写不一致等。 如何解决上述遇到的问题？</li><li>redis有哪几种数据类型，如何持久化，怎么更新，使用场景，主从复制怎么做？影响redis的瓶颈？</li><li>NoSQL数据库，以及MongDB和Redis使用场景？</li><li>缓存一致性问题 数据先写 redis？还是先写 MySQL？ 写入失败怎么办？ redis 或者 MySQL 挂掉怎么办？</li><li>redis的高可用，redis的集群方案，一致性哈希和哈希槽模式下缓存服务器宕机，数据如何迁移</li><li>你知道redis为什么读写速度那么快么？ redis数据装在内存中，那么数据可以持久化吗？ redis数据持久化的方式有哪些呢？ 这两种持久化方式的区别在哪里呢？ 你知道redis的内存淘汰机制吗？redis的cluster集群原理能简单说一下吗？</li><li>如何解决 Redis 的并发竞争 Key 问题</li><li>zset底层怎么实现的?</li><li>关于Redis的主从复制？</li><li>Redis 怎么保证不丢数据，能不能保证严格意义的一定不会丢 Redis 集群，生产环境Redis 如何做数据迁移</li><li>如何理解redis的高性能和高并发</li><li>Redis基本数据结构 跳表实现原理 过期处理，Redis单线程优势，影响吞吐因素，支持事务吗 Redis会遇到哪些问题 缓存一致性 穿透 雪崩，解决方案.</li><li>BloomFilter 知道吗？说下原理，怎么提高准确性</li><li>单线程的redis如何利用多核cpu机器？</li><li>有海量key和value都比较小的数据，在redis中如何存储才更省内存？</li><li>redis分布式锁如何保证原子性？</li><li>redis主备切换过程是怎样的？</li><li>redis的过期策略，定期删除何时终止</li><li>Redis如何解决key冲突？</li><li>如果redis作为分布式锁的时候,主节点挂掉了,但是数据还没有同步到从节点,这种情况怎么办?</li><li>redis的key是如何寻址的啊?</li><li>分布式缓存redis原理</li><li>redis分布式锁三种实现方式</li><li>redis和memcached 的内存管理的区别等等</li><li>redis的session共享的具体实现</li><li>讲讲redis里面的哈希表？</li><li>redis 集群主从复制原理。</li><li>Guava缓存除了做缓存还能做什么？和Redis的优缺点。</li><li>redis分片取模算法。</li><li>redis，memcache底层客户端使用一致性Hash，看是否了解；redis的事件驱动多路复用底层实现</li><li>redis的事务机制；</li><li>Redis 有序集合实现方式有哪些； zset与set区别？ list和set又有什么区别？</li><li>set 和setNx有什么区别</li><li>redis数据结构、跳跃表,redis qps能上多少，怎么知道的 ,sentinel和cluster区别和各自适用场景,redis cluster集群同步过程</li><li>讲下布隆过滤器的实现机制</li><li>redis处理大量重复数据</li><li>生产环境Redis 如何做数据迁移</li><li>Redis官方为什么不提供Windows版本？</li><li>redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）</li><li>Redis主要消耗什么物理资源？</li><li>分布式锁的方案，redis和zookeeper那个好，如果是集群部署，高并发情况下哪个性能更好？</li><li>高并发量大的话怎么处理热点，数据等。</li></ul><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>MongoDB和MySQL的区别，各自使用场景</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><p>项目里用redis存哪些数据？为什么用redis？和jetty本地缓存有什么区别？</p></li><li><p>发散性问题：假如有100万个玩家，需要对这100W个玩家的积分中前100名的积分，按照顺序显示在网站中，要求是实时更新的。积分可能由做的任务和获得的金钱决定。问如何对着100万个玩家前100名的积分进行实时更新？</p><blockquote><p>思路就是考虑出了前100名的后100W-100名玩家的积分，让变化的积分跟第100名比较，如果比第100名高，那就替换的原则。就是利用缓存机制，缓存—tomcat—DB，层级计算，能不用到DB层就别用，因为每进一层，实现起来都会更复杂和更慢。</p></blockquote></li><li><p>谈谈你对缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级的理解？</p></li><li><p>解决缓存击穿的方式有哪几种?加锁的时候什么时候选择本地锁,什么时候选择分布式锁?</p></li><li><p>数据库有1万条数据，怎么很快的加载到redis？</p></li><li><p>问nosql如何设计？</p></li><li><p>做个微信商城，其中有各种活动，限时优惠，和秒杀，问我并发的时候怎么做处理的。</p><blockquote><p>（用redis计数器做，当秒杀的商品库存减低时，直接响应请求）</p></blockquote></li><li><p>设计一个防止缓存穿透的解决方案，</p></li><li><p>分布式缓存实现原理，秒杀业务怎样防止超卖；</p></li><li><p>实际场景问题解决:典型的TOP K问题</p></li></ul><h1 id="Spring相关"><a href="#Spring相关" class="headerlink" title="Spring相关"></a>Spring相关</h1><ul><li>spring工作原理简单介绍</li><li>循环依赖问题</li><li>spring/spring boot启动加载过程 ？springboot是怎么运行起来的 使用springboot的好处是什么？</li><li>描述下spring的ioc和aop</li><li>spring task是怎么实现的？</li><li>spring事务你是怎么用的？加了@Transcational注解spring都做了哪些工作？怎么知道事务执行成功了</li><li>你常用哪一种注入方式？BeanFactory和ApplicationContext有什么区别？你们项目里用的哪个？说一下spring bean的生命周期</li><li>AOP实现原理是什么？两种动态**<em>实现原理？JDK动态**</em>为什么要实现接口？</li><li>spring默认事务传播属性是什么？嵌套事务子事务什么时候commit？</li><li>spring和springMVC是什么关系？有没有用过JdbcTemplate？ 16.springMVC中对整个请求的处理流程是怎样的？返回json的话是用哪个view？</li><li>ioc原理、aop原理和应用</li><li>springmvc底层实现大致逻辑?spring mvc有哪些常用的注解？</li><li>spring中Bean的作用域，几种scope区别，springMVC的controller是线程安全的吗？怎么去保证线程安全呢？</li><li>对spring的理解,仔细讲解一下spring的两大特性。说一下AOP中的切面切点。 用过哪些注解，注解的生命周期</li><li>你知道Spring的Scope吗？ 既然是单例的，怎么能保证变量可能会随不同的人访问出现值的改变？</li><li>SpringBoot 的自动配置是怎么做的？</li><li>spring容器的启动过程？</li><li>spring IOC 过程 如何自己设计IOC框架</li><li>spring生命周期，几种scope区别，aop实现有哪几种实现</li><li>SpringBoot核心配置文件有哪些，区别是什么？Springboot的核心注解组成？springboot的监视器的理解？</li><li>属性注入和构造器注入哪种会有循环依赖的问题？</li><li>spring事务传播 常见问题,spring事务传播机制的实现原理。</li><li>手写个jdk动态代理</li><li>spring事务的原理</li><li>springmvc的几个核心类及请求过程</li><li>@Autowired的作用</li><li>Spring的单例Bean是线程安全的吗？</li><li>谈一下SPRING的源码，IOC，AOP的源码</li><li>配置spring mvc拦截器的步骤</li><li>依赖注入属于什么模式？</li><li>spring异常处理</li><li>spring对bean的管理流程</li><li>然后问一个切点可以配置多个切面吗？</li><li>问spring用了哪些设计模式；用了哪些分布式缓存？</li><li>Spring 都有哪几种注入方式，什么情况下用哪种</li><li>执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring？（传播性）</li><li>sping如何实现（保证）事务一致性完整性，spring中事务传播机制类型；</li><li>spring的http请求的流程</li><li>spring底层数据结构？</li><li>spring aop的底层实验原理。 aop与cglib，与asm的关系。 spriong ioc的生命周期，init-method，intilizingbean接口方法afterPropertiesSet的先后顺序；</li><li>@transactional注解在什么情况下会失效，为什么。</li><li>.Spring如何维护它拥有的bean</li><li>问了class A和B相互依赖的情况下，spring如何对这两个bean进行加载</li><li>spring的bean加载机制和加载过程是怎样的；bean是什么时候消亡；</li><li>对spring的Bean加载了解吗？如果是你自己写一个这样的框架，你会如何写？</li><li>问 spring的controller中要跳转到一个新页面，并且把数据也传过去，应该返回一个什么对象？</li><li>Spring里面怎样实现在容器加载时就执行相关方法；</li><li>覆盖spring IOC容器中一个bean</li><li>spring的事务管理是如何实现的，编程式如何实现</li><li>IOC的主要作用</li><li>DI怎么用伪代码来实现。</li><li>什么是自动配置？ 什么是 Spring Boot Stater ？ 你能否举一个例子来解释更多 Staters 的内容？ Spring Boot 还提供了其它的哪些 Starter Project Options？ Spring 是如何快速创建产品就绪应用程序的？ 创建一个 Spring Boot Project 的最简单的方法是什么？ 为什么Spring Initializr 是创建 Spring Boot Projects 的唯一？为什么我们需要 spring-boot-maven-plugin？ 如何使用 SpringBoot 自动重装我的应用程序？ 什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢？ 如何在 Spring Boot 中添加通用的 JS 代码？</li></ul><h1 id="docker和linux"><a href="#docker和linux" class="headerlink" title="docker和linux"></a>docker和linux</h1><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul><li>docker的原理？dockerfile里面用过什么命令？</li><li>用过docker？dockerfile写过吗，常用命令，说下分层原理</li><li>docker 部署有什么好处？</li><li>docker 的底层原理是什么？namespace 和 cgroups，一个隔离环境，一个控制资源配额。那隔离环境主要隔离什么环境？</li><li>docker镜像和容器有什么区别？为什么要用docker？docker daemon是啥？发现docker daemon响应突然变慢了，如何排查？</li><li>docker的image、layer、container分别讲下？</li><li>是否用过docker和springCloud这样的搭建微服务？</li><li>docker的namespace和cgroup、cmd和entrypoint的区别</li><li>问我在docker里面如果查看linux发布版本，看到的是容器的还是宿主机的； 还有docker启动时如果要限制使用的cpu和内存，要加什么参数；</li><li>docker和虚拟机区别 docker安全性.和虚拟机比较？</li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li>Linux namespace讲一下？Linux cgroup的层级结构讲一下？</li><li>Linux中namespace是怎么实现的，底层的数据结构是什么？</li><li>linux中你用哪些命令 ,linux中想看一个文件中某个关键字出现的次数（我不会，后面还会问到。。）</li><li>linux下如何查看网络端口状态（netstat），如何查看内存使用情况（top）</li><li>linux常用操作命令</li><li>linux下查看系统时间的指令是什么？</li><li>查看linux内核版本该用哪些命令；</li></ul><h1 id="分布式和中间件等"><a href="#分布式和中间件等" class="headerlink" title="分布式和中间件等"></a>分布式和中间件等</h1><ul><li>raft协议 paxos算法</li><li>ddos 如何避免？怎么预防？怎么发现？利用了TCP什么特点？怎么改进TCP可以预防？服务端处理不了的请求怎么办？连接数最大值需要设置吗？怎么设置？ Thrift RPC过程是什么样子的？异构系统怎么完成通信？跟http相比什么优缺点？了解grpc吗？</li><li>kafka topic partition介绍下 一个 partition对应多少 生产者（不限），对应多少消费者（一对一） zk你们怎么用的</li><li>Redis与Mysql双写一致性方案</li><li>微服务架构是什么？它的优缺点？ ACID CAP BASE理论 ,分布式一致性协议，二段、三段、TCC，优缺点 ,RPC过程 ,服务注册中心宕机了怎么办？ 微服务还有其他什么组件 ,分布式架构与微服务的关系</li><li>从hystrix一路问到原理-&gt;自己如何实现-&gt;如何优化-&gt;响应流编程(reactive streams);</li><li>如何识别tcp和udp报文</li><li>如果生产者生产的数据量很多，消费者来不及消费这些数据怎么办？</li><li>Kafka消息是采用Pull模式，还是Push模式？</li><li>Kafka分区，如何分区等等</li><li>RPC的过程？ 如何做到透明化远程服务调用？ 动态代理，把本地调用代理成网络调用 .如何进行服务发布？（Zookeeper） 如何进行序列化与反序列化？（Protobuf、Thrift、Avro） 如何进行通信？（NIO—&gt;Netty）</li><li>Zookeeper锁是如何实现的？</li><li>分布式缓存读写不一致问题</li><li>Kafka是如何实现高吞吐率的？</li><li>配置中心项目, 问实时配置推送怎么做</li><li>讨论为什么选择所有的组件依赖放在配置中心中控制 ,我现在要做一个限流功能, 怎么做？这个限流要做成分布式的, 怎么做？ 怎么抢锁？锁怎么释放？ 加了超时之后有没有可能在没有释放的情况下, 被人抢走锁？怎么解决？ 不用 zk 的心跳, 可以怎么解决这个问题呢？假如这个限流希望做成可配置的, 需要有一个后台管理系统随意对某个 api 配置全局流量, 怎么做？</li><li>某一个业务中现在需要生成全局唯一的递增 ID, 并发量非常大, 怎么做</li><li>Kafka 的消费者如何做消息去重？</li><li>介绍一下 Kafka 的 ConsumerGroup</li><li>瞬时写入量很大可能会打挂存储, 怎么保护？（断路器） 断路器内部怎么实现的？（可以用 ringbuffer） 断路器会造成写入失败, 假如我们不允许写入失败呢？</li><li>MMM的DB架构，主从未完全同步，master挂了，未同步的内容会造成什么影响，怎么恢复</li><li>分布式锁使用和原理？</li><li>kafka为什么性能高？</li><li>mq怎么保证消息可靠性？</li><li>dubbo的设计和完整调用过程（要详细）</li><li>kafka生产端怎么实现幂等的 kafka如何实现分布式消息 kafka的副本同步机制的理解 kafka怎么进行消息写入的ack</li><li>分布式系统怎么做服务治理</li><li>Dubbo的服务请求失败怎么处理 ,重连机制会不会造成错误</li><li>如何实现负载均衡，有哪些算法可以实现？</li><li>Zookeeper的用途，选举的原理是什么</li><li>Nginx相关 1.nginx有哪些模块？你比较熟悉哪个？ 2.proxy_cache你是怎么配置的？缓存是存在哪里？具体是怎么命中缓存的？</li><li>spring cloud 组件和实现</li><li>消息可靠性保证；（数据幂等、高可用镜像集群、Confirm机制、事务机制、持久性）</li><li>任务拆分执行框架与管理基本手段，高可用实现（基于自己熟悉业务说）</li><li>zookeeper是保存数据的流程（选举算法要知道）</li><li>消息可靠性保证；（数据幂等、高可用镜像集群、Confirm机制、事务机制、持久性）</li><li>消息队列 1、项目中为什么使用消息队列，消息队列可以用来干什么； 2、如何解决消息重复消费、消息丢失、消息积压、顺序消费等问题； 3、如何保证消息队列得高可用性；</li><li>Eureka怎么实现高可用； 什么是Eureka的自我保护模式 ；Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别；</li><li>Dubbo 1、服务注册与发现； 2、SPI； 3、服务暴露过程； 4、服务引用； 5、降级； 6、负载均衡；</li><li>如何解决 Redis 的并发竞争 Key 问题。</li><li>zookeeper宕机与dubbo直连的情况？</li><li>消息基于什么传输？ 消息如何分发？ 消息怎么路由？ 如何确保消息不丢失？</li><li>RabbitMQ 中的 broker 是指什么？cluster 又是指什么？ RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？</li><li>解释下分布式系统中的cap理论，怎么保证ca？</li><li>Eureka 服务发现的主要功能 Eureka 服务有多少个实例 Eureka 服务同步每次都是全量吗 Eureka 服务发现的数据一致性 Eureka 如何保证数据可靠性，如何确认是一致的 Eureka 如果实例数太多，会面临同步的问题吗 Zuul 限流是如何实现的 限流是这一层起作用还是下一层起作用 为什么要在你这一层去做呢？那如何保护自身呢？ 限流的实现方式，有哪几种算法 时间窗口与令牌桶的对比 配置管理是如何实现的 应用配置的场景 为什么选择 zk 做配置管理 为什么不用 zk 做服务注册 怎么防止雪崩、服务过载这些 网络平时有遇到什么问题吗？ 服务间调用丢包、传输速度慢，怎么去解决？ 如何查看连接是否丢包 大量的连接导致短暂的瘫痪状态，怎么去解决？</li><li>Eureka 损失了一致性会带来什么问题呢？ Eureka 有主吗？怎么实现的同步？如果遇到了不一致的问题，谁说了算？ 如果多个节点同时尝试注册会有问题吗？ Eureka 内部采用的一致性算法是什么算法？</li><li>介绍 Paxos 原理？缺点是什么？ 本机宕机了怎么办？消息表会丢失的？ 数据存在哪里？消息表存在磁盘或者内存还是远程的数据库？ 本地消息表的缺点和优点是什么？</li><li>XA 事务和 TCC 的区别 如何解决 XA/TCC 的单点问题（数据分片） 什么是TCC，它的工作过程？ TCC 和 XA 的区别？ 如果让你优化XA，你会如何优化？</li><li>skywalking 的监控原理</li><li>redis分布式锁实现的话，setnx和expire命令，如果A线程将expire操作操作到了B线程了，也就是expire了另一个线程的资源，这种怎么避免？</li><li>规定给出的并发量外，如果有额外的流量访问进来了，如何做熔断处理？</li><li>搜索时延这么高，该如何进行优化？如何提高响应速度？如何优化以提升用户体验度？</li><li>分布式锁的方案，redis和zookeeper那个好，如果是集群部署，高并发情况下哪个性能更好？</li><li>如何实现何高并发下的削峰，限流？</li><li>redis集群，怎么集群，怎么负载，怎么设置？</li><li>nginx怎么保证各web容器之间不会串？</li><li>redis的高可用如何保证？</li><li>spring是如何管理zookeeper的？</li><li>了解zookeeper的leader选取算法吗，讲一下它的流程。</li><li>分库和分表怎么选择？结合项目场景讨论划分规则</li><li>kafka的产生背景和在项目中的使用 topic和partition，partition是干什么的 Consumer Group是干什么的 怎么将partition分配到多个broker上？怎么动态调整partition和broker的数量？ rebalance什么时候发生，rebalance过程</li><li>分布式协调算法：zk的paxos协议原理,zab原理，metaq的raft协议原理；</li><li>分布式限流如何实现，原理是什么？</li><li>分库分表的实现原理是什么，你所在业务一般是怎么分库分表的？对应逻辑是什么？</li><li>Nginx轮询的实现原理；</li><li>分布式缓存读写不一致问题；</li><li>谈谈完全高可用的分布式支付框架的设计构想；</li><li>dubbo调用其他服务如何做到不检查；</li><li>在分布式服务器群中，有两台服务器对共享数据库的同一条数据进行并发修改，如果解决同步问题；</li><li>分布式缓存需要具备的特点是什么？</li><li>各种消息中间件的底层实现有何不同；</li><li>mysql同步机制原理，有哪几种同步方法？ 数据库主从同步如何实现，事务如何实现？</li><li>谈谈你对SOA和微服务的理解，以及分布式架构从应用层面涉及到的调整和挑战。</li></ul><h1 id="场景和设计"><a href="#场景和设计" class="headerlink" title="场景和设计"></a>场景和设计</h1><ul><li>为什么要这样分表？跨库join如何解决？数据量突增怎么解决？ 如何解决线上问题？cpu狂飙怎么办？频繁minor gc怎么办？可能造成的原因是什么？如何避免？ 数据库 隔离级别，怎么实现的？当前读，快照读？MVCC？</li><li>分库分表的设计？ 分布式事务出现过不一致吗？为什么？怎么解决？有什么方法避免？怎么监控？监控到怎么处理？什么时候需要人工接入</li><li>如何优雅的写代码？什么代码算做优雅？什么代码是规范？你们代码规范是什么样的？ 如何进行code review？</li><li>mysql innodb下，能不能不设置主键？主键可以为空吗？可以允许几个？主键跟非主键的区别？索引存储形式？ 联合索引失效问题？索引失效问题？mysql索引，覆盖索引？回表？B+树叶子节点存储什么？为什么不用AVL树？ 数据库锁，乐观，悲观，record lock？next-key lock？</li><li>不停机扩容？分表避免冷热？不停机扩库？不停机扩表？跨库事务？</li><li>Redis与Mysql双写一致性方案</li><li>微服务需要注意些什么?</li><li>redis并发竞争key的解决方案</li><li>高并发系统的设计与实现</li><li>高并发系统的限流如何实现？</li><li>如何从0到1设计一个类似Dubbo的RPC框架？</li><li>线上有实际的性能优化经验？ 3、从SQL、JVM、架构、数据库四个方面讲讲优化思路，以及如何优先排序？</li><li>如果让你实现一个mq，怎么样保证消息不丢失</li><li>从简单的生产者消费者模式设计到如何高效健壮实现等等</li><li>然后根据一个项目，问如果量级扩大1000倍，你会怎么做？</li><li>如果让你做一个监控告警服务，你怎么设计</li><li>如果生产者生产的数据量很多，消费者来不及消费这些数据怎么办，</li><li>某一个业务中现在需要生成全局唯一的递增 ID, 并发量非常大, 怎么做</li><li>考虑一个业务场景: 头条的文章的评论量非常大, 比如说一篇热门文章就有几百万的评论, 设计一个后端服务, 实现评论的时序展示与分页</li><li>假如用 id 翻页的方式, 数据库表如何设计？索引如何设计？ 假如量很大, 你觉得需要分库分表吗? 怎么分？ 分库分表后怎么查询分页？ 分库分表后怎么保证主键仍然是递增的？ 现在需要支持深分页, 页码直接跳转, 怎么实现？</li><li>工作当中cpu和内存异常排查方法；详细说明分析过程及定位解决方式</li><li>redis问了一个实际问题的解决办法，如果redis一个value特别大，有什么解决方案；</li><li>接口调用变慢排查</li><li>解决项目运行时，CPU占用过高的问题</li><li>死锁怎么排查？</li><li>怎么不断优化项目、架构升级？如果业务量剧增，怎么保证系统高可用、扩展性？</li><li>系统负载过高怎么办、什么问题导致的？怎么排查？</li><li>JVM调优思路</li><li>redis cluster集群扩容怎么数据平滑过度，从客户端设计</li><li>设计一个im系统包括群聊单聊</li><li>设计数据库连接池</li><li>秒杀场景的设计</li><li>VM 出现 fullGC 很频繁，怎么去线上排查问题？</li><li>设计一个系统，每天有100亿条数据，需要在后台做实时展示和查找。 我当时回答的大体思路是nginx负载均衡，消息队列存储，多线程读取，批量插入，数据库分库分表。 面试官根据我的回答又衍生出了很多问题，如消息队列存满了怎么办？（也就是消费跟不上生产）批量插入时某一条失败了有什么影响？怎么解决？分库分表应该怎么分？怎么解决数据迁移的问题？</li><li>内存泄露，内存溢出解决方案？</li><li>A系统和B系统需要交互，A系统需要更新B系统的大量数据，但是更新失败了，有什么解决方法。</li><li>高并发场景 1、如何定时得往数据库中插入500万条数据以及删除，保证数据插入正确做到最优解； 2、在高并发下如何设计使用Redis；3、在高并发场景下如何设计一个接口，保证这个接口高性能高可用；</li><li>如何读取一个很大得文件里面存入了很多url怎么找到最常用得url；</li><li>如果页面点击反应慢，你怎么排查的？最后怎么优化？ 分布式你怎么怎么保持数据一致性的 说一下springboot启动run方法里都干了什么 给你ip1到ip2的一个ip段，再给你一个ip，用程序判断这个ip属不属于这个ip段 讲一下zk 你们zk挂了怎么处理的，你们redis挂了用的什么策略解决的</li><li>两个10G的文件，里面是一些url，内存只有1G，如何将这两个文件合并，找到相同的url？</li><li>100W 的数据，需要定时更新，失败需要重试，需要尽快执行完成。现在机器数量不固定，如何用最少的代码实现</li><li>一个任务在平时只需要 5 个线程就可以处理好，忙的时候需要 100 个线程才能处理完成， 如何设计才能合理利用资源？</li><li>规定给出的并发量外，如果有额外的流量访问进来了，如何做熔断处理？</li><li>搜索时延这么高，该如何进行优化？如何提高响应速度？如何优化以提升用户体验度？</li><li>如何实现何高并发下的削峰，限流？</li><li>服务器雪崩是怎么造成的？之前有这样的经历吗？怎么防备？</li><li>内存500M，有个文件存有int类型数据1亿条，要去读取，怎么处理</li><li>从需求到开发到上线。如何对需求进行有效管理？</li><li>假设有一个场景，系统需要某个特定时间内响应用户请求，比如说100ms内完成用户请求，但是在最高峰的时候每单位时间几百万的用户请求，也就是高并发，但我必须要实现系统响应及时，而且高可用(不宕机)，假如你是架构师，你该如何架构这个系统，聊聊你的方案。</li><li>如果要对系统进行监控，考虑哪些方面，如何实现？</li><li>如果你现在CPU100%了，你如何查询是哪个进程，哪个线程，哪行代码占用CPU过高？</li><li>自己写程序实现MySQL不同实例之间的导表/要求尽量高并发高效/给出设计</li><li>前台订单数据库如何与仓库库存数据库保持同步？限时抢购如何实现？</li><li>场景：同时给10万个人发工资，怎么样设计并发方案，能确保在1分钟内全部发完？</li><li>设计一个订餐排队系统，底层模型有哪些？(客户，商家，桌型)</li><li>单台机器4核，服务A请求时间为5S，但是A调用的某个服务B耗时4.98S，A服务超时时间是10S，问100QPS的访问量，动态线程池CoreSize,maxSize,等待队列怎么指定？</li><li>多个平台（B端C端）有多个支付的接口可利用，如何设计表；</li><li>给你100亿个账号和密码，怎么用纯Java自己设计一个缓存系统；</li><li>问重启服务的时候，发现线程数特别高，可能是什么问题？</li><li>秒杀系统如何设计？</li><li>如何实现1亿用户的消息通知机制？</li><li>秒杀业务怎样防止超卖；</li><li>怎么搭建一个自动化构建和发布环境，怎么从0开始搭建一个测试环境</li><li>分布式缓存实现原理，秒杀业务怎样防止超卖；</li><li>系统在10：05 设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在？</li><li>成千上万个数据文件，每个文件大概2GB数据量，只用java基础实现所有数据的读取，并按每条数据的时间排序；</li><li>设计十万并发级别的网站后台，如何计算使用的ecs数目；</li><li>10G的整数中，取出最大的一个；</li><li>设计一个系统，每天有100亿条数据，需要在后台做实时展示和查找。</li></ul><h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><ul><li><p>InnoDB的行锁</p><blockquote><p>（1）共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 （2）排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁</p></blockquote></li><li><p>Spring的事务传播级别</p><blockquote><p>（1）REQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。 （2）SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。 （3）MANDATORY：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。 （4）REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。 （5）NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。 （6）NEVER：无事务执行，如果当前有事务则抛出Exception。 （7）NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</p></blockquote></li><li><p>Redis与Mysql双写一致性方案</p></li></ul><blockquote><p>先更新数据库，再删缓存。数据库的读操作的速度远快于写操作的，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作</p></blockquote><ul><li>索引B+树的叶子节点都可以存哪些东西？</li></ul><blockquote><p>可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引</p></blockquote><ul><li>分代回收</li></ul><blockquote><p>（1）HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 （2）因为年轻代中的对象基本都是朝生夕死的，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 （3）在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p></blockquote><ul><li>线程之间如何通信？</li></ul><blockquote><p>（1）利用最基本的synchronized （2）利用synchronized、notify、wait （3）while轮询的方式 （4）利用Lock和Condition （5）利用volatile （6）利用AtomicInteger （7）利用CyclicBarrier （8）利用PipedInputStream （9）利用BlockingQueue</p></blockquote><ul><li>redis并发竞争key的解决方案</li></ul><blockquote><p>（1）分布式锁+时间戳 （2）利用消息队列</p></blockquote><ul><li>如何避免（预防）死锁？</li></ul><blockquote><p>破坏“请求和保持”条件：让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源。 破坏“不可抢占”条件：允许进程进行抢占，方法一：如果去抢资源，被拒绝，就释放自己的资源。方法二：操作系统允许抢，只要你优先级大，可以抢到。 破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出（指定获取锁的顺序，顺序加锁）</p></blockquote><ul><li>高并发系统的设计与实现</li></ul><blockquote><p>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。 （1）缓存：缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。 （2）降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 （3）限流：限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p></blockquote><ul><li>高并发系统的限流如何实现？</li></ul><blockquote><p>常见的限流算法有计数器、漏桶和令牌桶算法。漏桶算法在分布式环境中消息中间件或者Redis都是可选的方案。发放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。</p></blockquote><ul><li><p>JVM有哪些回收算法</p><blockquote><p>1）引用计数法 （2）复制算法 （3）标记-清除算法 （4）标记-整理算法 （5）分代收集算法</p></blockquote></li><li><p>垃圾收集器有哪些？</p></li></ul><blockquote><p>（1）Serial收集器 （2）ParNew 收集器 （3）Parallel Scavenge 收集器 （4）Serial Old收集器 （5）Parallel Old收集器 （6）CMS收集器 （7）G1收集器 (8)ZGC</p></blockquote><ul><li>常见的分布式事务方案有哪些？</li></ul><blockquote><p>（1）两阶段提交方案 （2）eBay 事件队列方案 （3）TCC 补偿模式 （4）缓存数据最终一致性</p></blockquote><ul><li>运行时数据区域（内存模型）</li></ul><blockquote><p>（1）程序计数器：程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。是线程私有”的内存。 （2）Java虚拟机栈：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧 ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 （3）本地方法栈：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 （4）Java堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 （5）方法区（1.8叫元数据）:方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></blockquote><ul><li>CAS操作ABA问题</li></ul><blockquote><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性</p></blockquote><ul><li>为什么选择B+树作为索引结构？</li></ul><blockquote><p>（1）Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描 （2）二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。 （3）平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。 （4）红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。 （5）B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。</p></blockquote><ul><li>脏读和幻读是什么？</li></ul><blockquote><p>（1）脏读是指当一个事务正在访问数据，并且对数据进行了修改。而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。 （2）幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到了表中的全部数据行。同时，第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p></blockquote><ul><li>如何解决Redis缓存雪崩，缓存穿透问题？</li></ul><blockquote><p>缓存雪崩: (1)使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉 (2)缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效 (3)限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务 缓存穿透： (1)在接口做校验 (2)存null值（缓存击穿加锁） (3)布隆过滤器拦截： 将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。 布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。</p></blockquote><ul><li>Redis的持久化机制</li></ul><blockquote><p>redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。 Redis的持久化策略有两种： (1)RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。 当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。 (2)AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。 使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。 Redis默认是快照RDB的持久化方式。</p></blockquote><ul><li>三次握手</li></ul><blockquote><p>（1）第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 （2）第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； （3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p></blockquote><ul><li>Kafka消息是采用Pull模式，还是Push模式？</li></ul><blockquote><p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式。Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达。</p></blockquote><ul><li>HashMap相关</li></ul><blockquote><p>（1）在jdk1.8之后，HashMap除了数组+链表之外，引用了红黑树。需要说明对于引用了红黑树的 HashMap 如何put一个元素，以及链表是在何时转化为红黑树的。比如，首先需要知道这个元素落在哪一个数组里，获取hashcode后并不是对数组长度取余来确定的，而是高低位异或求与来得到的。这个地方首先得知道异或求与是做什么样的运算的。 （2）之后说一下在HashMap中的实现，比如hashcode无符号右移16位后和原hashcode做异或运算，这相当于把hashcode的高16位拿过来和hashcode的低16位做异或运算，因为无符号右移后前面说的16位都补零，这就是前面说的 “高低位异或“，进而是“求与”，和谁求与呢，和数组长度减1 求与。说到这里起码能够证明你是看过源码的，接下来说说你的思考，比如我们知道对于hashmap 初始化容量决定了数组大小，一般我们对于数组这个初始容量的设置是有规律的，它应该是 2^n 。这个初始容量的设置影响了HashMap的效率，那又涉及到影响HashMap效率的主要因素，比如初始容量和负载因子。</p></blockquote><ul><li>手写一个基于懒汉式的双重检测的单例。</li></ul><blockquote><p>（1）单例有三个比较关键的点，一是私有构造方法，避免外部new出对象；二是保证唯一性；三是提供一个全局访问点。 （2）另外，懒汉式双重检测的实现方式 有三点需要注意的地方，一是全局访问点必须是静态的，外界使用可以通过类直接调用，二是在进入锁之后还需要校验，三是保存单例对象的私有变量一定要用volatile修饰，这个地方可以多说一些，比如volatile防止指令重排序，保证内存可见性(JVM层面和CPU层面可以分别说)。</p></blockquote><ul><li>RPC原理</li></ul><blockquote><p>（1）为什么会出现RPC？ RPC(Remote Procedure Call Protocol)——远程过程调用协议。 一般来说，自己写程序然后本地调用，这种程序的特点是服务的消费方和提供方。当我们进入公司时，面对的很可能就是成千上万的服务提供方，这时候就需要使用RPC来进行远程服务调用。RPC将原来的本地调用转变为调用远端的服务器上的方法，给系统的处理能力和吞吐量带来了近似于无限制提升的可能。 （2）RPC的组成 ①客户端：服务的调用方 ②客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，③然后通过网络远程发送给服务方。 ④服务端：真正的服务提供者。 ⑤服务端存根：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</p></blockquote><ul><li>Redis缓存回收机制</li></ul><blockquote><p>（1）数据过期： ①定时删除策略：Redis启动一个定时器监控所有的key,一旦有过期的话就进行删除（遍历所有key,非常耗费CPU） ②惰性删除策略：获取key的时候判断是否过期， 过期则进行删除 Redis采用的方式:①(随机抓取一部分key进行检测)+② （2）内存淘汰： ①noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略） ②allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用） ③allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。 ④volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。 ⑤volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。 ⑥volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。</p></blockquote><ul><li>Redis主从同步</li></ul><blockquote><p>（1）主从复制作用 ①数据冗余 ②故障恢复（服务冗余） ③负载均衡 ④读写分离（主节点写操作、从节点读操作） （2）主从复制过程 ①连接建立阶段 步骤1：保存主节点信息 步骤2：建立socket连接 步骤3：发送ping命令 步骤4：身份验证 步骤5：发送从节点端口信息 ②数据同步阶段 从节点向主节点发送psync命令 根据主从节点当前状态的不同，可以分为全量复制和部分复制 ③命令传播阶段 主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。 （3）介绍全量复制和部分复制 ①全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。 ②部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。 （4）主从复制缺点：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p></blockquote><ul><li>为什么会有哨兵机制？</li></ul><blockquote><p>在主从复制的基础上，哨兵实现了自动化的故障恢复。</p></blockquote><ul><li>哨兵机制作用？</li></ul><blockquote><p>（1）监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。 （2）自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。 （3）配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。 （4）通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</p></blockquote><ul><li>哨兵机制节点组成？</li></ul><blockquote><p>它由两部分组成，哨兵节点和数据节点： （1）哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。 （2）数据节点：主节点和从节点都是数据节点。</p></blockquote><ul><li>哨兵机制原理？</li></ul><blockquote><p>（1）定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。 （2）主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。 （3）客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。 （4）选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。 （5）故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤： ①在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。 ②更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。 ③将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。</p></blockquote><ul><li>哨兵机制缺点</li></ul><blockquote><p>写操作无法负载均衡；存储能力受到单机的限制。（Redis集群解决了该情况）</p></blockquote><ul><li>Zookeeper锁是如何实现的？</li></ul><blockquote><p>一般使用Curator进行使用Zookeeper锁，例如有两个客户端A和客户端B,首先A先在锁节点下创建例如01子节点的锁，然后再获取节点信息，发现自己的01节点排名第一，那么就获得锁。 客户端B也需要获取锁，现在锁节点下创建例如02的子节点，然后再获取锁节点信息，发现锁节点信息为[01,02],并不排第一，因此获取不到锁，客户端B会在他的顺序节点的上一个顺序节点加一个监听器。 当客户端A使用完锁，删除01节点，客户端B获取到01删除的监听，然后发现自己的02节点排名第一，那么就获取到锁。</p></blockquote><ul><li>JVM内存模型</li></ul><blockquote><p>（1）程序计数器：线程私有，用来程序跳转，流程控制 （2）方法区（1.8叫元数据区）：线程共享，用于存储类信息、常量、静态变量等信息 （3）Java虚拟机栈：线程私有，用于方法调用Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError （4）堆：线程私有，主要的内存区域，存储对象实例，垃圾回收主要针对这一块。 （5）本地方法栈：线程共享，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p></blockquote><ul><li>G1和CMS垃圾回收器</li></ul><blockquote><p>G1和CMS垃圾回收器 （1）CMS收集器：是一种以获取最短回收停顿时间为目标的收集器。 过程： ①初始标记：标记GC Roots能直接关联到的对象，需要在safepoint位置暂停所有执行线程。—-&gt;STW ②并发标记：进行GC Roots Tracing，遍历完从root可达的所有对象。该阶段与工作线程并发执行。 ③重新标记：修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录。需要在safepoint位置暂停所有执行线程。—&gt;STW ④并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。 优点：并发收集、低停顿。 缺点： ①CMS收集器对CPU资源非常敏感。 ②CMS收集器无法处理浮动垃圾（Floating Garbage）。 ③CMS收集器是基于标记-清除算法，该算法缺点都有：标记和清除效率低/产生大量不连续的内存碎片。 ④停顿时间是不可预期的。 （2）G1收集器：重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。 过程： ①初始标记：标记GC Roots 可以直接关联的对象，该阶段需要线程停顿但是耗时短。—-&gt;STW ②并发标记：寻找存活的对象，可以与其他程序并发执行，耗时较长。 ③最终标记：并发标记期间用户程序会导致标记记录产生变动（好比一个阿姨一边清理垃圾，另一个人一边扔垃圾）虚拟机会将这段时间的变化记录在Remembered Set Logs 中。最终标记阶段会向Remembered Set合并并发标记阶段的变化。这个阶段需要线程停顿，也可以并发执行—-&gt;STW ④筛选回收：对每个Region的回收成本进行排序，按照用户自定义的回收时间来制定回收计划 优点： ①空间整合：G1使用Region独立区域概念，G1利用的是标记复制法，不会产生垃圾碎片 ②分代收集：G1可以自己管理新生代和老年代 ③并行于并发：G1可以通过机器的多核来并发处理 STW停顿，减少停顿时间，并且可不停顿java线程执行GC动作，可通过并发方式让GC和java程序同时执行。 ④可预测停顿：G1除了追求停顿时间，还建立了可预测停顿时间模型，能让制定的M毫秒时间片段内，消耗在垃圾回收器上的时间不超过N毫秒 缺点： G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。</p></blockquote><ul><li>wait/await和sleep区别</li></ul><blockquote><p>（1）两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。 （2）两者都可以暂停线程的执行。 （3）wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。 （4）wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</p></blockquote><ul><li>Redis的LRU过期策略的具体实现 Redis的LRU具体实现</li></ul><blockquote><p>用栈的形式会导致执行select *的时候大量非热点数据占领头部数据，所以需要改进。 Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。 在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。</p></blockquote><ul><li>哪些对象可以作为GC Roots？</li></ul><blockquote><p>（1）虚拟机栈（栈帧中的本地变量表）中引用的对象。 （2）方法区中类静态属性引用的对象。 （3）方法区中常量引用的对象。 （4）本地方法栈中JNI（即一般说的Native方法）引用的对象。</p></blockquote><ul><li>ConcurrentHashMap的数据结构</li></ul><blockquote><p>在JDK1.7版本中，ConcurrentHashMap维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，并且该类里面维护了一个 HashEntry&lt;K,V&gt;[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。在JDK1.8版本中，ConcurrentHashMap摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。</p></blockquote><ul><li>tcp和udp的优点与缺点</li></ul><blockquote><p>（1）TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 （2）TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。 （3）UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… （4）UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输。什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP。</p></blockquote><ul><li>HashMap原理</li></ul><blockquote><p>（1）hashMap 是非线程安全的， hashMap 1.7的底层实现为数组（table[]）＋链表(LinkList–&gt;Entry)，hashmap 1.8底层为数组+链表/红黑树（当链表长度到达阈值TREEIFY_THRESHOLD（默认为8）时，会转化为红黑树）</p></blockquote><ul><li>HashMap的put和resize的过程</li></ul><blockquote><p>（1）put过程： ①查看数组是否需要初始化 ②根据key计算hashcode ③根据hashcode计算出桶位置 ④遍历链表，查看key值与链表节点的key值是否相等，如果相等的话，那么进行覆盖旧值，并返回旧值。1.8的话需要先查看链表长度是否达到阈值，如果达到阈值，先进行红黑树转化然后再进行检查扩容。 ⑤新增的时候需要检查是否需要扩容，需要扩容的话进行两倍扩容，扩容完成后进行插入新值。 （2）resize过程： resize扩容需要从四个方面来进行回答： ①什么时候触发resize? 当容量超过当前容量（默认容量16）乘以负载因子（默认0.75）就会进行扩容，扩容大小为当前大小的两倍（扩展问题，为啥是两倍：通过限制length是一个2的幂数，h &amp; (length-1)和h % length结果是一致的）。 ②resize是如何hash的：h &amp; (length-1) ③resize是如何进行链表操作的：使用头插法进行数据插入，每次新put的值放在头部 ④并发操作下，链表是如何成环的：HashMap的环：若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。</p></blockquote><ul><li>线程池有哪些类型</li></ul><blockquote><p>①FixedThreadPool:创建可重用固定线程数的线程池。 ②SingleThreadPool:创建只有一个线程的线程池。 ③CachedThreadPool:一个可根据需要创建新线程的线程池，如果现有线程没有可用的，则创建一个新线程并添加到池中，如果有被使用完但是还没销毁的线程，就复用该线程。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 ④ScheduledThreadPool：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote><ul><li>ConcurrentHashMap分段锁原理</li></ul><blockquote><p>（1）ConcurrentHashMap采用了分段锁技术，其中Segement继承了RecentLock，当ConcurrentHashMap进行get、put操作时，均是同步的。各个Segement之间的get、put操作可以进行并发，即当一个线程访问ConcurrentHashMap的Segement时，不会影响对其他Segement的访问。</p></blockquote><ul><li>B-树和B+树区别</li></ul><blockquote><p>1）B-树和B树是一个概念，是多路搜索树（相比于二叉搜索树，IO次数更少）。B-树的特性： ①关键字集合分布在整颗树中； ②任何一个关键字出现且只出现在一个结点中； ③搜索有可能在非叶子结点结束； ④其搜索性能等价于在关键字全集内做一次二分查找； ⑤其最底搜索性能为O(logN) （2）B+树是B-树的变体，也是一种多路搜索树 B+的特性： ①所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； ②不可能在非叶子结点命中； ③非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； ④更适合文件索引系统； （3）B+树的优势： ①单一节点存储更多的元素，使得查询的IO次数更少。 ②所有查询都要查找到叶子节点，查询性能稳定。 ③所有叶子节点形成有序链表，便于范围查询。</p></blockquote><ul><li>Mysql数据库索引原理</li></ul><blockquote><p>（1）MyISAM索引实现：MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。 （2）Innodb索引实现： ①第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 ②第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p></blockquote><ul><li>组合索引怎么使用？最左匹配的原理。</li></ul><blockquote><p>1）组合索引怎么使用？ 例如组合索引（a,b,c），组合索引的生效原则是： 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面（范围值也算断点，orderby不算断点，用到索引）的索引部分起作用，断点后面的索引没有起作用； （2）最左匹配的原理：以最左边的为起点任何连续的索引都能匹配上</p></blockquote><ul><li>Spring生命周期</li></ul><blockquote><p>Bean 的生命周期概括起来就是 4 个阶段： （1）实例化（Instantiation） （2）属性赋值（Populate） （3）初始化（Initialization） （4）销毁（Destruction）</p></blockquote><ul><li>Spring几种scope区别？</li></ul><blockquote><p>（1）singleton:Spring的IOC容器中只有一个实例bean，该值为scope的默认值 （2）prototype：每次getBean时都会创建一个新的实例 （3）request:每次请求都会创建一个实体bean （4）session：每次session请求时都会创建一个实体bean （5）globalsession:每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。</p></blockquote><ul><li>Spring AOP实现有哪几种实现</li></ul><blockquote><p>接口代理和类代理会有什么区别？ （1）Spring AOP有两种实现，均为动态代理： ①JDK动态代理：基于反射进行动态代理，核心类是InvocationHandker类和Proxy类，被代理的类必须实现接口 ②CGLIB动态代理：被代理类无需实现接口，主要实现MethodInterceptor接口即可实现代理 （2）Spring AOP如果代理的类存在接口，优先使用JDK动态代理，否则使用CGLIB动态代理。</p></blockquote><ul><li>MVCC,binlog,redolog,undolog都是什么，起什么作用？</li></ul><blockquote><p>（1）undolog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如”把id=’B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id =’B’的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。 （2）redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。 （3）MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。 （4）binlog由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑，比如”把id=’B’ 修改为id = ‘B2’。binlog会写入指定大小的物理文件中,是追加写入的,当前文件写满则会创建新的文件写入。 产生:事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。用于复制和恢复在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用binlog恢复</p></blockquote><ul><li>Kafka是如何实现高吞吐率的？</li></ul><blockquote><p>1）顺序读写：kafka的消息是不断追加到文件中的，这个特性使kafka可以（2）充分利用磁盘的顺序读写性能 （3）零拷贝：跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区” （4）文件分段：kafka的队列topic被分为了多个区partition，每个partition又分为多个段segment，所以一个队列中的消息实际上是保存在N多个片段文件中 （5）批量发送：Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去 （6）数据压缩：Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩</p></blockquote><ul><li>Http请求的完全过程</li></ul><blockquote><p>（1）浏览器根据域名解析IP地址（DNS）,并查DNS缓存 （2）浏览器与WEB服务器建立一个TCP连接 （3）浏览器给WEB服务器发送一个HTTP请求（GET/POST）：一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。 （4）服务端响应HTTP响应报文，报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。 （5）浏览器解析渲染</p></blockquote><ul><li>Spring的@Transactional如何实现的？</li></ul><blockquote><p>（1）配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。 （2）spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。 （3）真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的</p></blockquote><ul><li>为什么要使用线程池？</li></ul><blockquote><p>（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 （2）提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 （3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></blockquote><ul><li>rpc框架实现原理？</li></ul><blockquote><p>主要有以下几个步骤： （1）建立通信： 首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有相关的数据都在这个连接里面进行传输交换。 通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。 （2）服务寻址： 解决寻址的问题：即A机器上的应用A要调用B机器上的应用B，那么此时对于A来说如何告知底层的RPC框架所要调用的服务具体在哪里呢？ 通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。比如基于Web服务协议栈的RPC，就需要提供一个endpoint URI，或者是从UDDI服务上进行查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。 （3）网络传输： ①序列化 当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。 ②反序列化 当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。 （4）服务调用： B机器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。</p></blockquote><ul><li>redis热key怎么解决？</li></ul><blockquote><p>(1)利用二级缓存： 比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。 现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。 (2)备份热key： 这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。</p></blockquote><ul><li>不同年代GC收集器有哪些？</li></ul><blockquote><p>（1）serial收集器：单线程，工作时必须暂停其他工作线程。多用于client机器上，使用复制算法 （2）ParNew收集器：serial收集器的多线程版本，server模式下虚拟机首选的新生代收集器。复制算法 （3）Parallel Scavenge收集器：复制算法，可控制吞吐量的收集器。吞吐量即有效运行时间。 （4）Serial Old收集器：serial的老年代版本，使用整理算法。 （5）Parallel Old收集器：第三种收集器的老年代版本，多线程，标记整理 （6）CMS收集器：目标是最短回收停顿时间。标记清除算法实现，分四个阶段： •初始标记：GC Roots直连的对象做标记 •并发标记：多线程方式GC Roots Tracing •重新标记：修正第二阶段标记的记录 •并发清除。 缺点：标记清除算法的缺点，产生碎片。CPU资源敏感。</p></blockquote><ul><li>ES脑裂问题分析及优化</li></ul><blockquote><p>（1）脑裂问题可能的成因 •网络问题：集群间的网络延迟导致一些节点访问不到master，认为master挂掉了从而选举出新的master，并对master上的分片和副本标红，分配新的主分片 •节点负载：主节点的角色既为master又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。 •内存回收：data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。 （2）脑裂问题解决方案： •减少误判：discovery.zen.ping_timeout节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。 •选举触发 discovery.zen.minimum_master_nodes:1 该参数是用于控制选举行为发生的最小集群主节点数量。 当备选主节点的个数大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为（n/2）+1，n为主节点个数（即有资格成为主节点的节点个数） 增大该参数，当该值为2时，我们可以设置master的数量为3，这样，挂掉一台，其他两台都认为主节点挂掉了，才进行主节点选举。 •角色分离：即master节点与data节点分离，限制角色</p></blockquote><ul><li>讲一讲类加载的过程</li></ul><blockquote><p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载，连接，初始化，具体行为在 Java 虚拟机规范里有非常详细的定义。 （1）首先是加载过程（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，比如 jar 文件，class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。 （2）第二阶段是连接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转入 JVM 运行的过程中。这里可进一步细分成三个步骤：1，验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。2，准备（Pereparation），创建类或者接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显示初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。3，解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在 Java 虚拟机规范中，详细介绍了类，接口，方法和字段等各方面的解析。 （3）最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。再来谈谈双亲委派模型，简单说就是当加载器（Class-Loader）试图加载某个类型的时候，除非父类加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p></blockquote><ul><li>不可重复读和幻读区别</li></ul><blockquote><p>（1）”不可重复读” 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，bai另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 （2）幻觉读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p></blockquote><ul><li>单例对象会被jvm的gc时回收吗</li></ul><blockquote><p>（1）jvm卸载类的判定条件如下： ①该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。 ②加载该类的ClassLoader已经被回收。 ③该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 （2）只有上面三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被卸载。也就是说，只要单例类中的静态引用指向jvm堆中的单例对象，那么单例类和单例对象都不会被垃圾收集，依据根搜索算法，对象是否会被垃圾收集与未被使用时间长短无关，仅仅在于这个对象是不是不可回收的。</p></blockquote><ul><li>Get和Post区别</li></ul><blockquote><p>（1）Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 （2）Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 (3)Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 (4)Get执行效率却比Post方法好。Get是form提交的默认方法。 GET产生一个TCP数据包；POST产生两个TCP数据包。（非必然，客户端可灵活决定）</p></blockquote><ul><li>死锁的4个必要条件</li></ul><blockquote><p>（1）互斥条件：一个资源每次只能被一个线程使用； （2）请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放； （3）不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺； （4）循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</p></blockquote><ul><li>Redis 的数据结构及使用场景</li></ul><blockquote><p>1)String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。 (2)Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对 结构，添加命令：hset key field value。哈希可以用来存放用户信息，比如实现购物车。 (3)List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 (4)Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过 索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (5)Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作</p></blockquote><ul><li>ZAB协议</li></ul><blockquote><p>ZAB协议包括两种基本的模式：崩溃恢复和消息广播。当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。 当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p></blockquote><ul><li>volatile作用</li></ul><blockquote><p>（1）volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。(共享内存，私有内存) （2）volatile关键字通过“内存屏障”来防止指令被重排序。</p></blockquote><ul><li>什么是值传递和引用传递</li></ul><blockquote><p>（1）值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. （2）引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</p></blockquote><ul><li>Java内存模型</li></ul><blockquote><p>Java虚拟机规范中将Java运行时数据分为六种: （1）程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。 （2）Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。 （3）本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。 （4）Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。 （5）方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。 （6）运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。</p></blockquote><ul><li>string.stringbuilder.stringbuffer的区别，为什么string不可变</li></ul><blockquote><p>（1）区别 ①String是字符串常量，而StringBuffer和StringBuilder是字符串变量。由String创建的字符内容是不可改变的，而由StringBuffer和StringBuidler创建的字符内容是可以改变的。 ②StringBuffer是线程安全的，而StringBuilder是非线程安全的。StringBuilder是从JDK 5开始，为StringBuffer类补充的一个单线程的等价类。我们在使用时应优先考虑使用StringBuilder，因为它支持StringBuffer的所有操作，但是因为它不执行同步，不会有线程安全带来额外的系统消耗，所以速度更快。 （2）String为什么不可变： 虽然String、StringBuffer和StringBuilder都是final类，它们生成的对象都是不可变的，而且它们内部也都是靠char数组实现的，但是不同之处在于，String类中定义的char数组是final的，而StringBuffer和StringBuilder都是继承自AbstractStringBuilder类，它们的内部实现都是靠这个父类完成的，而这个父类中定义的char数组只是一个普通是私有变量，可以用append追加。因为AbstractStringBuilder实现了Appendable接口</p></blockquote><ul><li>为什么在重写equals方法的时候要重写hashcode的方法？</li></ul><blockquote><p>（1）我们知道判断的时候先根据hashcode进行的判断，相同的情况下再根据equals()方法进行判断。如果只重写了equals方法，而不重写hashcode的方法，造成hashcode的值不同，而equals()方法判断出来的结果为true。 （2）在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了equals（）的方法，而不重写hashcode的方法，Object中hashcode是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写hashcode方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。</p></blockquote><ul><li>反射的作用是什么？</li></ul><blockquote><p>（1）反射的主要作用是用来扩展系统和动态调用程序集。 （2）所谓扩展系统就是先把系统写好，系统里面定义接口，后面开发的人去写接口的代码。 （3）动态调用程序集就是利用反射去调用编译好的dll，当然此时的dll没有被引用到你所建的工程里面。</p></blockquote><ul><li>同步与异步区别？</li></ul><blockquote><p>（1）同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 （2）异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p></blockquote><ul><li>Java中overload override的区别</li></ul><blockquote><p>（1）Overload是重载的意思，Override是覆盖的意思，也就是重写。 （2）重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中的方法给覆盖了，这也是多态性的一种表现。 （3）重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法可以改变返回值类型。所以，如果两个方法的参数列表完全一样，是不能通过让它们的返回值类型不同来实现重载的。 （4）override是覆盖一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。 （5）overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同类型的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行。 （6）方法的重写和重载是Java多态性的不同表现。重写是父类与子类之间多态性的一种表现，而重载是一个类中多态性的一种表现。</p></blockquote><ul><li>线程的创建方式</li></ul><blockquote><p>（1）继承Thread ①定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 ②创建Thread子类的实例，即创建了线程对象。 ③调用线程对象的start()方法来启动该线程。 （2）实现Runnable接口 ①定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 ②创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 ③调用线程对象的start()方法来启动该线程。 （3）实现Callable接口 ①创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 ②创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 ③使用FutureTask对象作为Thread对象的target创建并启动新线程。 ④调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></blockquote><ul><li>LinkList和ArrayList的区别</li></ul><blockquote><p>（1）ArrayList的底层实现就是数组，且ArrayList实现了RandomAccess，表示它能快速随机访问存储的元素，通过下标 index 访问，只是我们需要用 get() 方法的形式，数组支持随机访问，查询速度快，增删元素慢； （2）LinkedList的底层实现是链表，LinkedList没有实现RandomAccess 接口，链表支持顺序访问，查询速度慢，增删元素快；</p></blockquote><ul><li>垃圾回收算法</li></ul><blockquote><p>（1）标记—清除算法 标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程。 （2）复制算法 复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。 （3）标记—整理算法 复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存</p></blockquote><ul><li>Hashtable 和 HashMap的区别？</li></ul><blockquote><p>（ 1）主要区别在于 HashMap允许将 null作为一个 entry的 key或者 value，而 Hashtable不允许。由于非线程安全，多线程情况下，效率上可能高于 Hashtable。 Hashtable和 HashMap采用的 hash/rehash 算法都大概一样，所以单线程性能不会有很大的差异。 （ 2） Hashtable的方法是 Synchronize的，而 HashMap不是，在多个线程访问 Hashtable时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步 (Collections.synchronizedMap)。 （ 3） HashMap是 Hashtable的轻量级实现（非线程安全的实现），他们都完成了 Map接口， Hashtable继承自 Dictionary类，而 HashMap是 Java1.2引进的 Map interface的一个实现。</p></blockquote><ul><li>servlet的线程安全问题？</li></ul><blockquote><p>答：如果代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。那么我们都知道servlet是多线程的，同时一个servlet实现类只会有一个实例对象，也就是它是Singleton的,所以多个线程是可能会访问同一个servlet实例对象的。同一个实例对象被多个线程访问，如果没有做同步处理，那么servlet就是非线程安全的，如果做了同步处理，就是线程安全。所以，servlet是否线程安全是由它的实现来决定的，如果它内部的属性或方***被多个线程改变，它就是线程不安全的，反之，就是线程安全的。</p></blockquote><ul><li>为什么要用volatile关键字？</li></ul><blockquote><p>答：在高并发时会出现并发模式异常，volatile可以防止指令重排，创建对象操作并不是一个原子操作，分为三个步骤 （1）构建对象：根据Person类元信息确定对象的大小，向JVM堆中申请一块内存区域并构建对象的默认信息(加载Person对象成员变量信息并赋默认值如 int类型为0，引用类型为null)。 （2）初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法。 （3）引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址……</p></blockquote><ul><li>java并发锁机制。</li></ul><blockquote><p>（1）偏向锁：JDK1.6提出来的一种锁优化的机制。其核心的思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就是说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，从而节约了操作时间，如果在此之间有其他的线程进行了锁请求，则锁退出偏向模式 （2）轻量级锁：如果偏向锁失败，Java虚拟机就会让线程申请轻量级锁，轻量级锁在虚拟机内部，使用一个成为BasicObjectLock的对象实现的，这个对象内部由一个BasicLock对象和一个持有该锁的Java对象指针组成。BasicObjectLock对象放置在Java栈帧中。在BasicLock对象内部还维护着displaced_header字段，用于备份对象头部的Mark Word。 （3）重量级锁：当轻量级锁失败，虚拟机就会使用重量级锁。重量级锁在操作过程中，线程可能会被操作系统层面挂起，如果是这样，线程间的切换和调用成本就会大大提高。 （4）自旋锁：它可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。</p></blockquote><ul><li>了解zookeeper的leader选取算法吗，讲一下它的流程。</li></ul><blockquote><p>（1）自增选举轮次。Zookeeper规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对logicalclock进行自增操作。 （2）初始化选票。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为Leader。 （3）发送初始化选票。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper会将刚刚初始化好的选票放入sendqueue中，由发送器WorkerSender负责发送出去。 （4）接收外部投票。每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。 （5）判断选举轮次。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。 ·外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。 ·外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理，并返回步骤4。 ·外部投票的选举轮次等于内部投票。此时可以开始进行选票PK。 （6）选票PK。在进行选票PK时，符合任意一个条件就需要变更投票。 · 若外部投票中推举的Leader服务器的选举轮次大于内部投票，那么需要变更投票。 · 若选举轮次一致，那么就对比两者的ZXID，若外部投票的ZXID大，那么需要变更投票。 · 若两者的ZXID一致，那么就对比两者的SID，若外部投票的SID大，那么就需要变更投票。 （7）变更投票。经过PK后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。 （8）选票归档。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档。recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票。 （9）统计投票。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤（4）。 （10）更新服务器状态。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的Leader服务器是否是自己，若是自己，则将自己的服务器状态更新为LEADING，若不是，则根据具体情况来确定自己是FOLLOWING或是OBSERVING。</p></blockquote><ul><li>双亲委派机制及其使用原因？</li></ul><blockquote><p>（1）当某个特定的类加载器它在接到需要加载类的请求时，这个类会首先查看自己已加载完的类中是否包含这个类，如果有就返回，没有的话就会把加载的任务交给父类加载器加载，以此递归，父类加载器如果可以完成类加载任务，就返回它，当父类加载器无法完成这个加载任务时，才会不得已自己去加载。这种机制就叫做双亲委派机制。 （2）原因： 双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。</p></blockquote><ul><li>treemap和HashMap的区别？</li></ul><blockquote><p>（1）HashMap是通过hashcode()对其内容进行快速查找的；HashMap中的元素是没有顺序的；TreeMap中所有的元素都是有某一固定顺序的，如果需要得到一个有序的结果，就应该使用TreeMap； （2）HashMap继承AbstractMap类；覆盖了hashcode() 和equals() 方法，以确保两个相等的映射返回相同的哈希值；TreeMap继承SortedMap类；他保持键的有序顺序； （3）HashMap：基于hash表实现的；使用HashMap要求添加的键类明确定义了hashcode() 和equals()；为了优化HashMap的空间使用，可以调优初始容量和负载因子；TreeMap：基于红黑树实现的；TreeMap就没有调优选项，因为红黑树总是处于平衡的状态；</p></blockquote><ul><li>java内存泄露解决</li></ul><blockquote><p>堆的dump文件，通过jmx的mbean生产当前 的heap信息， 用eclipse自带的静态分析工具Mat（windDBG）打开 分析内存泄露：那些被怀疑为内存泄露，哪些占用空间大，对象调用关系</p></blockquote><ul><li>分布式锁的实现原理和有多少种实现方式？</li></ul><blockquote><p>目前主流的分布式锁的实现方式有三种： ①借助数据库来实现，新建一张锁表； 操作前向表添加一条锁记录（锁id建立唯一索引），成功添加者获得锁权限，处理完后删除锁记录来释放锁。 ②基于缓存实现，如memcache 和 redis； memcache的add操作具有原子性，可以保证同一个key add操作只有一个成功，来获取锁权限，利用缓存的失效时间来解决死锁问题。相对于第一种方案，这种方案性能更好，而且操作更方便。 ③通过zookeeper实现； 客户端会在zookeeper生成一个临时的目录节点，存储在一个序列中，每次节点序号最小的节点对应的客户端获得锁，处理完成后删除最小节点，而且可重复获取锁（通过判断序号是否和最小的节点相同）。这种方式可以实现阻塞分布式锁，和锁的重复获取问题。</p></blockquote><ul><li>HashMap和Hashtable的区别</li></ul><blockquote><p>主要的区别有：线程安全性，同步，以及速度。 （1）HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 （2）另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p></blockquote><ul><li>HashMap中是否任何对象都可以做为key,用户自定义对象做为key有没有什么要求？</li></ul><blockquote><p>用自定义类作为key，必须重写equals()和hashCode()方法。 自定义类中的equals() 和 hashCode()都继承自Object类。 Object类的hashCode()方法返回这个对象存储的内存地址的编号。 而equals()比较的是内存地址是否相等。</p></blockquote><ul><li>对sql进行优化的原则有哪些？</li></ul><blockquote><p>（1）减少返回不必要的数据 （2）减少物理和逻辑读次数 （3）减少计算次数</p></blockquote><ul><li>String和StringBuffer的区别</li></ul><blockquote><p>1）运行速度：StringBuilder &gt;StringBuffer &gt;String String是字符串常量，不可变，每次改变只是创建一个新的对象，然后GC回收掉老的那个，所以执行速度最慢，另外两个是字符串对象，可变。 （2）线程安全： StringBuilder是线程不安全的，StringBuffer是线程安全的，看是否带synchronized关键字。多线程则采用StringBuffer，单线程则要建议用速度较快的StringBuilder。 （3）String：适用于少量的字符串操作的情况，String是final类，无法被继承。StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况。 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。</p></blockquote><ul><li>如果A和B对象循环引用，是否可以被GC？</li></ul><blockquote><p>答：这个循环引用是否被回收，就看这个循环引用是否挂在根上，A引用B，B引用A，A和Ｂ并没有挂在某个内存元和根上，当他们的生命周期结束的时候。这两个对象都有可能被回收。</p></blockquote><ul><li>Error、Exception和RuntimeException的区别，作用又是什么？</li></ul><blockquote><p>Error是Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error的任何子类，因为这些错误可能是再也不会发生的异常条件。 Exception类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException 的任何子类都无需在 throws 子句中进行声明。它是Exception的子类。</p></blockquote><ul><li>reader和inputstream区别</li></ul><blockquote><p>（1）InputStream是表示字节输入流的所有类的超类；Reader是用于读取字符流的抽象类 （2）InputStream提供的是字节流的读取，而非文本读取，这是和Reader类的根本区别。 即用Reader读取出来的是char数组或者String ，使用InputStream读取出来的是byte数组。</p></blockquote><ul><li>hashCode的作用；</li></ul><blockquote><p>hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p></blockquote><ul><li>Java中的内存溢出是如何造成的？</li></ul><blockquote><p>（1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据； （2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； （3）代码中存在死循环或循环产生过多重复的对象实体； （4）使用的第三方软件中的BUG； （5）启动参数内存值设定的过小；</p></blockquote><ul><li>springMVC的工作原理图</li></ul><blockquote><p>（1）客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配 DispatcherServlet的请求映射路径（在web.xml中指定）， web容器将请求转交给DispatcherServlet； （2）DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请 求参数Cookie等） 以及HandlerMapping的配置找到处理请求的处理器（Handler）； （3）DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将 具体的处理进行封装）， 再由具体的HandlerAdapter对Handler进行具体的调用。 （4）Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet； （5）Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过 ViewResolver将逻辑视图转化为真正的视图View； （6）Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端；</p></blockquote><ul><li>RPC框架和普通http有什么区别和优势？</li></ul><blockquote><p>基于Tcp封装还是http封装的？ （1）1、RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。 （2）RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。 （3）HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。 （4）HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。 （5）HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。 （6）HTTP需要事先通知，修改Nginx/HAProxy配置。RPC能做到自动通知，不影响上游。 （7）HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。</p></blockquote><ul><li>GC的基本原理？什么时候需要GC？为什么需要GC？</li></ul><blockquote><p>GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停 （1）对新生代的对象的收集称为minor GC； （2）对旧生代的对象的收集称为Full GC； （3）程序中主动调用System.gc()强制执行的GC为Full GC。 不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型： （1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收） （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC） （3）弱引用：在GC时一定会被GC回收 （4）虚引用：由于虚引用只是用来得知对象是否被GC</p></blockquote><ul><li>怎样避免死锁？</li></ul><blockquote><p>（1）破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。 （2）破坏”请求与保持条件”：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。 （3）破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程</p></blockquote><ul><li>BEAN的生命周期</li></ul><blockquote><p>（1）应用启动的时候检查加载需要被Spring管理的bean. （2）根据实现的接口，依次设置beanName，BeanFactory，ApplicationContext应用上下文。 （3）根据实现的接口，依次调用加载前，设置值，自定义初始化方法，加载完成后。 （4）bean已经可以用了，存活直到上下文也被销毁。 （5）销毁的时候调用destroy方法和自定义的销毁方法。</p></blockquote><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://github.com/zhendiao/JavaInterview"> JavaInterview</a></p><p><a href="https://github.com/CyC2018/CS-Notes">CS-Notes</a></p><p><a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小马哥代码学习记录</title>
      <link href="2021/03/07/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%B0%8F%E9%A9%AC%E5%93%A5%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2021/03/07/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%B0%8F%E9%A9%AC%E5%93%A5%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 数据校验</title>
      <link href="2021/03/06/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%9B%9B%E8%8A%82%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
      <url>2021/03/06/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E5%9B%9B%E8%8A%82%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><p>Java EE 项目 - 第四节 数据校验 </p><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者<strong>议题</strong> </p><p>• Apache commons-validator </p><p>• Bean Validation 1.0（JSR-303） </p><p>• 问答互动</p><p><strong>Apache commons-validator</strong> </p><p>• 简介 </p><p>A common issue when receiving data either electronically or from user input </p><p>is verifying the integrity of the data. This work is repetitive and becomes even </p><p>more complicated when different sets of validation rules need to be applied </p><p>to the same set of data based on locale. Error messages may also vary by </p><p>locale. This package addresses some of these issues to speed development </p><p>and maintenance of validation rules.</p><p><strong>Apache commons-validator</strong> </p><p>• 功能特性 </p><p>• 可配置的校验引擎 </p><p>• 可重用的原生校验手段 </p><p>• 第三方依赖 </p><p>• commons-beanutils </p><p>• commons-digester </p><p>• commons-logging </p><p>• commons-collections</p><p><strong>Apache commons-validator</strong> </p><p>• 验证器类型 </p><p>• Date 与 Time 校验器 </p><p>• 数值校验器 </p><p>• 正则表达式校验器 </p><p>• ISBN校验器 </p><p>• IP 地址校验器 </p><p>• 邮件地址校验器 </p><p>• URL 校验器 </p><p>• 域名校验器</p><p><strong>Apache commons-validator</strong> </p><p>• Date 与 Time 校验器 </p><p>• API </p><p>• org.apache.commons.validator.routines.DateValidator </p><p>• org.apache.commons.validator.routines.CalendarValidator </p><p>• org.apache.commons.validator.routines.TimeValidator </p><p>• 使用场景 </p><p>• 校验 </p><p>• 格式化 </p><p>• 时区 </p><p>• 比较</p><p><strong>Apache commons-validator</strong> </p><p>• 数值校验器（Numberic） </p><p>• API </p><p>• org.apache.commons.validator.routines.ByteValidator </p><p>• org.apache.commons.validator.routines.ShortValidator </p><p>• org.apache.commons.validator.routines.IntegerValidator </p><p>• org.apache.commons.validator.routines.LongValidator </p><p>• org.apache.commons.validator.routines.FloatValidator </p><p>• org.apache.commons.validator.routines.DoubleValidator </p><p>• org.apache.commons.validator.routines.BigIntegerValidator </p><p>• org.apache.commons.validator.routines.BigDecimalValidator </p><p>• org.apache.commons.validator.routines.CurrencyValidator</p><p><strong>Apache commons-validator</strong> </p><p>• 其他校验器 </p><p>• API </p><p>• org.apache.commons.validator.routines.RegexValidator </p><p>• org.apache.commons.validator.routines.CodeValidator </p><p>• org.apache.commons.validator.routines.ISBNValidator </p><p>• org.apache.commons.validator.routines.InetAddressValidator </p><p>• org.apache.commons.validator.routines.EmailValidator </p><p>• org.apache.commons.validator.routines.UrlValidator </p><p>• org.apache.commons.validator.routines.DomainNameValidator</p><p><strong>Bean Validation 1.0**</strong>（JSR-303）** </p><p>• 介绍 </p><p>Java API for JavaBean validation in Java EE and Java SE. The technical objective of </p><p>this work is to provide a class level constraint declaration and validation facility </p><p>for the Java application developer, as well as a constraint metadata repository and </p><p>query API. </p><p>• 规范版本 </p><p>• 2009.10.12 Bean Validation 1.0（JSR-303） </p><p>• 2013.04.10 Bean Validation 1.1（JSR-349） </p><p>• 2017.06.21 Bean Validation 2.0.0.CR1（JSR-380）</p><p><strong>Bean Validation 1.0**</strong>（JSR-303）** </p><p>• 常用注解 </p><p>• @Valid </p><p>• @NotNull </p><p>• @Null </p><p>• @Size </p><p>• @Min </p><p>• @Max</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>通过课堂上简易版的依赖注入和依赖查找，实现用户注册功能</p><ul><li>通过UserService实现用户注册【依赖注入】</li><li>注册用户时，需要校验<ul><li>密码6-32位</li><li>id必须是大于0的整数</li><li>电话号码采用中文的方式【十一位校验】</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 配置管理与 Java Logging</title>
      <link href="2021/03/06/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%BA%94%E8%8A%82%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B8%8E%20Java%20Logging/"/>
      <url>2021/03/06/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%BA%94%E8%8A%82%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B8%8E%20Java%20Logging/</url>
      
        <content type="html"><![CDATA[<p>小马哥的 Java 项目实战营 </p><h1 id="Java-EE-项目-第五节-配置管理与-Java-Logging"><a href="#Java-EE-项目-第五节-配置管理与-Java-Logging" class="headerlink" title="Java EE 项目 - 第五节 配置管理与 Java Logging"></a>Java EE 项目 - 第五节 配置管理与 Java Logging</h1><p>小马哥（mercyblitz）</p><p><strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者<strong>议题</strong> </p><p>• 配置管理 </p><p>• Java Logging </p><p>• 问答互动</p><p><strong>配置管理</strong> </p><h2 id="•-简介"><a href="#•-简介" class="headerlink" title="• 简介"></a>• 简介</h2><p>配置（Configuration）是应用程序重要的元信息（Metadata），几乎所有软件依 </p><p>赖配置调控程序行为，比如 MySQL 中的 my.ini 文件，Apache Maven 的配置文件 </p><p>settings.xml 文件，以及其项目管理文件 pom.xml。尽管配置常以文件的形式承载， </p><p>然而并仅限于此。根据配置所处的物理位置，可分为本地配置（Local </p><p>Configuration）和远程配置（Remote Configuration）。其中，本地配置相对于 </p><p>程序的位置主要包括“内部配置（Internal Configuration）”以及“外部配置 </p><p>（External Configuration）”，而远程配置则有“版本化配置（Versioned </p><p>Configuration）”和“分布式配置（Distributed Configuration）”等实现。</p><p><strong>配置管理</strong> </p><h2 id="•-本地配置（Local-Configuration）"><a href="#•-本地配置（Local-Configuration）" class="headerlink" title="• 本地配置（Local Configuration）"></a>• 本地配置（Local Configuration）</h2><p>顾名思义，本地配置即配置存放在应用程序所在的物理环境，比如程序内部、物理机 </p><p>器或虚拟化容器。存放在程序进程内部的配置称之为“内部配置（Internal </p><p>Configuration）”，相反则是“外部配置（External Configuration）”。</p><p><strong>配置管理</strong> </p><h2 id="•-内部配置（Internal-Configuration）"><a href="#•-内部配置（Internal-Configuration）" class="headerlink" title="• 内部配置（Internal Configuration）"></a>• 内部配置（Internal Configuration）</h2><p>通常，内部配置是通过程序代码，甚至是硬编码（Hard Code）实现。虽然不推荐程 </p><p>序使用硬编码来初始化配置，然而这并非是不可原谅的做法，如：</p><p>![image-20210311200112943](/Users/cutie/Library/Application Support/typora-user-images/image-20210311200112943.png)</p><p><strong>配置管理</strong> </p><p>• 内部配置（Internal Configuration） </p><p>内部配置并未与硬编码（Hard-Code）划上等号，如 Java 8 引入的共享线程池 </p><p>java.util.concurrent.ForkJoinPool#commonPool()：</p><p>![image-20210311200130987](/Users/cutie/Library/Application Support/typora-user-images/image-20210311200130987.png)</p><p><strong>配置管理</strong> </p><h2 id="•-外部配置（External-Configuration）"><a href="#•-外部配置（External-Configuration）" class="headerlink" title="• 外部配置（External Configuration）"></a>• 外部配置（External Configuration）</h2><p>外部配置是软件使用者、开发者以及运维者最常见和熟悉的配置手段，正如前文提到 </p><p>的 MySQL my.ini 文件等。在 Java 生态体系中，JDK 层面允许程序读取来自 Java </p><p>System Properties、操作系统环境变量以及 JNDI 等多方配置来源。</p><p>![image-20210311200143438](/Users/cutie/Library/Application Support/typora-user-images/image-20210311200143438.png)</p><p><strong>配置管理</strong> </p><h2 id="•-远程配置（Remote-Configuration）"><a href="#•-远程配置（Remote-Configuration）" class="headerlink" title="• 远程配置（Remote Configuration）"></a>• 远程配置（Remote Configuration）</h2><p>在分布式场景中，远程配置的内容来自于配置运用端程序进程物理环境以外的环境， 其作用相当重要，是大多数互联网企业的基础设施标配，大多数实现采用 C/S（客户 端/服务器）架构。C/S 架构广义地包含了 B/S（浏览器/服务器）架构，这两种实现 均采用 B/S 架构，属于“分布式配置（Distributed Configuration）B/S 架构，然 而都归类于“分布式配置实现，即应用需要依赖一个专属的 HTTP 客户端，通过访问 远端的 Web 服务器获取配置。实现上，配置客户端版本化配置（Versioned Configuration）”。</p><p>• Java 标准外部化配置 </p><p>• Java SE </p><p>• Java 系统属性 - java.lang.System#getProperties() </p><p>• 操作系统环境变量 - java.lang.System#getenv() </p><p>• 偏好配置 - java.util.prefs.Preferences </p><p>• Java EE </p><p>• Servlet 上下文配置 - javax.servlet.ServletContext#getInitParameter(String) </p><p>• Servlet 配置 - javax.servlet.ServletConfig#getInitParameter(String) </p><p>• JSP 配置 - javax.servlet.descriptor.JspConfigDescriptor </p><p>• JNDI 配置 - javax.naming.Context#lookup(javax.naming.Name) </p><p><strong>配置管理</strong></p><h2 id="•-Apache-通用配置开源框架-Apache-Commons-Configuration"><a href="#•-Apache-通用配置开源框架-Apache-Commons-Configuration" class="headerlink" title="• Apache 通用配置开源框架 - Apache Commons Configuration"></a>• Apache 通用配置开源框架 - Apache Commons Configuration</h2><p>• 支持数据源 </p><p>• Properties files </p><p>• XML documents </p><p>• Windows INI files </p><p>• Property list files (plist) </p><p>• JNDI </p><p>• JDBC Datasource </p><p>• System properties </p><p>• Applet parameters </p><p>• Servlet parameters </p><p><strong>配置管理</strong></p><h2 id="•-Apache-Commons-Configuration-1-x-配置源"><a href="#•-Apache-Commons-Configuration-1-x-配置源" class="headerlink" title="• Apache Commons Configuration 1.x - 配置源"></a>• Apache Commons Configuration 1.x - 配置源</h2><p>• 接口信息 </p><p>• PropertiesConfiguration Loads configuration values from a properties file </p><p>• XMLConfiguration Takes values from an XML document </p><p>• INIConfiguration Loads the values from a .ini file as used by Windows </p><p>• PropertyListConfiguration Loads values from an OpenStep .plist file </p><p>• JNDIConfiguration Using a key in the JNDI tree, can retrieve values </p><p>• BaseConfiguration An in-memory method of populating a Configuration object </p><p>• HierarchicalConfiguration An in-memory Configuration object </p><p>• SystemConfiguration A configuration using the system properties </p><p><strong>配置管理</strong></p><h3 id="•-Apache-Commons-Configuration-1-x-数据类型"><a href="#•-Apache-Commons-Configuration-1-x-数据类型" class="headerlink" title="• Apache Commons Configuration 1.x - 数据类型"></a>• Apache Commons Configuration 1.x - 数据类型</h3><p>• BigDecimal </p><p>• BigInteger </p><p>• boolean </p><p>• byte </p><p>• double </p><p>• float </p><p>• int </p><p>• long </p><p>• short </p><p>• String </p><p><strong>配置管理</strong></p><h3 id="•-Apache-Commons-Configuration-1-x-操作方法"><a href="#•-Apache-Commons-Configuration-1-x-操作方法" class="headerlink" title="• Apache Commons Configuration 1.x - 操作方法"></a>• Apache Commons Configuration 1.x - 操作方法</h3><p>• addProperty() </p><p>• Adds a new property to the configuration. If this property already exists, another value is </p><p>added to it (so it becomes a multi-valued property) </p><p>• clearProperty() </p><p>• Removes the specified property from the configuration </p><p>• setProperty() </p><p>• Overwrites the value of the specified property. This is the same as removing the property and </p><p>then calling addProperty() with the new property value. </p><p>• clear() </p><p>• Wipes out the whole configuration</p><p><strong>配置管理</strong></p><h3 id="•-Apache-Commons-Configuration-1-x-使用"><a href="#•-Apache-Commons-Configuration-1-x-使用" class="headerlink" title="• Apache Commons Configuration 1.x - 使用"></a>• Apache Commons Configuration 1.x - 使用</h3><p>• Maven 坐标 </p><dependency> <p><groupid>commons-configuration</groupid> </p><p><artifactid>commons-configuration</artifactid> </p><p><version>1.10</version> </p></dependency> <p>• 依赖 </p><p>• <a href="http://commons.apache.org/proper/commons-">http://commons.apache.org/proper/commons-</a> </p><p>configuration/dependencies_1_10.html [点击访问] </p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a><strong>配置管理</strong></h2><h2 id="Java-Logging"><a href="#Java-Logging" class="headerlink" title="Java Logging"></a><strong>Java Logging</strong></h2><h3 id="•-简介-1"><a href="#•-简介-1" class="headerlink" title="• 简介"></a>• 简介</h3><p>Java日志API，在包中介绍java.util.logging文件，通过生成适合最终用户、系统管理 </p><p>员、现场服务工程师和软件开发团队分析的日志报告，促进客户站点的软件服务和维护。 </p><p>日志api捕获应用程序或平台中的安全故障、配置错误、性能瓶颈和/或bug等信息。 </p><p>核心包支持将纯文本或XML格式的日志记录传递到内存、输出流、控制台、文件和套 </p><p>接字。此外，日志API能够与主机操作系统上已经存在的日志服务进行交互。</p><p><strong>Java Logging</strong> </p><h3 id="•-控制流程"><a href="#•-控制流程" class="headerlink" title="• 控制流程"></a>• 控制流程</h3><p>应用程序对 Logger 对象进行日志记录调用。记录器被组织在一个层次化的名称空间 </p><p>中，子记录器可以从名称空间中的父记录器继承一些日志属性。 </p><p>应用程序对 Logger 对象进行日志记录调用。这些 Logger 对象分配传递给处理程序 </p><p>对象以供发布的 LogRecord 对象。 Loggers 和 Handlers 都可以使用日志级别（Levels） </p><p>和（可选） Filters 来决定是否对特定的 LogRecord 感兴趣。当需要在外部发布 </p><p>LogRecord 时，Handlers 可以（可选）使用 Formatter 在将消息发布到 I/O 流之前对 </p><p>其进行本地化和格式化。</p><p><strong>Java Logging</strong> </p><p>• 控制流程</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210311200249.png" alt="image-20210311200239446"></p><p><strong>Java Logging</strong> </p><h3 id="•-日志级别（Levels）"><a href="#•-日志级别（Levels）" class="headerlink" title="• 日志级别（Levels）"></a>• 日志级别（Levels）</h3><p>每个日志消息都有一个关联的日志级别。该级别粗略地说明了日志消息的重要性和紧 </p><p>迫性。日志级对象封装了一个整数值，值越大表示优先级越高。 </p><p>Level类定义了七个标准日志级别，从FINEST（最低优先级，具有最低值）到SEVERE </p><p>（最高优先级，具有最高值）。 </p><p>API - java.util.logging.Level</p><p><strong>Java Logging</strong> </p><p>• 日志级别（Levels） </p><p>每个日志消息都有一个关联的日志级别。该级别粗略地说明了日志消息的重要性和紧迫 </p><p>性。日志级对象封装了一个整数值，值越大表示优先级越高。 </p><p>Level类定义了七个标准日志级别，从FINEST（最低优先级，具有最低值）到SEVERE </p><p>（最高优先级，具有最高值）。 </p><p>API - java.util.logging.Level</p><p><strong>Java Logging</strong> </p><h3 id="•-日志对象（Loggers）"><a href="#•-日志对象（Loggers）" class="headerlink" title="• 日志对象（Loggers）"></a>• 日志对象（Loggers）</h3><p>客户机代码向 Logger 对象发送日志请求。每个 Logger 都跟踪它感兴趣的日志级别， </p><p>并丢弃低于此级别的日志请求。 </p><p>Logger 通常使用 “.” 分隔名称（如”java.awt”. 名称空间是分层的，由 LogManager管 </p><p>理。名称空间通常应与Java打包名称空间保持一致，但不需要盲目跟随。 </p><p>Logger 在记录名称空间中记录其父 Logger。Logger 的父级是其在记录名称空间中最 </p><p>接近的现有祖先。根日志程式（名称为””）没有父级。匿名日志记录者都被授予根日志记 </p><p>录者作为其父。</p><p><strong>Java Logging</strong> </p><p>• 日志对象（Loggers） </p><p>Logger 可从其在记录者名称空间中的父类继承各种属性。特别是， Logger 可继承： </p><p>• Levels - 如果一Logger的level设置为空，则该Logger将使用一个有效的level，该level将通过走上父树并 </p><p>使用第一个非空level获得。 </p><p>• Handlers - 默认情况下， Logger 会将任何输出消息记录到其父级的 Handlers 中，依此在树中循环上升。 </p><p>• ResourceBundle 名称 - 如果 Logger 的资源包名称为空，则其将继承为其父级定义的任何资源包名称， </p><p>依此在树上循环。</p><p><strong>Java Logging</strong> </p><h3 id="•-日志处理器（Handlers）"><a href="#•-日志处理器（Handlers）" class="headerlink" title="• 日志处理器（Handlers）"></a>• 日志处理器（Handlers）</h3><p>Java SE 提供以下日志处理器实现： </p><p>• StreamHandler - 一个简单的处理程序，用于将格式化记录写入OutputStream </p><p>• ConsoleHandler - 向其写入格式记录的简单处理程序System.err </p><p>• FileHandler - 将已格式化的日志记录写入一个文件或一组循环日志文件的处理程序 </p><p>• SocketHandler - 将已格式化的日志记录写入远程TCP端口的处理程序 </p><p>• MemoryHandler - 在内存中缓冲日志记录的处理程序</p><p><strong>Java Logging</strong> </p><h3 id="•-日志格式化器（Formatters）"><a href="#•-日志格式化器（Formatters）" class="headerlink" title="• 日志格式化器（Formatters）"></a>• 日志格式化器（Formatters）</h3><p>Java SE 提供两种 Formatter 实现： </p><p>• SimpleFormatter - 编写简要的“人类可读”的日志记录摘要 </p><p>• XMLFormatter - 编写详细的XML结构信息</p><p><strong>Java Logging</strong> </p><h3 id="•-日志管理器（LogManager）"><a href="#•-日志管理器（LogManager）" class="headerlink" title="• 日志管理器（LogManager）"></a>• 日志管理器（LogManager）</h3><p>全局的 LogManager 对象，用于跟踪全局日志记录信息。LogManager 对象可以使用 </p><p>静态 LogManager.getLogManager 方法获得。在 LogManager 初始化期间根据系统属 </p><p>性创建的。此属性允许容器应用程序（如EJB容器）用其自身的LogManager子类代替默认 </p><p>类。</p><p>LogManager 对象包括： </p><p>• 命名的 Logger 分层名称空间 </p><p>• 从配置文件中读取的一组日志记录控制属性</p><p><strong>Java Logging</strong> </p><h3 id="•-日志配置文件（Configuration-File）"><a href="#•-日志配置文件（Configuration-File）" class="headerlink" title="• 日志配置文件（Configuration File）"></a>• 日志配置文件（Configuration File）</h3><p>在启动时读取的日志配置文件来初始化日志配置。此日志配置文件为标准 </p><p>java.util.Properties 格式。或者，可以通过指定可用于读取初始化属性的类来初始化日志 </p><p>记录配置。此机制允许从任意源（如LDAP、JDBC等）读取配置数据。有关详细信息，请 </p><p>参阅LogManager API规范。 </p><p>有一小部分全局配置信息。这在 LogManager 类的描述中指定，并包括在启动期间安装 </p><p>的根级别处理程序列表。 </p><p>初始配置可指定特定记录者的级别。这些级别应用于命名层次结构中的命名日志记录程 </p><p>序及其下的任何日志记录程序。级别按在配置文件中定义的顺序应用。</p><p><strong>Java Logging</strong> </p><h3 id="•-日志默认配置（Default-Configuration）"><a href="#•-日志默认配置（Default-Configuration）" class="headerlink" title="• 日志默认配置（Default Configuration）"></a>• 日志默认配置（Default Configuration）</h3><p>JRE附带的默认日志记录配置仅为一个默认值，并可由ISV、系统管理员和最终用户覆盖 </p><p>默认配置仅使用有限的磁盘空间。它不会向用户大量提供信息，但确保始终获取关键故 </p><p>障信息</p><p>默认配置在根日志记录程序上建立一个处理程序，用于向控制台发送输出</p><p><strong>Java Logging</strong> </p><h3 id="•-日志动态配置更新（Dynamic-Configuration-Updates）"><a href="#•-日志动态配置更新（Dynamic-Configuration-Updates）" class="headerlink" title="• 日志动态配置更新（Dynamic Configuration Updates）"></a>• 日志动态配置更新（Dynamic Configuration Updates）</h3><p>程序能够在运行期动态地更新以下配置： </p><p>• FileHandlers, MemoryHandlers, 和 ConsoleHandlers 动态创建和属性更新 </p><p>• Handlers 能被动态地添加或移除 </p><p>• 新的 Logger 对象能被动态地创建，并能关联指定的 Handlers </p><p>• 特定 Handlers 上的级别能被动态地设置</p><p><strong>Java Logging</strong> </p><h3 id="•-日志本地化（Localization）"><a href="#•-日志本地化（Localization）" class="headerlink" title="• 日志本地化（Localization）"></a>• 日志本地化（Localization）</h3><p>日志消息可能需要本地化。 </p><p>每个 Logger 可能有一个与其相关联的资源包名称。相应的资源包可用于在原始消息串 </p><p>和本地化消息串之间进行映射。 </p><p>通常，本地化将由 Formatter 执行。为方便起见， Formatter 类提供了一个提供一些基 </p><p>本本地化和格式设置支持的 Format 消息方法。</p><h2 id="配置管理-1"><a href="#配置管理-1" class="headerlink" title="配置管理"></a>配置管理</h2><h3 id="设计技巧"><a href="#设计技巧" class="headerlink" title="设计技巧"></a>设计技巧</h3><p>有限读取外部配置（存在多来源，可能存在优先级），将内部配置作为默认（兜底）策略</p><p>当存在多外源外部配置时候，员作用范围岳晓，通常越优先，比如Java System#getProperties()（当前JVM进程）和操作系统环境变量（当前用户或者系统共享）</p><h3 id="整合MicroProfile-Config"><a href="#整合MicroProfile-Config" class="headerlink" title="整合MicroProfile Config"></a>整合MicroProfile Config</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 数据存储之 JDBC</title>
      <link href="2021/02/27/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B-JDBC/"/>
      <url>2021/02/27/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%BA%8C%E8%8A%82-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B-JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="小马哥的-Java-项目实战营-Java-EE-项目-第二节-数据存储之-JDBC"><a href="#小马哥的-Java-项目实战营-Java-EE-项目-第二节-数据存储之-JDBC" class="headerlink" title="小马哥的 Java 项目实战营  Java EE 项目 - 第二节 数据存储之 JDBC"></a>小马哥的 Java 项目实战营  Java EE 项目 - 第二节 数据存储之 JDBC</h1><h2 id="Java-Database-Connectivity（JDBC）"><a href="#Java-Database-Connectivity（JDBC）" class="headerlink" title="Java Database Connectivity（JDBC）"></a>Java Database Connectivity（JDBC）</h2><p>• 概念 </p><p>JDBC(Java DataBase Connectivity,java数据库连接)是一种用于执行SQL语句的Java API， </p><p>可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提 </p><p>供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应 </p><p>用程序，同时，JDBC也是个商标名。（文字来源 - 360 百科） </p><p>JDBC 是 Java 针对关系型数据库的底层 API，也是 iBatis（MyBatis）、JDO、Hibernate、 </p><p>JPA 等高层框架的基石。</p><h2 id="JDBC-4-0-主要特征"><a href="#JDBC-4-0-主要特征" class="headerlink" title="JDBC 4.0 主要特征"></a>JDBC 4.0 主要特征</h2><p>• 面向数据表行列编程 </p><p>• 驱动程序需要数据库定制（MySQL、Oracle） </p><p>• SQL 语法与目标数据库保持一致 </p><p>• 事务（需要数据库支持） </p><p>• 数据库元信息（数据库信息、表结构信息等）</p><h2 id="JDBC-核心-API"><a href="#JDBC-核心-API" class="headerlink" title="JDBC 核心 API"></a>JDBC 核心 API</h2><h3 id="数据源接口-javax-sql-DataSource"><a href="#数据源接口-javax-sql-DataSource" class="headerlink" title="数据源接口 - javax.sql.DataSource"></a>数据源接口 - javax.sql.DataSource</h3><p>接口 - javax.sql.DataSource </p><p>获取方式</p><ul><li>普通对象初始化<ul><li>Spring Bean</li><li>API实现</li></ul></li><li>JNDI 依赖查找</li><li></li></ul><p>举例：</p><p>comons.apache.</p><p>主流DataSource实现</p><ul><li>DBCP 1/2<ul><li>间接依赖 - Apache Commons Pool<ul><li>对象池的概念<ul><li>池化 - 肉少狼多，肉 - 资源，狼 - 消费者<ul><li>特点：有借有还</li><li>核心编程思想：生产者/消费者模型</li><li>资源：线程资源，数据库资源【分表很多，分库并不多，分库问题：局部可用】，I/O资源</li><li>举例：线程池，数据库连接池【都和线程有关系】【单例的还是原生的，原生的每次都是一个新的实例】</li></ul></li></ul></li></ul></li></ul></li><li>C3P0（字节码提升/优化）</li><li>Alibaba Druid（字节码提升/优化）</li></ul><h3 id="JDBC-驱动接口-java-sql-Driver"><a href="#JDBC-驱动接口-java-sql-Driver" class="headerlink" title="JDBC 驱动接口 - java.sql.Driver"></a>JDBC 驱动接口 - java.sql.Driver</h3><p>acceptsURL ：尝试连接，是否成功</p><p>DriverPropertiesInfo：属性</p><p>getMarjorVersion（）：API版本属性比较关键的时候使用，以及getMinorVersion（）</p><p>jdbcCompliant：jdbc是否兼容</p><p>一般使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"org.apache.derby.jdbc.EmbeddedDriver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注册Driver到DriverManager中</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">setLogWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//通过ClassLoader加载Java.sql.DriverManager  -&gt; static{}</span><span class="token class-name">Driver</span> driver <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getDriver</span><span class="token punctuation">(</span><span class="token string">"jdbc:derby:/db/user-platform;create=true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>driver<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token string">"jdbc:derby:/db/user-platform;create=true"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="驱动管理器接口-java-sql-DriverManager"><a href="#驱动管理器接口-java-sql-DriverManager" class="headerlink" title="驱动管理器接口 - java.sql.DriverManager"></a>驱动管理器接口 - java.sql.DriverManager</h3><p>管理器的角色</p><ul><li>registerDriver()<ul><li>JDBC规范中，Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”); 需要驱动自己进行主动注册</li></ul></li></ul><ul><li>获取Driver实现的方式【下面是顺序】<ul><li>前提：数据库驱动Driver实现会显示地调用registerDriver()方法</li><li>通过ClassLoader去加载Driver实现【用户/应用控制】【1】</li><li>通过java SPI serviceLoader获取Driver实现【2】<ul><li>ServiceLoader会初始化Driver实现类（应用主动配置），包含Class加载</li></ul></li><li>通过jdbc.driver 系统属性【3】<ul><li>通过读取“jcbc.driver”系统属性后，在经过“：”分割，尝试获取多值，在通过ClassLoader加载对应的实现类</li></ul></li></ul></li></ul><ul><li>获取Connection<ul><li>通过ClassLoader类加载数据库JDBC Driver 实现类的方式，增加java.sql.DriverManager#registeredDrivers字段的元素，然后通过迭代的方式逐一getConnection方法参数的JDBC URL是否可用。</li></ul></li></ul><h3 id="数据连接接口-java-sql-Connection"><a href="#数据连接接口-java-sql-Connection" class="headerlink" title="数据连接接口 - java.sql.Connection"></a>数据连接接口 - java.sql.Connection</h3><ul><li>相近语义术语<ul><li>一个JDBC相当于MyBatis中的Session或者Hibernate的Session</li></ul></li></ul><h3 id="SQL-命令接口-java-sql-Statement"><a href="#SQL-命令接口-java-sql-Statement" class="headerlink" title="SQL 命令接口 - java.sql.Statement"></a>SQL 命令接口 - java.sql.Statement</h3><p>主要类型</p><ul><li><p>创建SQL命令 - Statement【都是接口】</p><ul><li>普通SQL命令 - java.sql.Statement</li><li>预编译SQL命令 - java.sql.PreparedStatement</li><li>存储过程SQL命令 - java.sql.CallableStatement</li></ul></li><li><p>DDL语句和DML语句</p><ul><li>DML语句：CRUD<ul><li>R: java.sql.Statement#executeQuery</li><li>CUD： java.sql.Statement#executeUpdate</li></ul></li><li>DDL<ul><li>java.sql.Statement#execute<ul><li>成功的话，不需要返回值（返回false）。创建过程中，失败是一个异常，成功的话返回true或者false都没有意义，为什么？</li><li>失败的话，抛出SQLException</li></ul></li></ul></li></ul></li></ul><h3 id="SQL-执行结果接口-java-sql-ResultSet"><a href="#SQL-执行结果接口-java-sql-ResultSet" class="headerlink" title="SQL 执行结果接口 - java.sql.ResultSet"></a>SQL 执行结果接口 - java.sql.ResultSet</h3><h3 id="ResultSet-元数据接口-java-sql-ResultSetMetaData"><a href="#ResultSet-元数据接口-java-sql-ResultSetMetaData" class="headerlink" title="ResultSet 元数据接口 - java.sql.ResultSetMetaData"></a>ResultSet 元数据接口 - java.sql.ResultSetMetaData</h3><h3 id="SQL-执行异常-java-sql-SQLException"><a href="#SQL-执行异常-java-sql-SQLException" class="headerlink" title="SQL 执行异常 - java.sql.SQLException"></a>SQL 执行异常 - java.sql.SQLException</h3><ul><li>基本特点<ul><li>几乎所有的JDBC API操作都需要try catch SQLException</li><li>SQLException属于检查类型异常，继承了Exception</li></ul></li></ul><h3 id="事务保护点接口-java-sql-Savepoint"><a href="#事务保护点接口-java-sql-Savepoint" class="headerlink" title="事务保护点接口 - java.sql.Savepoint"></a>事务保护点接口 - java.sql.Savepoint</h3><h2 id="上课记录"><a href="#上课记录" class="headerlink" title="上课记录"></a>上课记录</h2><h3 id="数据源接口"><a href="#数据源接口" class="headerlink" title="数据源接口"></a>数据源接口</h3><h3 id="关联技术"><a href="#关联技术" class="headerlink" title="关联技术"></a>关联技术</h3><h4 id="Native-SQL"><a href="#Native-SQL" class="headerlink" title="Native SQL"></a>Native SQL</h4><h4 id="数据源-DataSource"><a href="#数据源-DataSource" class="headerlink" title="数据源 DataSource"></a>数据源 DataSource</h4><h5 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h5><ul><li>n个DataSources</li><li>DataSource代理<ul><li>Druid</li></ul></li></ul><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><ul><li>MyBatis Generator 通过数据库表结构生成Java代码和SQL Mapper</li></ul><h4 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h4><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>对应不同的技术栈的时候，数据源，JDBC，JPA，Redis，写的过程中不要过度依赖</p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><ul><li>如果有多个驱动，程序如何确定是使用哪一个驱动？<ul><li>无法确认</li></ul></li><li>java SPI会一次性全部加载，会不会比较浪费资源<ul><li>会，尽量不要配置多个。Dubbo中有自己的实现？</li></ul></li><li>多个Driver被加载到ClassLoader之后，到底用的是哪个？<ul><li>getConnection方法是通过JDBC URL来判断的，通过迭代多次，返回第一个成功的Connection</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210227202010.png" alt="image-20210227202010764"><ul><li>java.sql.DriverManager#loadInitialDrivers方法中java SPI 空遍历的意义？</li><li>ServiceLoader 中查看：ServiceLoader#next() 方法会主动触发ClassLoader加载</li></ul></li><li></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>要求【derby数据库】</p><ul><li>通过自研Web MVC框架实现一个用户注册，forward到一个成功的页面（JSP用法）<ul><li>/register</li></ul></li><li>通过Controller -&gt; Service -&gt; Repository实现（数据库实现）</li><li>（非必须）JNDI方式获取数据库源（DataSource）</li></ul><p>问题：</p><p>1、derby数据库如何使用</p><p><a href="https://www.wisyoong.com/2020/04/25/macOS-%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AE-Derby-%E6%95%B0%E6%8D%AE%E5%BA%93/">macOS 环境下配置 Derby 数据库</a></p><p>不行，使用mysql吧。。</p><p>2、用户注册页面使用bootstrap绘制</p><p>3、注册成功数据库操作【通过Controller -&gt; Service -&gt; Repository实现】done</p><p>4、成功后forward到成功的页面【使用jsp】</p><p>5、JNDI方式获取数据库源</p><p>数据库的连接整体流程</p><p>SPI</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库对比及选型</title>
      <link href="2021/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94%E5%8F%8A%E9%80%89%E5%9E%8B/"/>
      <url>2021/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94%E5%8F%8A%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><p>关系型数据库，是指采用了关系模型来组织数据的数据库。简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p><h2 id="关系型数据库的优点"><a href="#关系型数据库的优点" class="headerlink" title="关系型数据库的优点"></a>关系型数据库的优点</h2><p>1、容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</p><p>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便</p><p>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</p><h2 id="关系型数据库的缺点"><a href="#关系型数据库的缺点" class="headerlink" title="关系型数据库的缺点"></a>关系型数据库的缺点</h2><p>1、 当数据存储容量足够大的时候，备份成为了一件非常复杂的事情，费时费力。</p><p>2、 主备模式下，如果主库不出现问题并不会切换到备库，备库仅仅起到了一个以防万一的作用平时并不能分担压力，但是却不得不承担备库部分的成本。</p><p>3、 在读写分离场下，每添加一个只读库基本上就得购买一个一模一样的存储空间，如果是一个1T的主库，那么两个只读库的成本就是2个1T。</p><p>4、 还是读写分离场景，一个上TB的数据库容量加个只读副本就需要一到两天时间，非常的麻烦。</p><p>5、 传统模式下为了保障数据库不会到达 100% 都会预留10%~20% 的容量作为阈值，到了 80% 就进行升级或者扩容，其实这个时候那个预留的阈值是浪费了的，但是又不得不浪费。</p><p>6、 存储容量瓶颈，云计算厂商提供的关系型数据库基本上都有一个问题，那就是存储容量存在瓶颈，当数据量达到 2T 左右的时候就已经是瓶颈了无法进一步上升，而部分数据库应用场景恰恰就是需要大容量大存储的。</p><p>7、 性能瓶颈，当使用数据库遭遇性能瓶颈的时候其实是很糟心的，如果是能通过升级配置解决的那倒还行，如果是因为数据库软件本身的问题而更换数据库软件又意味着更高额的成本和风险。</p><hr><p>8、高并发读写需求<br>    网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈</p><p>9、海量数据的高效率读写<br>    网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的</p><p>10、高扩展性和可用性<br>    在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移。</p><h2 id="关系型数据库的主流产品"><a href="#关系型数据库的主流产品" class="headerlink" title="关系型数据库的主流产品"></a>关系型数据库的主流产品</h2><p>1、Oracle</p><p>Oracle是1983年推出的世界上第一个开放式商品化关系型数据库管理系统。它采用标准的SQL结构化查询语言，支持多种数据类型，提供面向对象存储的数据支持，具有第四代语言开发工具，支持Unix、Windows NT、OS/2、Novell等多种平台。除此之外，它还具有很好的并行处理功能。Oracle产品主要由Oracle服务器产品、Oracle开发工具、Oracle应用软件组成，也有基于微机的数据库产品。主要满足对银行、金融、保险等企业、事业开发大型数据库的需求。</p><p>2、DB2</p><p>DB2是美国IBM公司开发的一套关系型数据库管理系统，它主要的运行环境为UNIX（包括IBM自家的AIX）、Linux、IBM i（旧称OS/400）、z/OS，以及Windows服务器版本。</p><p>DB2主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境，应用于所有常见的服务器操作系统平台下。 DB2提供了高层次的数据利用性、完整性、安全性、可恢复性，以及小规模到大规模应用程序的执行能力，具有与平台无关的基本功能和SQL命令。</p><p>DB2采用了数据分级技术，能够使大型机数据很方便地下载到LAN数据库服务器，使得客户机/服务器用户和基于LAN的应用程序可以访问大型机数据，并使数据库本地化及远程连接透明化。</p><p>DB2以拥有一个非常完备的查询优化器而著称，其外部连接改善了查询性能，并支持多任务并行查询。 DB2具有很好的网络支持能力，每个子系统可以连接十几万个分布式用户，可同时激活上千个活动线程，对大型分布式应用系统尤为适用。</p><p>3、Microsoft SQL Server</p><p>SQL Server 是Microsoft 公司推出的关系型数据库管理系统。具有使用方便可伸缩性好与相关软件集成程度高等优点，可跨越从运行Microsoft Windows 98 的膝上型电脑到运行Microsoft Windows 2012 的大型多处理器的服务器等多种平台使用。</p><p>Microsoft SQL Server 是一个全面的数据库平台，使用集成的商业智能 (BI)工具提供了企业级的数据管理。Microsoft SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能，使您可以构建和管理用于业务的高可用和高性能的数据应用程序。</p><p>4、Microsoft Access</p><p>Access是由微软发布的关系数据库管理系统。它结合了 MicrosoftJet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。</p><p>Access是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。它是微软OFFICE的一个成员, 在包括专业版和更高版本的office版本里面被单独出售。2018年9月25日,最新的微软Office Access 2019在微软Office 2019里发布。</p><p>MS ACCESS以它自己的格式将数据存储在基于Access Jet的数据库引擎里。它还可以直接导入或者链接数据(这些数据存储在其他应用程序和数据库)。</p><p>5、MySQL</p><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p><p>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p><h1 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h1><p>非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。但非关系型数据库由于很少的约束，他也不能够提供像SQL所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数据库显的更为合适。</p><h2 id="非关系型数据库分类"><a href="#非关系型数据库分类" class="headerlink" title="非关系型数据库分类"></a>非关系型数据库分类</h2><p>​    由于非关系型数据库本身天然的多样性，以及出现的时间较短，因此，不想关系型数据库，有几种数据库能够一统江山，非关系型数据库非常多，并且大部分都是开源的。<br>​    这些数据库中，其实实现大部分都比较简单，除了一些共性外，很大一部分都是针对某些特定的应用需求出现的，因此，对于该类应用，具有极高的性能。依据结构化方法以及应用场合的不同，主要分为以下几类：<br>​    1、面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表<br>​    2、面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB<br>​    3、面向可扩展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</p><h1 id="分布式关系型数据库"><a href="#分布式关系型数据库" class="headerlink" title="分布式关系型数据库"></a>分布式关系型数据库</h1><p>目前只对主流的2个分布式关系型数据库进行调研</p><p><a href="https://juejin.cn/post/6844903863170891790">存储上云TiDB和Polardb</a></p><h2 id="Aliyun-PolarDB"><a href="#Aliyun-PolarDB" class="headerlink" title="Aliyun PolarDB"></a>Aliyun PolarDB</h2><p><a href="https://help.aliyun.com/product/58609.html?spm=a2c4g.11186623.6.540.602f1b417HgAbJ">PolarDB MySQL 云原生数据库</a></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="简单易用"><a href="#简单易用" class="headerlink" title="简单易用"></a>简单易用</h4><ul><li>PolarDB兼容多款流行的关系型数据库引擎，完全兼容MySQL和PostgreSQL，高度兼容Oracle语法，代码/应用无需修改或只需少量修改。</li></ul><h4 id="降低成本"><a href="#降低成本" class="headerlink" title="降低成本"></a>降低成本</h4><ul><li>计算节点和存储分离：多个计算节点共享存储，新增只读节点时只需支付计算节点费用，大大降低扩容成本。</li><li>Serverless存储：存储空间无需手动配置，根据数据量自动伸缩，您只需为实际使用的数据库容量付费。</li></ul><h4 id="极致性能"><a href="#极致性能" class="headerlink" title="极致性能"></a>极致性能</h4><ul><li>深度优化数据库内核，同时采用物理复制、RDMA高速网络和分布式共享存储，大幅提高性能。</li><li>集群包含一个主节点和最多15个只读节点，满足高并发场景对性能的要求，尤其适用于读多写少的场景。</li><li>基于共享存储的一写多读集群，数据只需要一次修改，所有节点立即生效。</li></ul><p>增加：</p><ul><li>在性能上 POLARDB 远超 MySQL ，在特殊场景下最高可以实现6倍于 MySQL。</li></ul><h4 id="海量存储，支持上百TB级别数据"><a href="#海量存储，支持上百TB级别数据" class="headerlink" title="海量存储，支持上百TB级别数据"></a>海量存储，支持上百TB级别数据</h4><ul><li>采用分布式块存储设计和文件系统，使得存储容量不限制于单节点的规格，能够轻松扩展，应对上百TB级别的数据规模。</li></ul><h4 id="高可用和高可靠保障，数据安全可靠"><a href="#高可用和高可靠保障，数据安全可靠" class="headerlink" title="高可用和高可靠保障，数据安全可靠"></a>高可用和高可靠保障，数据安全可靠</h4><ul><li>共享分布式存储的设计，彻底解决了主从（Master-Slave）异步复制所带来的备库数据非强一致的缺陷，使得整个数据库集群在应对任何单点故障时，可以保证数据零丢失。</li><li>多可用区架构，在多个可用区内都有数据备份，为数据库提供容灾和备份。</li><li>采用白名单、VPC网络、数据多副本存储等全方位的手段，对数据库数据访问、存储、管理等各个环节提供安全保障。</li></ul><h4 id="快速弹性，应对不确定的业务增长"><a href="#快速弹性，应对不确定的业务增长" class="headerlink" title="快速弹性，应对不确定的业务增长"></a>快速弹性，应对不确定的业务增长</h4><ul><li><p>配置升降级，5分钟生效。</p><p>采用容器虚拟化技术和共享的分布式块存储技术，使得数据库服务器的CPU、内存能够快速扩容。</p></li><li><p>增减节点，5分钟生效。</p><p>通过动态增减节点提升性能或节省成本。通过使用集群地址，可屏蔽底层的变化，应用对于增减节点无感知。</p></li></ul><h4 id="无锁备份"><a href="#无锁备份" class="headerlink" title="无锁备份"></a>无锁备份</h4><ul><li>利用底层分布式存储的快照技术，只需分钟级别即可完成对上TB数据量大小的数据库的备份，且整个备份过程不需要加锁，效率更高，影响更小。</li></ul><h2 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h2><p><a href="https://docs.pingcap.com/zh/tidb/stable">TiDB官网</a></p><p><a href="https://pingcap.com/blog-cn/schema-application-scenario-for-tidb/">TiDB 常⻅架构应⽤场景</a></p><p><a href="https://book.tidb.io/session4/chapter1/scenarios.html">TIDB gitbook</a></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><h4 id="一键水平扩容或者缩容"><a href="#一键水平扩容或者缩容" class="headerlink" title="一键水平扩容或者缩容"></a>一键水平扩容或者缩容</h4><ul><li>得益于 TiDB 存储计算分离的架构的设计，可按需对计算、存储分别进行在线扩容或者缩容，扩容或者缩容过程中对应用运维人员透明。</li></ul><h4 id="金融级高可用"><a href="#金融级高可用" class="headerlink" title="金融级高可用"></a>金融级高可用</h4><ul><li>数据采用多副本存储，数据副本通过 Multi-Raft 协议同步事务日志，多数派写入成功事务才能提交，确保数据强一致性且少数副本发生故障时不影响数据的可用性。可按需配置副本地理位置、副本数量等策略满足不同容灾级别的要求。</li></ul><h4 id="实时-HTAP"><a href="#实时-HTAP" class="headerlink" title="实时 HTAP"></a>实时 HTAP</h4><ul><li>提供行存储引擎 TiKV、列存储引擎 TiFlash 两款存储引擎，TiFlash 通过 Multi-Raft Learner 协议实时从 TiKV 复制数据，确保行存储引擎 TiKV 和列存储引擎 TiFlash 之间的数据强一致。TiKV、TiFlash 可按需部署在不同的机器，解决 HTAP 资源隔离的问题。</li></ul><h4 id="云原生的分布式数据库"><a href="#云原生的分布式数据库" class="headerlink" title="云原生的分布式数据库"></a>云原生的分布式数据库</h4><ul><li>专为云而设计的分布式数据库，通过 <a href="https://docs.pingcap.com/zh/tidb-in-kubernetes/v1.1/tidb-operator-overview">TiDB Operator</a> 可在公有云、私有云、混合云中实现部署工具化、自动化。</li></ul><h4 id="兼容-MySQL-5-7-协议和-MySQL-生态"><a href="#兼容-MySQL-5-7-协议和-MySQL-生态" class="headerlink" title="兼容 MySQL 5.7 协议和 MySQL 生态"></a>兼容 MySQL 5.7 协议和 MySQL 生态</h4><ul><li>兼容 MySQL 5.7 协议、MySQL 常用的功能、MySQL 生态，应用无需或者修改少量代码即可从 MySQL 迁移到 TiDB。提供丰富的数据迁移工具帮助应用便捷完成数据迁移。</li></ul><h1 id="数据库之间的对比"><a href="#数据库之间的对比" class="headerlink" title="数据库之间的对比"></a>数据库之间的对比</h1><p><a href="https://book.tidb.io/session1/chapter5/mysql-compatibility.html">第5章 TiDB 和 MySQL 的区别</a></p><p><a href="https://help.aliyun.com/document_detail/146102.html">PolarDB MySQL与RDS MySQL的对比</a></p><p><a href="https://www.mf8.biz/polardb-for-mysql/">POLARDB for MySQL 版评测及同类横向对比【重要】</a></p><h1 id="为什么要做对比？"><a href="#为什么要做对比？" class="headerlink" title="为什么要做对比？"></a>为什么要做对比？</h1><p>数据库大表2700w，需要做处理，技术选型，看什么合适</p><h1 id="分库分表方案讨论"><a href="#分库分表方案讨论" class="headerlink" title="分库分表方案讨论"></a>分库分表方案讨论</h1><p><a href="https://mp.weixin.qq.com/s/U_pEF9sfnXeZ7RnhGFnqyg">“分库分表” ？选型和流程要慎重，否则会失控</a></p><h1 id="阿里云数据库上云指导图"><a href="#阿里云数据库上云指导图" class="headerlink" title="阿里云数据库上云指导图"></a>阿里云数据库上云指导图</h1><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210301161812.jpg" alt="img"></p><p><strong>OLTP</strong> 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；（在线事务处理（简称OLTP）在3层体系结构中支持面向事务的应用程序。OLTP管理组织的日常事务。）</p><p><strong>OLAP</strong> 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 （联机分析处理，一类软件工具，可为业务决策提供数据分析。OLAP系统允许用户一次分析来自多个数据库系统的数据库信息。）</p><p><a href="https://www.guru99.com/oltp-vs-olap.html">OLTP和OLAP之间的区别</a></p><p><a href="https://help.aliyun.com/document_detail/184047.html">HATP - 混合事务分析处理（Hybrid Transactional/Analytical Processing，简称HTAP）</a></p><h1 id="MySQL迁移PolarDB"><a href="#MySQL迁移PolarDB" class="headerlink" title="MySQL迁移PolarDB"></a>MySQL迁移PolarDB</h1><p><a href="https://help.aliyun.com/document_detail/188525.html?spm=a2c4g.11186623.6.567.796b40aaRNOj5Q">购买方式-简介和对比</a></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210302152822.png" alt="image-20210302152822140"></p><p>目前业务量不大，先选择购买 <code>云数据库 PolarDB-按量付费</code></p><p><a href="https://help.aliyun.com/document_detail/123903.html?spm=5176.smartservice_service_chat.0.dexternal.6d053f1bwtLTvp">一键升级RDS MySQL至PolarDB MySQL</a></p><p>在购买并执行迁移的时候报错了</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210302151529.png" alt="image-20210302151529500"></p><p>咨询了阿里云客服，针对RDS MySQL 5.7，内核小版本需为20200331或以上版本。需要抽时间换内核小版本，再进行购买。<code>20210302</code>晚上升级内核后再进购买测试。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210302151351.png" alt="image-20210302151351929"></p><p>最后是先购买一台PolarDB，在使用阿里云的迁移和同步服务，在数据同步的情况下重新发版项目，切换数据源到新的数据源下面。期间遇到了表名大小写敏感的问题，Quartz的几张表源数据库是小写的，迁移到新的PolarDB后，程序无法访问，期间只能手动尝试修改。</p><p><a href="https://blog.csdn.net/fdipzone/article/details/73692929">mysql大小写敏感配置</a></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show global variables like '%lower_case%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>lower_case_file_system    OFF<br>lower_case_table_names    0</p><ul><li><strong>lower_case_file_system</strong></li></ul><p>表示当前系统文件是否大小写敏感，只读参数，无法修改。</p><p>ON 大小写不敏感<br>OFF 大小写敏感</p><h1 id="其他参考链接"><a href="#其他参考链接" class="headerlink" title="其他参考链接"></a>其他参考链接</h1><p><a href="https://blog.csdn.net/oChangWen/article/details/53423301">关系型数据库和非关系型数据库区别、oracle与mysql的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小马哥训练营-汇总记录</title>
      <link href="2021/02/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%B0%8F%E9%A9%AC%E5%93%A5%E8%AE%AD%E7%BB%83%E8%90%A5-%E6%B1%87%E6%80%BB%E8%AE%B0%E5%BD%95/"/>
      <url>2021/02/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%B0%8F%E9%A9%AC%E5%93%A5%E8%AE%AD%E7%BB%83%E8%90%A5-%E6%B1%87%E6%80%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="小马哥java项目实战训练营大纲"><a href="#小马哥java项目实战训练营大纲" class="headerlink" title="小马哥java项目实战训练营大纲"></a>小马哥java项目实战训练营大纲</h2><h2 id="Week-1：Java-EE-项目-迭代-项目开发和框架实现"><a href="#Week-1：Java-EE-项目-迭代-项目开发和框架实现" class="headerlink" title="Week 1：Java EE 项目**迭代 -** 项目开发和框架实现"></a><strong>Week 1：</strong>Java EE <strong>项目**</strong>迭代 -** <strong>项目开发和框架实现</strong></h2><h3 id="教学目标："><a href="#教学目标：" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li><p>使用 Java 标准化技术栈开发项目</p></li><li><p>掌握 Java 生态系统、企业级架构和技术规范</p></li><li><p>基于 Java 标准技术栈自研开发框架，为主流框架的设计和实现做铺垫</p></li></ul><h3 id="架构工作中的痛点："><a href="#架构工作中的痛点：" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li><p>缺少 Java 生态全局视野，对潜在需求，尤其是非功能性需求意识较弱</p></li><li><p>日常工作对 Java 标准技术、规范和 API 知之甚少，阅读框架源码举步维艰</p></li></ul><h3 id="通过学习掌握的核心能力："><a href="#通过学习掌握的核心能力：" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>技术规范：了解项目中所使用的 Java 规范和 API 接口</p></li><li><p>实战运用：使用标准 Java 技术栈和自研框架迭代实现项目需求</p></li></ul><h3 id="详细内容："><a href="#详细内容：" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>项目模块：项目主要围绕“用户注册”、“用户登录”以及“用户管理”等模块构建</p></li><li><p>Web 框架：基于 Servlet 实现 Web MVC Framework，使用 JSP、EL 以及 JSTL 作为服务端视图模板引擎</p></li><li><p>IoC 框架：基于 JNDI 和 Java Common Annotations 实现 IoC（CDI）框架</p></li><li><p>同步服务：基于 JAX-RS 和 MicroProfile Rest Client 实现服务调用框架</p></li><li><p>异步服务：基于 JMS 和 MicroProfile Reactive Messaging 作为异步服务通讯</p></li><li><p>数据存储：应用 IoC 框架整合 JDBC 和 JPA 实现项目数据持久化</p></li></ul><h2 id="Week-2：Java-EE-项目迭代-运维管理"><a href="#Week-2：Java-EE-项目迭代-运维管理" class="headerlink" title="Week 2：Java EE 项目迭代 - 运维管理"></a><strong>Week 2：</strong>Java EE 项目<strong>迭代 -</strong> 运维管理</h2><h3 id="教学目标：-1"><a href="#教学目标：-1" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li><p>提升项目运维管理能力，实现可配置和可监控</p></li><li><p>使用 CI/CD 工具实现项目持续交付，构建自动化平台</p></li><li><p>理解标准 Java 技术栈在运维管理中扮演的角色</p></li></ul><h3 id="架构工作中的痛点：-1"><a href="#架构工作中的痛点：-1" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li><p>项目代码变更之后，缺乏自动化测试和试运行机制，产品质量得不到有效的保障</p></li><li><p>作为一名开发人员，对于运维体系和手段相对陌生，无法运用 Java EE 容器内建特性达到运维目的</p></li></ul><h3 id="通过学习掌握的核心能力：-1"><a href="#通过学习掌握的核心能力：-1" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>DevOps：打造项目的运维体系，包括 codebase 管理、项目构建工具运用、CI/CD 平台搭建、以及基于 Java 实现服务监控、日志管理以及配置管理等</li></ul><h3 id="详细内容：-1"><a href="#详细内容：-1" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>日志管理：基于 Java Logging 作为系统日志框架，理解其整体设计和架构</p></li><li><p>监控管理：使用 Java JMX（Java 管理扩展）对关键服务进行监管，理解 JMX 架构和不同类型的 MBean 使用场景</p></li><li><p>配置管理：基于 MicroProfile Config 实现配置框架，理解 ServletContext Config、ServletConfig、JVM 启动参数、Java 系统属性以及环境变量等外部化配置差异</p></li><li><p>质量保证：运用 codebase 平台工具实现代码变更通知、代码分析以及 Code Review 流程，并使用 GitHub/GitLab CI 工具集成 Maven 生态构建自动化测试平台</p></li></ul><h2 id="Week-3：Java-EE-项目迭代-分布式架构设计"><a href="#Week-3：Java-EE-项目迭代-分布式架构设计" class="headerlink" title="Week 3：Java EE 项目迭代 - 分布式架构设计"></a><strong>Week 3：</strong>Java EE 项目<strong>迭代 - 分布式架构设计</strong></h2><h3 id="教学目标：-2"><a href="#教学目标：-2" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li><p>熟练运用 Java EE 容器实现平台高可用、高性能以及高并发的需要</p></li><li><p>使用 Java Security 实现平台访问控制和安全防护</p></li></ul><h3 id="架构工作中的痛点：-2"><a href="#架构工作中的痛点：-2" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li><p>由于企业系统规模的局限，缺少实践高可用、高性能和高并发 Java 分布式架构的机会</p></li><li><p>作为一名业务开发，日常项目中缺乏访问控制和 Web 安全防控的意识</p></li></ul><h3 id="通过学习掌握的核心能力：-2"><a href="#通过学习掌握的核心能力：-2" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>安全防控：理解服务认证和授权架构，并结合 Java EE 容器实现访问控制；了解常见 Web 攻击手段，构建安全 Web 服务</li></ul><h3 id="详细内容：-2"><a href="#详细内容：-2" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>负载均衡：使用多 Java EE 容器对等部署的方式，达到均衡服务器压力的目的</p></li><li><p>API 网关：基于 Servlet 异步技术实现高性能 API 网关</p></li><li><p>单点登录：通过 Java EE 容器 Session 复制等手段提供项目 Web 应用的单点登录能力</p></li><li><p>性能压测：通过 JDK 动态代理和 Servlet Filter 方式，对项目关键服务进行性能埋点，评估 API 性能指标</p></li><li><p>性能提升：结合压力测试结果，运用 Java Caching 整合 Redis 以及异步技术，提升系统性能</p></li><li><p>访问控制：使用 Java EE 容器认证和授权架构实现访问控制</p></li><li><p>Web 安全：了解 SQL 注入、CSRF、XSS、HSTS 等攻击手段，结合 Java Security 提升加密解密和安全防护能力</p></li></ul><h2 id="Week-4：Java-开源整合项目迭代-实现重构"><a href="#Week-4：Java-开源整合项目迭代-实现重构" class="headerlink" title="Week 4：Java 开源整合项目迭代 - 实现重构"></a><strong>Week 4：</strong>Java 开源整合项目迭代 - 实现重构</h2><h3 id="教学目标：-3"><a href="#教学目标：-3" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>使用 Spring 技术栈和其他开源框架重构当前项目</li></ul><h3 id="架构工作中的痛点：-3"><a href="#架构工作中的痛点：-3" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>公司项目的技术单一，对 Java 技术生态缺少技术选型的判断力和决策力</li></ul><h3 id="通过学习掌握的核心能力：-3"><a href="#通过学习掌握的核心能力：-3" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>使用标准 Java 技术、Spring 以及其他开源框架迭代重构当前项目</li></ul><h3 id="详细内容：-3"><a href="#详细内容：-3" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>数据存储：使用 MyBatis 和 Spring Data JPA 重构项目 JDBC 封装实现</p></li><li><p>视图渲染：基于 Spring Web MVC 重构业务实现，并复用 JSP、EL 以及 JSTL 页面</p></li><li><p>服务通讯：基于 Spring Web MVC 适配 JAX-RS 注解，实现业务代码复用，使用 Spring JMS 重构项目遗留 JMS 实现</p></li></ul><h2 id="Week-5：Java-开源整合项目迭代-运维重构"><a href="#Week-5：Java-开源整合项目迭代-运维重构" class="headerlink" title="Week 5：Java 开源整合项目迭代 - 运维重构"></a><strong>Week 5：</strong>Java 开源整合项目迭代 - 运维重构</h2><h3 id="教学目标：-4"><a href="#教学目标：-4" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>使用 Spring 技术栈替换 Java EE 架构的运维体系</li></ul><h3 id="架构工作中的痛点：-4"><a href="#架构工作中的痛点：-4" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>日常开发能够熟练使用 Spring 技术栈，然而对其生态缺乏整体认识，对框架细节相对陌生</li></ul><h3 id="通过学习掌握的核心能力：-4"><a href="#通过学习掌握的核心能力：-4" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>从实现成本和学习曲线等多维度对比标准 Java 技术生态、Spring 技术生态以及其他开源框架</li></ul><h3 id="详细内容：-4"><a href="#详细内容：-4" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>测试用例：基于 Spring Testing 重构项目单元测试和集成测试</p></li><li><p>服务监控：基于 Spring JMX 重构项目中 MBean 的管理，理解 Spring JMX @ManagedResource 注解，简化 JMX 开发的实现细节。</p></li><li><p>日志管理：使用 Spring Logging API 替换现有的 Java Logging 实现，并理解它与 Apache Commons Logging 以及 SLF4J 的区别。</p></li><li><p>配置管理：基于 Spring 外部化配置重构当前项目基于 Apache Commons Configuration 的配置抽象实现。</p></li></ul><h2 id="Week-6：Java-开源整合项目迭代-架构升级"><a href="#Week-6：Java-开源整合项目迭代-架构升级" class="headerlink" title="Week 6：Java 开源整合项目迭代 - 架构升级"></a><strong>Week 6：</strong>Java 开源整合项目迭代 - 架构升级</h2><h3 id="教学目标：-5"><a href="#教学目标：-5" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>利用非 Java 基础设施提升平台应用的整体性能</li></ul><h3 id="架构工作中的痛点：-5"><a href="#架构工作中的痛点：-5" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>长期从事 Java 服务端研发，对于非 Java 技术栈如何提升平台性能缺少实战经验</li></ul><h3 id="通过学习掌握的核心能力：-5"><a href="#通过学习掌握的核心能力：-5" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>掌握 Nginx、Varnish 等非 Java Web 服务基础设施</p></li><li><p>了解 Spring Security 特性和架构，并运用其特性重构项目的访问控制和 Web 安全实现</p></li></ul><h3 id="详细内容：-5"><a href="#详细内容：-5" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>负载均衡：利用 Nginx 作为反向代理服务器，更替 Java-Based Web Server 实现</p></li><li><p>单点登录：使用 Spring Session 升级项目遗留的单点登录实现</p></li><li><p>API 网关：基于 Nginx 构建系统 API 网关，利用 Spring WebFlux 实现业务 API 网关</p></li><li><p>性能压测：使用 Spring AOP 替换项目性能埋点实现，并重新评估重构后的 API 性能指标</p></li><li><p>性能提升：使用 Spring Caching 抽象重构 Java Caching 标准实现，运用 Nginx 实现动态内容和静态内容分离，使用 Varnish 提升 Web 整体性能</p></li></ul><h2 id="Week-7：Java-SOA-项目迭代-需求分析和开发"><a href="#Week-7：Java-SOA-项目迭代-需求分析和开发" class="headerlink" title="Week 7：Java SOA 项目迭代 - 需求分析和开发"></a><strong>Week 7：Java SOA</strong> 项目迭代 - 需求分析和<strong>开发</strong></h2><h3 id="教学目标：-6"><a href="#教学目标：-6" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>构建 SOA 理论体系，了解 SOA 解决方案，为项目选型提供参考</li></ul><h3 id="架构工作中的痛点：-6"><a href="#架构工作中的痛点：-6" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>在日常开发中更多的关注是功能实现和框架运用，对于 SOA 架构并未建立清晰的理论体系</li></ul><h3 id="通过学习掌握的核心能力：-6"><a href="#通过学习掌握的核心能力：-6" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>理解 SOA 的概念、原则、模式、实现以及延伸架构，如：事件驱动架构、WebServices、REST 等</p></li><li><p>服务注册与发现：理解服务注册与发现理论，掌握不同注册中心技术选型的使用场景</p></li></ul><h3 id="详细内容：-6"><a href="#详细内容：-6" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>服务通讯：使用 Apache Dubbo 替换项目部分 REST API 同步服务，使用 Spring Kafka 重构异步服务通讯</p></li><li><p>数据存储：使用 Apache ShardingSphere 增加数据库分库分表能力</p></li><li><p>服务注册与发现：理解 Dubbo Registry SPI 以及不同的基础设施实现，如：ZooKeeper、Consul 和 Nacos 等</p></li></ul><h2 id="Week-8：Java-SOA-项目迭代-平台运维"><a href="#Week-8：Java-SOA-项目迭代-平台运维" class="headerlink" title="Week 8：Java SOA 项目迭代 - 平台运维"></a><strong>Week 8：Java SOA</strong> 项目迭代 - 平台运维</h2><h3 id="教学目标：-7"><a href="#教学目标：-7" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>引入 Apache Dubbo Admin 技术，提升项目运维能力</li></ul><h3 id="架构工作中的痛点：-7"><a href="#架构工作中的痛点：-7" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>没有接触过服务治理、负载均衡、服务路由、服务熔断、三方登录等分布式高阶场景</li></ul><h3 id="通过学习掌握的核心能力：-7"><a href="#通过学习掌握的核心能力：-7" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>负载均衡：理解常见负载均衡算法，把握它们的适用场景</p></li><li><p>服务路由：了解服务路由的使用场景，掌握动态服务路由的实现原理</p></li></ul><h3 id="详细内容：-7"><a href="#详细内容：-7" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>负载均衡：理解 Dubbo LoadBalance SPI 设计以及各种不同的实现，结合项目实际情况，合理选型</p></li><li><p>服务路由：理解 Dubbo Route SPI 设计与实现，并模拟实现多区域用户路由到不同的 Dubbo 服务机房</p></li><li><p>配置管理：使用 Nacos Spring 提升分布式动态配置</p></li><li><p>服务监控：使用 Apache Dubbo Admin 提升项目 DevOps 能力，如：治理 Dubbo 服务、实现延迟暴露、优雅上下线、动态路由等</p></li></ul><h2 id="Week-9：Java-SOA-项目迭代-架构升级"><a href="#Week-9：Java-SOA-项目迭代-架构升级" class="headerlink" title="Week 9：Java SOA 项目迭代 - 架构升级"></a><strong>Week 9：Java SOA</strong> 项目迭代 - 架构升级</h2><h3 id="教学目标：-8"><a href="#教学目标：-8" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li><p>使用 SOA 的模式和实现升级当前项目的架构，使其符合 SOA 的原则</p></li><li><p>运用全链路压测，对重构后的 SOA 应用进行性能评估</p></li><li><p>实现灰度发布策略，确保应用更迭安全稳定</p></li></ul><h3 id="架构工作中的痛点：-8"><a href="#架构工作中的痛点：-8" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li><p>目前应用规模无法触及高并发场景，缺少自动化和精细化测量业务完整链路的性能指标</p></li><li><p>尽管回归测试相对完善，然而项目发布时仍提心吊胆，无法在生产环境执行小规模测试</p></li></ul><h3 id="通过学习掌握的核心能力：-8"><a href="#通过学习掌握的核心能力：-8" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>服务高可用：了解服务熔断、降级以及限流的原理和差异</p></li><li><p>安全控制：理解 OAuth2 架构和原理，帮助项目提升认证和授权的能力</p></li><li><p>全链路压测：掌握全链路压测系统的设计模式，寻找服务性能短板</p></li><li><p>灰度发布：掌握灰度发布的实现策略，理解不同基础设施实现的利弊</p></li></ul><h3 id="详细内容：-8"><a href="#详细内容：-8" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>服务高可用：基于 Netflix Hystrix 和 Alibaba Sentinel 实现 Web 服务和 Dubbo 服务熔断、降级和限流</p></li><li><p>安全和控制： 基于 Spring Security 提升 Dubbo 服务认证和授权能力</p></li><li><p>全链路压测：基于JMeter 技术，再结合库表设计，实现平台业务全链路压测</p></li><li><p>灰度发布：基于 Nginx 插件提供平台灰度发布的能力</p></li></ul><h2 id="Week-10：Java-微服务架构项目迭代-技术提升"><a href="#Week-10：Java-微服务架构项目迭代-技术提升" class="headerlink" title="Week 10：Java 微服务架构项目迭代 - 技术提升"></a><strong>Week 10：Java</strong> 微服务架构项目迭代 - 技术提升</h2><h3 id="教学目标：-9"><a href="#教学目标：-9" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li><p>理解微服务架构的概念、与 SOA 架构的区别，以及常见的实现模式</p></li><li><p>使用前后端分离技术实现服务端视图渲染</p></li></ul><h3 id="架构工作中的痛点：-9"><a href="#架构工作中的痛点：-9" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li><p>时常听到微服务架构的理论和实践案例，但不清楚它与 SOA 到底存在哪些区别</p></li><li><p>长期从事服务端研发，对前端技术的发展不了解，缺少前后端分离技术的实践经验</p></li></ul><h3 id="通过学习掌握的核心能力：-9"><a href="#通过学习掌握的核心能力：-9" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>理论知识：掌握微服务架构理论体系，了解微服务最佳实践</p></li><li><p>技术提升：理解 Spring Boot/Spring Cloud 核心特性和架构设计</p></li></ul><h3 id="详细内容：-9"><a href="#详细内容：-9" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>数据存储：使用第三方 Spring Boot Starter 重构 MyBatis 和 Apache ShardingSphere 实现，并使用 Spring Boot 官方 Starter 针对 JPA 和 Caching 等进行升级</p></li><li><p>视图渲染：使用 Vue.js 替换 Java Web Server 服务端视图渲染</p></li><li><p>服务通讯：使用 Dubbo Spring Cloud 重构同步服务，基于 Spring Cloud Stream 重新实现异步服务</p></li></ul><h2 id="Week-11：Java-微服务架构项目迭代-平台运维"><a href="#Week-11：Java-微服务架构项目迭代-平台运维" class="headerlink" title="Week 11：Java 微服务架构项目迭代 - 平台运维"></a><strong>Week 11：Java</strong> 微服务架构项目迭代 - 平台运维</h2><h3 id="教学目标：-10"><a href="#教学目标：-10" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>运用微服务架构理论和基础设施升级平台架构</li></ul><h3 id="架构工作中的痛点：-10"><a href="#架构工作中的痛点：-10" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>应用架构升级到微服务过程中，伴随着基础设施的升级，又需要学习新的技术，感觉力不从心</li></ul><h3 id="通过学习掌握的核心能力：-10"><a href="#通过学习掌握的核心能力：-10" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>掌握 Spring Boot 和 Spring Cloud 中的运维方式</li></ul><h3 id="详细内容：-10"><a href="#详细内容：-10" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>测试用例：学习并使用 Spring Boot Testing 重构集成测试</p></li><li><p>负载均衡：使用 Spring Cloud LoadBalancer 抽象重构 REST 负载均衡</p></li><li><p>服务监控：理解 Spring Boot Actuator 体系，使用 Spring Boot Admin 提升 Spring Boot 应用运维能力</p></li><li><p>配置管理：基于 Spring Cloud Config 实现动态分布式配置</p></li><li><p>日志管理：基于 Spring Cloud Config 实现分布式动态日志管理</p></li></ul><h2 id="Week-12：Java-微服务架构项目迭代-架构升级与过渡"><a href="#Week-12：Java-微服务架构项目迭代-架构升级与过渡" class="headerlink" title="Week 12：Java 微服务架构项目迭代 - 架构升级与过渡"></a><strong>Week 12：Java</strong> 微服务架构项目迭代 - 架构升级与过渡</h2><h3 id="教学目标：-11"><a href="#教学目标：-11" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>运用微服务架构理论和基础设施升级平台架构</li></ul><h3 id="架构工作中的痛点：-11"><a href="#架构工作中的痛点：-11" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>公司为顺应潮流，要求将所有应用架构升级到微服务架构，然而缺少应用合理拆分的理论指导，也不清楚如何应对拆分后的潜在风险</li></ul><h3 id="通过学习掌握的核心能力：-11"><a href="#通过学习掌握的核心能力：-11" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>架构升级：使用 Spring Boot 和 Spring Cloud 升级 Java 基础设施</p></li><li><p>架构过渡：掌握不同发布策略的实质和区别，合理选择架构过渡方案</p></li></ul><h3 id="详细内容：-11"><a href="#详细内容：-11" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>访问控制：使用 Spring Security OAuth 提升认证和授权架构，实现访问控制</p></li><li><p>Web 安全：使用 Spring Security Starter 配置化实现 CSRF、XSS、HSTS</p></li><li><p>API 网关：使用 Spring Cloud Gateway 重构 Spring WebFlux 实现的业务 API 网关，使用 Dubbo Spring Cloud 实现 Dubbo 服务网关</p></li><li><p>服务高可用：基于 Spring Cloud Circuit Breaker 重构服务熔断实现，并结合 Spring Cloud Alibaba Sentinel 实现服务限流和熔断</p></li><li><p>分布式跟踪：理解 Dapper 分布式跟踪理论，使用 Spring Cloud Sleuth 实现分布式应用服务跟踪</p></li><li><p>性能压测：使用 Spring AOP 替换项目性能埋点实现，并重新评估重构后的 API 性能指标</p></li><li><p>性能提升：使用 Spring Caching 抽象重构 Java Caching 标准实现，运用 Nginx 实现动态内容和静态内容分离，使用 Varnish 提升 Web 整体性能</p></li></ul><h2 id="Week-13：Java-云原生项目迭代-开发提升"><a href="#Week-13：Java-云原生项目迭代-开发提升" class="headerlink" title="Week 13：Java 云原生项目迭代 - 开发提升"></a><strong>Week 13：Java</strong> 云原生项目迭代 - 开发提升</h2><h3 id="教学目标：-12"><a href="#教学目标：-12" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>理解云原生云的基本概念、实质以及主流技术</li></ul><h3 id="架构工作中的痛点：-12"><a href="#架构工作中的痛点：-12" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>云原生的势头迅猛，感觉工作和云原生的实践缺少交集，心里不踏实，也缺少一条弯道超车的办法</li></ul><h3 id="通过学习掌握的核心能力：-12"><a href="#通过学习掌握的核心能力：-12" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li><p>理论知识：了解云原生的理论，掌握主流云原生基础设施</p></li><li><p>技术提升：掌握 GraalVM、Docker、Kubernetes、Service Mesh（Istio）以及 Spring 云原生等技术</p></li></ul><h3 id="详细内容：-12"><a href="#详细内容：-12" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>容器化技术：掌握以 Docker 为代表的容器化技术，并介绍不同的容器引擎</p></li><li><p>Kubernetes：理解 Kubernetes 架构、Pod 和容器设计模式、应用编排与管理等</p></li><li><p>服务注册与发现：使用 Spring Cloud Kubernetes 替换现有 Spring Cloud 传统实现，理解 Kubernetes API Server 架构</p></li><li><p>服务通讯：使用 gRPC 升级 Dubbo 中的传输协议，利用 RSocket 实现 Dubbo 异步服务通讯（Reactive）</p></li></ul><h2 id="Week-14：Java-云原生项目迭代-运维平台"><a href="#Week-14：Java-云原生项目迭代-运维平台" class="headerlink" title="Week 14：Java 云原生项目迭代 - 运维平台"></a><strong>Week 14：Java</strong> 云原生项目迭代 - 运维平台</h2><h3 id="教学目标：-13"><a href="#教学目标：-13" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>使用云原生主流技术升级项目的基础设施，并将其变成云原生应用</li></ul><h3 id="架构工作中的痛点：-13"><a href="#架构工作中的痛点：-13" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>云原生生态体系庞大，而且对它缺乏整体认知，面对诸多技术选型无从抉择</li></ul><h3 id="通过学习掌握的核心能力：-13"><a href="#通过学习掌握的核心能力：-13" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>运维体系：熟悉私有云和公共云的运维体系，逐渐磨平两种体系的运维差异</li></ul><h3 id="详细内容：-13"><a href="#详细内容：-13" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>运维建设：构建企业 Docker 镜像仓库，打造以 Docker 为基础的 CI/CD 环境</p></li><li><p>负载均衡：理解 Kubernetes Ingress 及负载均衡解决方法</p></li><li><p>服务监控：（可观测性）理解 livenessProbes、readinessProbes、容器日志收集，使用 Prometheus 和 Grafana 的监控系统实践</p></li><li><p>配置管理：基于 Spring Cloud Kubernetes Config 更替已有配置实现，理解 Kubernetes ConfigMaps</p></li><li><p>日志管理：使用 Kubernetes 平台日志管理方法</p></li></ul><h2 id="Week-15：Java-云原生项目迭代-架构改造"><a href="#Week-15：Java-云原生项目迭代-架构改造" class="headerlink" title="Week 15：Java 云原生项目迭代 - 架构改造"></a><strong>Week 15：Java</strong> 云原生项目迭代 - 架构改造</h2><h3 id="教学目标：-14"><a href="#教学目标：-14" class="headerlink" title="教学目标："></a>教学目标：</h3><ul><li>项目将从自建私有云部署到公有云平台（阿里云），并掌握阿里云主流云产品的使用</li></ul><h3 id="架构工作中的痛点：-14"><a href="#架构工作中的痛点：-14" class="headerlink" title="架构工作中的痛点："></a>架构工作中的痛点：</h3><ul><li>公司业务发展蓬勃，只有云平台支撑业务快速发展，需要具备公有云、私有云以及混合云的配套技能</li></ul><h3 id="通过学习掌握的核心能力：-14"><a href="#通过学习掌握的核心能力：-14" class="headerlink" title="通过学习掌握的核心能力："></a>通过学习掌握的核心能力：</h3><ul><li>使用云原生流行技术等升级系统架构、基础设施和 DevOps 体系</li></ul><h3 id="详细内容：-14"><a href="#详细内容：-14" class="headerlink" title="详细内容："></a>详细内容：</h3><ul><li><p>访问控制：了解 Kubernetes 中 API 访问安全机制、认证和授权，逐步替代现有实现</p></li><li><p>API 网关：使用 Istio Ingress 升级 API 网关实现</p></li><li><p>服务高可用：使用 Istio 替换 Spring Cloud Circuit Breaker 实现</p></li><li><p>分布式跟踪：使用 Jaeger 替换 Spring Cloud Sleuth 实现</p></li><li><p>性能提升：使用 GraalVM 提升 Java 微服务性能</p></li></ul><h1 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h1><p>训练营项目工程代码地址：</p><p>GitHub：<a href="https://github.com/mercyblitz/geekbang-lessons">https://github.com/mercyblitz/geekbang-lessons</a></p><p>Gitee：<a href="https://gitee.com/geektime-geekbang/mercyblitz-projects">https://gitee.com/geektime-geekbang/mercyblitz-projects</a></p><h1 id="作业链接"><a href="#作业链接" class="headerlink" title="作业链接"></a>作业链接</h1><p>优秀作业链接：<a href="https://shimo.im/sheets/vC8TkCGq9dcWdqpW/MODOC/">https://shimo.im/sheets/vC8TkCGq9dcWdqpW/MODOC/</a> </p><p>﻿</p><p>第一周作业提交链接：<a href="https://jinshuju.net/f/cCuRcp">https://jinshuju.net/f/cCuRcp</a></p><p>第二周作业提交链接：<a href="https://jinshuju.net/f/afHnK6">https://jinshuju.net/f/afHnK6</a></p><p>第三周作业提交链接：<a href="https://jinshuju.net/f/EDwozM">https://jinshuju.net/f/EDwozM</a></p><p>第四周作业提交链接：<a href="https://jinshuju.net/f/OubQma">https://jinshuju.net/f/OubQma</a></p><p>第五周作业提交链接：<a href="https://jinshuju.net/f/DRe5aZ">https://jinshuju.net/f/DRe5aZ</a></p><p>第六周作业提交链接：<a href="https://jinshuju.net/f/OJ1nlq">https://jinshuju.net/f/OJ1nlq</a></p><p>第七周作业提交链接：<a href="https://jinshuju.net/f/qizKPb">https://jinshuju.net/f/qizKPb</a></p><p>第八周作业提交链接：<a href="https://jinshuju.net/f/A3FbqX">https://jinshuju.net/f/A3FbqX</a></p><p>第九周作业提交链接：<a href="https://jinshuju.net/f/b8KKap">https://jinshuju.net/f/b8KKap</a></p><p>第十周作业提交链接：<a href="https://jinshuju.net/f/wQzOKQ">https://jinshuju.net/f/wQzOKQ</a></p><p>第十一周作业提交链接：<a href="https://jinshuju.net/f/IVQimK">https://jinshuju.net/f/IVQimK</a></p><p>第十二周作业提交链接：<a href="https://jinshuju.net/f/HxOBY5">https://jinshuju.net/f/HxOBY5</a></p><p>第十三周作业提交链接：<a href="https://jinshuju.net/f/QuL00Q">https://jinshuju.net/f/QuL00Q</a></p><p>第十四周作业提交链接：<a href="https://jinshuju.net/f/ocTopp">https://jinshuju.net/f/ocTopp</a></p><p>第十五周作业提交链接：<a href="https://jinshuju.net/f/nL407C">https://jinshuju.net/f/nL407C</a></p><h1 id="课程重要点记录"><a href="#课程重要点记录" class="headerlink" title="课程重要点记录"></a>课程重要点记录</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><h3 id="第一节：Java-EE-单体架构"><a href="#第一节：Java-EE-单体架构" class="headerlink" title="第一节：Java EE 单体架构"></a>第一节：Java EE 单体架构</h3><h3 id="第二节-数据存储之-JDBC"><a href="#第二节-数据存储之-JDBC" class="headerlink" title="第二节 数据存储之 JDBC"></a>第二节 数据存储之 JDBC</h3><p>ORM框架是怎么实现的，实现一个ORM框架</p><p>Servlet，Filter是怎么实现Controller，即如何实现自己的mvc框架</p><p>JNDI-依赖查找注入</p><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><h3 id="第三节-数据存储之-JPA"><a href="#第三节-数据存储之-JPA" class="headerlink" title="第三节 数据存储之 JPA"></a>第三节 数据存储之 JPA</h3><h3 id="第四节-数据校验"><a href="#第四节-数据校验" class="headerlink" title="第四节 数据校验"></a>第四节 数据校验</h3><p>spring依赖查找和依赖注入的实现</p><p>hibernate是如何验证的</p><h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><h3 id="第五节-配置管理与-Java-Logging"><a href="#第五节-配置管理与-Java-Logging" class="headerlink" title="第五节 配置管理与 Java Logging"></a>第五节 配置管理与 Java Logging</h3><h3 id="第六节-监控管理"><a href="#第六节-监控管理" class="headerlink" title="第六节 监控管理"></a>第六节 监控管理</h3><p>如何通过MBean实现JConsole调用的一个效果</p><p>可以在JConsole中暴露进行远程调用</p><p>是点对点的操作，分布式的话使用消息的方式 </p><p>Introspector  内省</p><p>Composite 组合</p><p>Tabular 表格式的</p><h2 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h2><h3 id="第七节-Maven-项目管理"><a href="#第七节-Maven-项目管理" class="headerlink" title="第七节 Maven 项目管理"></a>第七节 Maven 项目管理</h3><h3 id="第八节-持续集成和持续交付"><a href="#第八节-持续集成和持续交付" class="headerlink" title="第八节 持续集成和持续交付"></a>第八节 持续集成和持续交付</h3><h2 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h2><h3 id="第九节"><a href="#第九节" class="headerlink" title="第九节"></a>第九节</h3><h3 id="第十节"><a href="#第十节" class="headerlink" title="第十节"></a>第十节</h3><h3 id="后续记录"><a href="#后续记录" class="headerlink" title="后续记录"></a>后续记录</h3><p>reactive streams规范</p><p>javax.ws.rs.client</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 数据存储之 JPA</title>
      <link href="2021/02/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%89%E8%8A%82%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%20JPA/"/>
      <url>2021/02/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%89%E8%8A%82%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%20JPA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://weread.qq.com/web/reader/328329c07198d703328ecb3">https://weread.qq.com/web/reader/328329c07198d703328ecb3</a></p><h1 id="小马哥的-Java-项目实战营-Java-EE-项目-第三节-数据存储之-JPA"><a href="#小马哥的-Java-项目实战营-Java-EE-项目-第三节-数据存储之-JPA" class="headerlink" title="小马哥的 Java 项目实战营 Java EE 项目 - 第三节 数据存储之 JPA"></a>小马哥的 Java 项目实战营 Java EE 项目 - 第三节 数据存储之 JPA</h1><p>小马哥（mercyblitz）<strong>我是谁？</strong> </p><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>•Java 劝退师 </p><p>• Apache Dubbo PMC </p><p>• Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><h1 id="Java-Persistence-API-（JPA）"><a href="#Java-Persistence-API-（JPA）" class="headerlink" title="Java Persistence API**（JPA）**"></a><strong>Java Persistence API**</strong>（JPA）**</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JPA 1.0 整合查询语言（Query）和对象关系映射（ORM）元数据定义。 </p><p>JPA 2.0 在 1.0 的基础上，增加 Criteria 查询、元数据API以及校验支持。 </p><p>2009 年 JPA 2.0 最终规范发布（JSR-317） </p><p>2006 年 JPA 1.0 最终规范发布（JSR-220） </p><p>EJB 3.0 的子规范</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体（Entities） </p><p>轻量级持久化域（Domain）对象。实体类可能利用辅助类或者用于表示状态。 </p><p>• 约束 </p><p>• 实体类必须使用@Entity标注或者XML描述 </p><p>• 实体类至少包含一个默认构造器，并且构造器必须是public 或者 protected </p><p>• 实体类必须是顶级类，不能是枚举或者接口 </p><p>• 实体类禁止是final类 </p><p>• 实体支持继承、多态关联以及多态查询</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体持久字段和属性 </p><p>实体持久状态由字段（Fields）或者属性（Properties），字段即实例的属性或变量， </p><p>属性则是JavaBeans实例的setter或getter方法。 </p><p>实例属性的访问性必须是private、protected或者包可见，属性的可见性必须是 </p><p>public或者protected。 </p><p>字段和属性可能是单一类型值或集合类型值。</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 持久字段和属性类型 </p><p>• 原生类型 </p><p>• Java Serializable类型 </p><p>• 自定义类型（实现Serializable接口） </p><p>• 枚举 </p><p>• 实体类型（包括集合实体类型） </p><p>• 嵌入类型</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 字段和属性访问类型（Access Type） </p><p>• 默认访问类型 </p><p>• 非 transient 或者@Transient字段 </p><p>• 非@Transient 属性 </p><p>• 显示访问类型 </p><p>• 注解类型 </p><p>• 实体类 </p><p>• 映射超类 </p><p>• 嵌套类 </p><p>• 注解 </p><p>• @Access(AccessType.FIELD) 字段 </p><p>• @Access(AccessType.PROPERTY) 属性</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体主键（Primary Key）默认访问类型 </p><p>• 每个实体必须存在主键，主键必须定义在实体类。 </p><p>• 简单主键 </p><p>• @Id </p><p>• 复合主键 </p><p>• @EmbeddedId </p><p>• @IdClass</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体关系 </p><p>实体关系可能一对一、一对多、多对一或多对多，这些关系是多态性的，可以是 </p><p>单向或者双向。 </p><p>• 注解表述方式 </p><p>• @OneToOne </p><p>• @OneToMany </p><p>• @ManyToOne </p><p>• @ManyToMany</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体双向关系 </p><p>实体双向关系是指两实体之间不仅存在拥有方（owning），也存在倒转方 </p><p>（inverse）。主方决定了更新级联关系到数据库。 </p><p>• 规则 </p><p>• 倒转必须通过@OneToOne、@OneToMany或者@ManyToMany中的mappedBy属性方 </p><p>法关联到拥有方的字段或者属性。 </p><p>• 一对多、多对一双向关系中的多方必须是主方，因此@ManyToOne 注解不能指定 </p><p>mappedBy属性方法。 </p><p>• 双向一对一关系中，主方相当于包含外键的一方。 </p><p>• 双向多对多关系中，任何一方可能是拥有方。</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体双向关系：一对一（OneToOne） </p><p>假设： </p><p>l 实体A引用单个实体B的实例 </p><p>l 实体B引用单个实体A的实例 </p><p>l 实体A在关系中处于拥有方 </p><p>默认映射 </p><p>• 实体A被映射到数据表A </p><p>• 实体B被映射到数据表B </p><p>• 表A包含一个外键关联B </p><p>举例：客户（Customer）与信用卡（Credit Card）的关系</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体双向关系：多对一（ManyToOne）/一对多（OneToMany） </p><p>假设： </p><p>l 实体A引用单个实体B的实例 </p><p>l 实体B引用多个实体A的实例 </p><p>l 实体A在关系中处于拥有方 </p><p>默认映射 </p><p>• 实体A被映射到数据表A </p><p>• 实体B被映射到数据表B </p><p>• 表A包含一个外键关联B </p><p>举例：店铺（Store）与客户（Customer）的关系</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体双向关系：多对多（ManyToMany） </p><p>假设： </p><p>l 实体A引用多个实体B的实例 </p><p>l 实体B引用多个实体A的实例 </p><p>l 实体A在关系中处于拥有方 </p><p>默认映射 </p><p>• 实体A被映射到数据表A </p><p>• 实体B被映射到数据表B </p><p>• 存在一个名为A_B的关联表（拥有方表名为前缀），其中包含两个外键列，一列关联表A的主键， </p><p>另外一列关联表B的主键</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体单向关系：一对一（OneToOne） </p><p>假设： </p><p>l 实体A引用单个实体B的实例 </p><p>l 实体B没有引用单个实体A的实例 </p><p>l 实体A在关系中处于拥有方 </p><p>默认映射 </p><p>• 实体A被映射到数据表A </p><p>• 实体B被映射到数据表B </p><p>• 表A包含一个外键关联B</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体单向关系：一对多（OneToMany） </p><p>假设： </p><p>l 实体A引用多个实体B的实例 </p><p>l 实体B没有引用单个实体A的实例 </p><p>l 实体A在关系中处于拥有方 </p><p>默认映射 </p><p>• 实体A被映射到数据表A </p><p>• 实体B被映射到数据表B </p><p>• 存在一个名为A_B的关联表（拥有方表名为前缀），其中包含两个外键列，一列关联表A的主键， </p><p>另外一列关联表B的主键</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体单向关系：多对多（ManyToMany） </p><p>假设： </p><p>l 实体A引用多个实体B的实例 </p><p>l 实体B没有引用单个实体A的实例 </p><p>l 实体A在关系中处于拥有方 </p><p>默认映射 </p><p>• 实体A被映射到数据表A </p><p>• 实体B被映射到数据表B </p><p>• 存在一个名为A_B的关联表（拥有方表名为前缀），其中包含两个外键列，一列关联表A的主键， </p><p>另外一列关联表B的主键</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体继承（Inheritance） </p><p>实体可继承其他实体。实体之间支持继承、多态关联、多态查询 </p><p>继承方式 </p><p>• 继承抽象实体类 </p><p>• @Inheritance </p><p>• 继承已映射父类型 </p><p>• @MappedSuperclass </p><p>• @AssociationOverride </p><p>• 继承非实体类型</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体操作（Operations） </p><p>实体管理器 - EntityManager</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210305124422.png" alt="image-20210305124422838"></p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体实例生命周期（Life Cycle） </p><p>• 创建 </p><p>• 持久化 </p><p>• 移除 </p><p>• 同步到数据库 </p><p>• 刷新实例 </p><p>• 淘汰</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 持久化上下文使用期限（Persistence Context Lifetime） </p><p>• 类型 </p><p>• 事务类型（默认） </p><p>• 扩展类型 </p><p>• 阶段 </p><p>• 事务提交阶段 </p><p>• 事务类型：实体状态-&gt;脱管 </p><p>• 扩展类型：实体状态-&gt;继续维持 </p><p>• 事务回滚阶段 </p><p>• 实体状态-&gt;脱管</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体监听器和回调方法 </p><p>• 实体监听器 - @EntityListeners </p><p>• 回调方法 </p><p>• @PrePersist </p><p>• @PostPersist </p><p>• @PreRemove </p><p>• @PostRemove </p><p>• @PreUpdate </p><p>• @PostUpdate </p><p>• @PostLoad</p><p><strong>Java Persistence API**</strong>（JPA）** </p><p>• 实体监听器和回调方法 </p><p>• 实体监听器 - @EntityListeners </p><p>• 回调方法 </p><p>• @PrePersist </p><p>• @PostPersist </p><p>• @PreRemove </p><p>• @PostRemove </p><p>• @PreUpdate </p><p>• @PostUpdate </p><p>• @PostLoad</p><h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>users表（主）</p><table><thead><tr><th>id</th><th>name</th><th>Password</th></tr></thead><tbody><tr><td>1</td><td>mercyblitz</td><td><code>******</code></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>user_address_rel</p><table><thead><tr><th>id</th><th>User_id</th><th>Address_id</th></tr></thead><tbody><tr><td>100</td><td>1</td><td>10000</td></tr><tr><td>101</td><td>1</td><td>10001</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>user_addresses（副）</p><table><thead><tr><th>id</th><th>address</th></tr></thead><tbody><tr><td>10000</td><td>Shanghai</td></tr><tr><td>10001</td><td>Beijing</td></tr><tr><td></td><td></td></tr></tbody></table><p>User(id,name password)</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">class"coom.acme.User"</span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"com.acme.User"</span><span class="token punctuation">;</span><span class="token class-name">Class</span> klass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span>klass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>组合和关联</p><h3 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h3><p>primary key (id, name)</p><p>@IdClass</p><p>public class PrimaryKey{</p><p>​    Long id;</p><p>​    String name;</p><p>}</p><h3 id="JAP-组合和关联"><a href="#JAP-组合和关联" class="headerlink" title="JAP 组合和关联"></a>JAP 组合和关联</h3><h3 id="JAP-实体管理器"><a href="#JAP-实体管理器" class="headerlink" title="JAP 实体管理器"></a>JAP 实体管理器</h3><p>EntityManager == Hibernamte Session = MyBatis Session &gt;= JDBC Connection</p><ul><li>缓存（一级，二级）</li><li>延迟加载（特有功能）</li></ul><h2 id="关联技术"><a href="#关联技术" class="headerlink" title="关联技术"></a>关联技术</h2><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h4 id="假设有一个Entity-Class关联其他Class"><a href="#假设有一个Entity-Class关联其他Class" class="headerlink" title="假设有一个Entity Class关联其他Class"></a>假设有一个Entity Class关联其他Class</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Address</span><span class="token punctuation">&gt;</span></span> addresses<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Address</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAddresses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// lazy load（加载）</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>延迟加载是通过类的字节码提升来做的，因此，从Session获取到的Entity Object的类型是一个字节码提升的类，那么原始的类型Entity是它的子类。所以原始Entity类型不能修饰为final</p><h3 id="Session-load-和-get方法的区别？"><a href="#Session-load-和-get方法的区别？" class="headerlink" title="Session load 和 get方法的区别？"></a>Session load 和 get方法的区别？</h3><p>get有缓存</p><p>load重新加载（无缓存）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节：Java EE 单体架构</title>
      <link href="2021/02/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9AJava-EE-%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
      <url>2021/02/25/java%E9%A1%B9%E7%9B%AE%E8%AE%AD%E7%BB%83%E8%90%A5/%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9AJava-EE-%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="小马哥的-Java-项目实战营-Java-EE-项目-第一节：Java-EE-单体架构"><a href="#小马哥的-Java-项目实战营-Java-EE-项目-第一节：Java-EE-单体架构" class="headerlink" title="小马哥的 Java 项目实战营  Java EE 项目 - 第一节：Java EE 单体架构"></a>小马哥的 Java 项目实战营  Java EE 项目 - 第一节：Java EE 单体架构</h1><p>小马哥（mercyblitz）</p><h2 id="我是谁？"><a href="#我是谁？" class="headerlink" title="我是谁？"></a><strong>我是谁？</strong></h2><p>小马哥（mercyblitz） </p><p>•父亲 </p><p>• Java 劝退师 </p><p>•Apache Dubbo PMC </p><p>•Spring Cloud Alibaba 架构师 </p><p>•《Spring Boot 编程思想》作者</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a><strong>主要内容</strong></h2><ol><li><p>总体目标 </p></li><li><p>项目需求说明 </p></li><li><p>迭代 v1：需要实现 </p></li><li><p>迭代 v2：日志管理 </p></li><li><p>问答互动</p></li></ol><h2 id="总体目标"><a href="#总体目标" class="headerlink" title="总体目标"></a><strong>总体目标</strong></h2><p>• 理解需求描述，并深度探讨潜在需求 </p><p>• 掌握 Java 生态系统、企业级架构和技术规范 </p><p>• 学会使用 Java 标准技术栈实现互联网平台项目</p><p>Cyy：项目分为技术性的和工程性的，工程性的网上有很多项目，主要还是要了解运行背后的逻辑</p><p>• 功能需求 </p><p>• 用户注册 </p><p>• 用户名注册 </p><p>• 邮箱注册 </p><p>• 手机注册 </p><p>• 用户登录 </p><p>• 用户名登录 </p><p>• 邮箱登录 </p><p>• 手机登录 </p><h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a><strong>项目需求</strong></h2><p>• 非功能需求 </p><p>• 系统架构 </p><p>• 单体架构 </p><h2 id="迭代-v1：需要实现"><a href="#迭代-v1：需要实现" class="headerlink" title="迭代 v1：需要实现"></a><strong>迭代</strong> <strong>v1</strong>：需要实现</h2><p>• 技术栈 </p><p>• 应用容器 </p><p>• Servlet Engine - Apache Tomcat 8+ </p><p>• Web 服务 </p><p>• 基于 Servlet 实现的自研 MVC 框架，支持 JAX-RS 注解 </p><p>• 数据存储 </p><p>• 基于 JDBC 实现 </p><h2 id="Servlet-概念"><a href="#Servlet-概念" class="headerlink" title="Servlet 概念"></a>Servlet 概念</h2><p>Servlet 是一种基于 Java 技术的 Web 组件，用于生成动态内容，由容器管理。类似于其 </p><p>他 Java 技术组件，Servlet 是平台无关的 Java 类组成，并且由 Java Web 服务器加载 </p><p>执行。通常情况，由 Servlet 容器提供运行时环境。Servlet 容器，有时候也称作为 </p><p>Servlet 引擎，作为Web服务器或应用服务器的一部分。通过请求和响应对话，提供Web </p><p>客户端与 Servlets 交互的能力。容器管理Servlets实例以及它们的生命周期。</p><h2 id="Servlet-主要版本"><a href="#Servlet-主要版本" class="headerlink" title="Servlet 主要版本"></a>Servlet 主要版本</h2><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210225190513.png" alt="image-20210225190512938"></p><h2 id="Servlet-核心-API"><a href="#Servlet-核心-API" class="headerlink" title="Servlet 核心 API"></a>Servlet 核心 API</h2><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210225190524.png" alt="image-20210225190524058"></p><p>这里的类都看了一遍。。</p><h2 id="Servlet-组件注册方式"><a href="#Servlet-组件注册方式" class="headerlink" title="Servlet 组件注册方式"></a>Servlet 组件注册方式</h2><p>• 传统 web.xml 注册方式 </p><p>• 注解注册方式（Servlet 3.0+） </p><p>• 编码注册方式（Servlet 3.0+）</p><h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><p>• 声明（应用行为） </p><p>• 注册（容器行为） </p><p>• 初始化：Servlet#init(ServletConfig) </p><p>• 服务：Servlet#service(ServletRequest, ServletResponse) </p><p>• 销毁：Servlet#destroy()</p><h2 id="Filter-生命周期"><a href="#Filter-生命周期" class="headerlink" title="Filter 生命周期"></a>Filter 生命周期</h2><p>• 声明（应用行为） </p><p>• 注册（容器行为） </p><p>• 初始化：Filter#init(FilterConfig) </p><p>• 过滤: Filter#doFilter(ServletRequest,ServletResponse,FilterChain) </p><p>• 毁：Filter#destroy()</p><h2 id="ServletContext-生命周期"><a href="#ServletContext-生命周期" class="headerlink" title="ServletContext 生命周期"></a>ServletContext 生命周期</h2><p>• 声明（应用行为） </p><p>• 注册（容器行为） </p><p>• 初始化：ServletContextListener#contextInitialized </p><p>• 销毁：ServletContextListener#contextDestroyed</p><h2 id="Servlet-3-1-规范重点章节"><a href="#Servlet-3-1-规范重点章节" class="headerlink" title="Servlet 3.1 规范重点章节"></a>Servlet 3.1 规范重点章节</h2><p>• CHAPTER 2 The Servlet Interface </p><p>• CHAPTER 3 The Request </p><p>• CHAPTER 4 Servlet Context </p><p>• CHAPTER 5 The Response </p><p>• CHAPTER 9 Dispatching Requests </p><p>• CHAPTER 11Application Lifecycle Events </p><p>• CHAPTER 12 Mapping Requests to Servlets</p><p>nio</p><p>buffer</p><h2 id="EL-概念"><a href="#EL-概念" class="headerlink" title="EL 概念"></a>EL 概念</h2><p>EL是Expression Language的英文缩写（表达式语言）,原来是为了方便存储数据所自定义的语言。当时呢，只能在JSTL1.0的标签中使用，现在已经成为了JSP2.0的规范之一，已经成为了一项成熟的、标准的技术。 </p><p>EL表达式规定为：eval-expression 和 literal-expression,同时EL表达式支持Composite expressions</p><h2 id="EL-语法支持"><a href="#EL-语法支持" class="headerlink" title="EL 语法支持"></a>EL 语法支持</h2><p>• 表达式：取值表达式、字面值表达式、组合表达式 </p><p>• 操作符号[]和. </p><p>• 操作符：算术操作符、关系操作符(ralational operator)、逻辑操作符(logic operator)、空值操作符(empty operator)、条件操作符(conditonal operator) </p><p>• 隐藏对象(hidden object) </p><p>• EL函数(EL function)</p><h2 id="JSTL-概念"><a href="#JSTL-概念" class="headerlink" title="JSTL 概念"></a>JSTL 概念</h2><p>JSTL全名为JSP Standard Tag Libaray(JSP标准标签函数库),目前主流的版本为1.2,它是 </p><p>由JCP(Java Commnunity Process)制定的标准规范,提供给我们一个标准通用的标签函数 </p><p>库，主要分为5大类： </p><p>• 核心标签库（Core) </p><p>• I18N格式标签库(I18N-capable format tab libaray) </p><p>• SQL标签库(SQL tag libaray) </p><p>• XML标签库(XML tag libaray) </p><p>• 函数标签库(Functions tag libaray)</p><h2 id="自研-Web-MVC-框架-模型"><a href="#自研-Web-MVC-框架-模型" class="headerlink" title="自研 Web MVC 框架 - 模型"></a>自研 Web MVC 框架 - 模型</h2><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210225190555.png" alt="image-20210225190555773"></p><p>• 技术栈 </p><p>• Servlet Logging API </p><p>• ServletContext#log 方法 </p><p>• Java Logging API </p><p>• java.util.logging.Logger </p><p><strong>迭代</strong> <strong>v2**</strong>：日志管理**</p><h1 id="课堂记录"><a href="#课堂记录" class="headerlink" title="课堂记录"></a>课堂记录</h1><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>SQuirreL SQL Client</li></ul><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>代码地址：<a href="https://github.com/mercyblitz/geekbang-lessons">https://github.com/mercyblitz/geekbang-lessons</a></p><p>编译命令：<code>mvn clean package -U</code></p><p>启动命令：<code>java -jar user-web/target/user-web-v1-SNAPSHOT-war-exec.jar</code></p><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul><li>API使用</li><li>整体架构设计</li></ul><h4 id="Servlet-Forward技术"><a href="#Servlet-Forward技术" class="headerlink" title="Servlet Forward技术"></a>Servlet Forward技术</h4><ul><li>实例1 Spring Framework Web DefaultServletHttpRequestHandler forward到容器文件Servlet实例</li><li>实例2 自研发 Web MVC</li><li>实例3 Spring Web MVC 模板渲染</li></ul><p>Servlet forward 它是转发请求到下一个Servlet</p><p>Servlet forward 是否会转发到Filter上去。会</p><h3 id="自研Web-MVC框架"><a href="#自研Web-MVC框架" class="headerlink" title="自研Web MVC框架"></a>自研Web MVC框架</h3><p>控制器接口：Conntoller</p><ul><li>页面渲染Controller：PageController（集成controller）</li><li>REST Body Controller：RestController（集成controller）</li></ul><h4 id="Servlet-处理静态内容"><a href="#Servlet-处理静态内容" class="headerlink" title="Servlet 处理静态内容"></a>Servlet 处理静态内容</h4><ul><li>Tomcat ： org.apache.catalina.servlets.DefaultServlet</li><li>Jetty</li><li>Weblogic</li><li>WebSphere </li></ul><blockquote><p>关联一个问题：springboot 为什么把css或者js放在static目录下，可以进行读取</p><p>org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler</p><ul><li>Tomcat（JBoss）</li><li>Jetty</li><li>Resin</li><li>WebLogic</li><li>WebSphere</li></ul></blockquote><h3 id="服务端页面渲染"><a href="#服务端页面渲染" class="headerlink" title="服务端页面渲染"></a>服务端页面渲染</h3><h4 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h4><p>jsp就是Servlet的拓展</p><p>通过模板代码-&gt;Servlet字节码</p><h4 id="流行前端框架"><a href="#流行前端框架" class="headerlink" title="流行前端框架"></a>流行前端框架</h4><ul><li>vue.js</li><li>reactjs</li></ul><p>都需要编译</p><ul><li>nodejs</li><li>源代码-&gt;js代码</li></ul><h2 id="相关基础"><a href="#相关基础" class="headerlink" title="相关基础"></a>相关基础</h2><h3 id="java归档文件"><a href="#java归档文件" class="headerlink" title="java归档文件"></a>java归档文件</h3><ul><li>zip<ul><li>Jar:Java Archiever</li><li>War:Web Archiever</li><li>Ear:Enterprise Archiever</li></ul></li></ul><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>多值参数  <a href="http://www.abc.com/def?a=1&amp;a=2&amp;a=3">http://www.abc.com/def?a=1&amp;a=2&amp;a=3</a></p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><p>GUI 基于进程，php，aapche Httpd</p><p>Servlet - 基于线程</p><ul><li>Struts1&amp;2</li><li>Spring Web MVC</li><li>JSF    </li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Tomcat NIO 模型：</p><p>请求头（Head）</p><p>请求体（Body）</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210226095831.png" alt="image-20210226095831635"></p><p><a href="http://tomcat.apache.org/tomcat-8.5-doc/config/http.html#Connector_Comparison">http://tomcat.apache.org/tomcat-8.5-doc/config/http.html#Connector_Comparison</a></p><p>GoF23 Patterns</p><p>2003 - J2EE Core Patterns</p><p>JSR : <a href="https://github.com/mercyblitz/jsr">https://github.com/mercyblitz/jsr</a></p><p>Apache Digester：<a href="http://commons.apache.org/proper/commons-digester/">http://commons.apache.org/proper/commons-digester/</a></p><p>微信：</p><p>老：mercyblitz</p><p>新：mercyblitz-1985</p><p>训练营项目工程代码地址：<br>GitHub：<a href="https://github.com/mercyblitz/geekbang-lessons">https://github.com/mercyblitz/geekbang-lessons</a><br>Gitee：<a href="https://gitee.com/geektime-geekbang/mercyblitz-projects">https://gitee.com/geektime-geekbang/mercyblitz-projects</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> Java 项目实战营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8-stream</title>
      <link href="2021/02/23/java/java8/java8-stream/"/>
      <url>2021/02/23/java/java8/java8-stream/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-util-stream.html">java-8 stream</a></p>]]></content>
      
      
      <categories>
          
          <category> java8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>维基百科上的介绍，很全面：<a href="https://en.wikipedia.org/wiki/Software_design_pattern">Software design pattern</a></p><p>设计模式区分为创建型模式，结构型模式，行为型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-多容器间交互</title>
      <link href="2021/02/21/docker/docker-%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%97%B4%E4%BA%A4%E4%BA%92/"/>
      <url>2021/02/21/docker/docker-%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%97%B4%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/07_multi_container/">docker-多容器应用官网示例</a></p><p>到目前为止，我们一直在使用单个容器应用程序。但是，我们现在想将MySQL添加到应用程序堆栈中。通常会出现以下问题-“ MySQL将在哪里运行？将它安装在同一个容器中还是单独运行？” 通常，<strong>每个容器都应该做一件事情并做好。</strong>原因如下：</p><ul><li>您很有可能需要以与数据库不同的方式扩展API和前端</li><li>单独的容器可让您隔离版本和更新版本</li><li>虽然您可以在本地使用数据库的容器，但可能要在生产环境中使用数据库的托管服务。然后，您不想随应用程序一起提供数据库引擎。</li><li>运行多个进程将需要一个进程管理器（容器仅启动一个进程），这增加了容器启动/关闭的复杂性</li></ul><p>还有更多原因。因此，我们将更新我们的应用程序使其工作如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221170100.png" alt="Todo App已连接到MySQL容器"></p><h2 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h2><p>请记住，默认情况下，容器是独立运行的，并且对同一台计算机上的其他进程或容器一无所知。那么，我们如何允许一个容器与另一个容器对话？答案是 <strong>网络</strong>。现在，您不必是网络工程师（万岁！）。只要记住这个规则…</p><blockquote><p><strong>笔记</strong></p><p>如果两个容器在同一网络上，它们可以相互通信。如果不是，他们就不会。</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>有两种将容器放置在网络上的方法：1）在开始时分配它，或2）连接现有容器。现在，我们将首先创建网络并在启动时附加MySQL容器。</p><ol><li><p>创建网络。</p><pre class="line-numbers language-none"><code class="language-none">docker network create todo-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动一个MySQL容器并将其附加到网络。我们还将定义一些环境变量，数据库将使用这些变量来初始化数据库（请参见<a href="https://hub.docker.com/_/mysql/">MySQL Docker Hub列表中</a>的“环境变量”部分）。 <code>docker pull mysql</code></p><pre class="line-numbers language-none"><code class="language-none">docker run -d \    --network todo-app --network-alias mysql \    -v todo-mysql-data:/var/lib/mysql \    -e MYSQL_ROOT_PASSWORD=secret \    -e MYSQL_DATABASE=todos \    mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用的是PowerShell，则使用此命令。</p><pre class="line-numbers language-none"><code class="language-none">docker run -d `    --network todo-app --network-alias mysql `    -v todo-mysql-data:/var/lib/mysql `    -e MYSQL_ROOT_PASSWORD=secret `    -e MYSQL_DATABASE=todos `    mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您还将看到我们指定了<code>--network-alias</code>标志。我们稍后再讲。</p><blockquote><p><strong>小费</strong></p><p>您会注意到我们使用的是<code>todo-mysql-data</code>这里命名的卷，并将其挂载<code>/var/lib/mysql</code>在MySQL存储数据的位置。但是，我们从未运行过<code>docker volume create</code>命令。Docker认识到我们要使用命名卷，并自动为我们创建一个。</p></blockquote></li><li><p>为了确认我们已启动并运行数据库，请连接到数据库并验证其是否连接。</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it &lt;mysql-container-id&gt; mysql -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当出现密码提示时，输入<strong>secret</strong>。在MySQL Shell中，列出数据库并确认您看到该<code>todos</code>数据库。</p><pre class="line-numbers language-cli" data-language="cli"><code class="language-cli">mysql&gt; SHOW DATABASES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您应该看到如下所示的输出：</p><pre class="line-numbers language-none"><code class="language-none">+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                || todos              |+--------------------+5 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>万岁！我们有我们的<code>todos</code>数据库，可以随时使用！</p></li></ol><h2 id="连接到"><a href="#连接到" class="headerlink" title="连接到"></a>连接到</h2><p>现在我们知道MySQL已启动并正在运行，让我们使用它吧！但是，问题是…如何？如果我们在同一网络上运行另一个容器，我们如何找到该容器（记住每个容器都有自己的IP地址）？</p><p>为了弄清楚这一点，我们将使用<a href="https://github.com/nicolaka/netshoot">nicolaka / netshoot</a>容器，该容器附带了<em>许多</em>工具，可用于对网络问题进行故障排除或调试。</p><ol><li><p>使用nicolaka / netshoot映像启动一个新容器。确保将其连接到同一网络。</p><pre class="line-numbers language-none"><code class="language-none">docker run -it --network todo-app nicolaka/netshoot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在容器内部，我们将使用<code>dig</code>命令，这是一个有用的DNS工具。我们将查找主机名的IP地址<code>mysql</code>。</p><pre class="line-numbers language-none"><code class="language-none">dig mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样您将得到一个输出…</p><pre class="line-numbers language-none"><code class="language-none">; &lt;&lt;&gt;&gt; DiG 9.14.1 &lt;&lt;&gt;&gt; mysql;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32162;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0   ;; QUESTION SECTION:;mysql.INA   ;; ANSWER SECTION:mysql.600INA172.23.0.2   ;; Query time: 0 msec;; SERVER: 127.0.0.11#53(127.0.0.11);; WHEN: Tue Oct 01 23:47:24 UTC 2019;; MSG SIZE  rcvd: 44<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在“答复部分”中，您将看到解决该问题的<code>A</code>记录 （您的IP地址很可能具有不同的值）。尽管通常不是有效的主机名，但Docker能够将其解析为具有该网络别名的容器的IP地址（还记得我们之前使用的 标志吗？）。<code>mysql``172.23.0.2``mysql``--network-alias</code></p><p>这意味着…我们的应用程序仅需要连接到名为的主机<code>mysql</code>，它将与数据库对话！没有比这更简单的了！</p></li></ol><h2 id="与MySQL运行你的应用程序"><a href="#与MySQL运行你的应用程序" class="headerlink" title="与MySQL运行你的应用程序"></a>与MySQL运行你的应用程序</h2><p>todo应用程序支持一些环境变量的设置，以指定MySQL连接设置。他们是：</p><ul><li><code>MYSQL_HOST</code> -正在运行的MySQL服务器的主机名</li><li><code>MYSQL_USER</code> -用于连接的用户名</li><li><code>MYSQL_PASSWORD</code> -用于连接的密码</li><li><code>MYSQL_DB</code> -连接后要使用的数据库</li></ul><blockquote><p><strong>通过环境变量设置连接设置</strong></p><p>尽管通常可以使用env vars设置连接设置以进行开发，但是 在生产环境中运行应用程序时，<strong>强烈建议不要</strong>使用它。Docker的前安全主管Diogo Monica <a href="https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/">写了一篇很棒的博客文章，</a> 解释了为什么。</p><p>一种更安全的机制是使用容器编排框架提供的秘密支持。在大多数情况下，这些机密会作为文件安装在正在运行的容器中。您会看到许多应用程序（包括MySQL映像和todo应用程序）也支持带有<code>_FILE</code>后缀的env var，以指向包含变量的文件。</p><p>例如，设置<code>MYSQL_PASSWORD_FILE</code>var将使应用程序将引用文件的内容用作连接密码。Docker不做任何支持这些环境变量的事情。您的应用将需要知道寻找变量并获取文件内容。</p></blockquote><p>在解释了所有这些内容之后，让我们开始开发就绪容器！</p><ol><li><p>我们将指定上面的每个环境变量，并将容器连接到我们的应用程序网络。</p><pre class="line-numbers language-none"><code class="language-none">docker run -dp 3000:3000 \  -w /app -v "$(pwd):/app" \  --network todo-app \  -e MYSQL_HOST=mysql \  -e MYSQL_USER=root \  -e MYSQL_PASSWORD=secret \  -e MYSQL_DB=todos \  node:12-alpine \  sh -c "yarn install &amp;&amp; yarn run dev"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用的是PowerShell，则使用此命令。</p><pre class="line-numbers language-none"><code class="language-none">docker run -dp 3000:3000 `  -w /app -v "$(pwd):/app" `  --network todo-app `  -e MYSQL_HOST=mysql `  -e MYSQL_USER=root `  -e MYSQL_PASSWORD=secret `  -e MYSQL_DB=todos `  node:12-alpine `  sh -c "yarn install &amp;&amp; yarn run dev"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果我们查看容器（<code>docker logs &lt;container-id&gt;</code>）的日志，则应该看到一条消息，表明它正在使用mysql数据库。</p><pre class="line-numbers language-none"><code class="language-none"># Previous log messages omitted$ nodemon src/index.js[nodemon] 1.19.2[nodemon] to restart at any time, enter `rs`[nodemon] watching dir(s): *.*[nodemon] starting `node src/index.js`Connected to mysql db at host mysqlListening on port 3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在浏览器中打开应用程序，然后向待办事项列表中添加一些项目。</p></li><li><p>连接到mysql数据库并证明项目已被写入数据库。记住，密码是<strong>秘密的</strong>。</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it &lt;mysql-container-id&gt; mysql -p todos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在mysql shell中运行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; select * from todo_items;+--------------------------------------+--------------------+-----------+| id                                   | name               | completed |+--------------------------------------+--------------------+-----------+| c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! |         0 || 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome!        |         0 |+--------------------------------------+--------------------+-----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然，您的表看起来会有所不同，因为它包含您的项目。但是，您应该看到它们存储在这里！</p></li></ol><p>如果快速浏览Docker Dashboard，您会看到我们有两个正在运行的应用程序容器。但是，没有真正的迹象表明它们在单个应用程序中组合在一起。我们很快就会看到如何使它变得更好！</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221170125.png" alt="Docker Dashboard显示了两个未分组的应用程序容器"></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>至此，我们有了一个应用程序，该应用程序现在将其数据存储在运行在单独容器中的外部数据库中。我们了解了一些有关容器网络的知识，并了解了如何使用DNS执行服务发现。</p><p>但是，您很有可能开始对启动此应用程序所需做的一切感到有点不知所措。我们必须创建一个网络，启动容器，指定所有环境变量，公开端口等等！这要记住很多，这肯定会使事情很难传递给其他人。</p><p>在下一节中，我们将讨论Docker Compose。借助Docker Compose，我们可以以一种更简单的方式共享我们的应用程序堆栈，并允许其他人使用一个（简单的）命令将它们旋转起来！</p><h2 id="执行流程记录"><a href="#执行流程记录" class="headerlink" title="执行流程记录"></a>执行流程记录</h2><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker network create todo-app289342da8341dc4957bdc9e797242dad9a4e3eb26fbb982d0480a191b6f803bbcutiedeMacBook-Pro:app cutie$ docker run -d \&gt;      --network todo-app --network-alias mysql \&gt;      -v todo-mysql-data:/var/lib/mysql \&gt;      -e MYSQL_ROOT_PASSWORD=secret \&gt;      -e MYSQL_DATABASE=todos \&gt;      mysql:5.7cd2f6e9da40e7658e639f0222de723b4b2444295cb76fbcb2ffa60feac97be7bcutiedeMacBook-Pro:app cutie$ docker exec -it cd2f6e9da40e7658e639f0222de723b4b2444295cb76fbcb2ffa60feac97be7b  mysql -pEnter password:ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)cutiedeMacBook-Pro:app cutie$ docker exec -it cd2f6e9da40e7658e639f0222de723b4b2444295cb76fbcb2ffa60feac97be7b  mysql -pEnter password:ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)cutiedeMacBook-Pro:app cutie$ docker exec -it cd2f6e9da40e7658e639f0222de723b4b2444295cb76fbcb2ffa60feac97be7b  mysql -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.32 MySQL Community Server (GPL)Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                || todos              |+--------------------+5 rows in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker run -it --network todo-app nicolaka/netshootUnable to find image 'nicolaka/netshoot:latest' locallylatest: Pulling from nicolaka/netshoot4c0d98bf9879: Downloadingdf962687d630: Download completef4b598a64a46: Download completea3f487e8dfcb: Download complete0d084d29b530: Download completec40275cdc1a4: Download complete53d8247f861d: Download completelatest: Pulling from nicolaka/netshoot4c0d98bf9879: Pull completedf962687d630: Pull completef4b598a64a46: Pull completea3f487e8dfcb: Pull complete0d084d29b530: Pull completec40275cdc1a4: Pull complete53d8247f861d: Pull completeDigest: sha256:6ae5a524ab390824a43a29a8a2ec7b9c013736d98a0aed264f1132196098aac2Status: Downloaded newer image for nicolaka/netshoot:latest                    dP            dP                           dP                    88            88                           8888d888b. .d8888b. d8888P .d8888b. 88d888b. .d8888b. .d8888b. d8888P88'  `88 88ooood8   88   Y8ooooo. 88'  `88 88'  `88 88'  `88   8888    88 88.  ...   88         88 88    88 88.  .88 88.  .88   88dP    dP `88888P'   dP   `88888P' dP    dP `88888P' `88888P'   dPWelcome to Netshoot! (github.com/nicolaka/netshoot)root @ / [1] 🐳  → dig mysql; &lt;&lt;&gt;&gt; DiG 9.16.11 &lt;&lt;&gt;&gt; mysql;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 53757;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mysql.INA;; ANSWER SECTION:mysql.600INA172.19.0.2;; Query time: 4 msec;; SERVER: 127.0.0.11#53(127.0.0.11);; WHEN: Sun Feb 21 09:48:10 UTC 2021;; MSG SIZE  rcvd: 44<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记20210221</title>
      <link href="2021/02/21/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210221/"/>
      <url>2021/02/21/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0-20210221/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="33cc73a5f8d2549e6c89dfe333dc5a8460b687d0ee7ac5b199010aefe4063273">675ef3242d144ff249cb5b90ca678376166165578abddbd822aecd43a16808c1e034c13215e1aa5d1915b7f1e9fa7947bede05dfbe49d081f4154959ab3872efb169caf5ade0e9eeaf5d9a758d0e48ed1803dc65d8fc0cceeb76aa9637b66728172d393504be71d92bdb4e0e4887dd97bdc55164377c8a3fcae04a8d23a48ed724d6d6394e498ab93c2a946db359dbb0afcd6c92b3c59840c3ec48935e3b6f1bc603e359a73e1a4c9b8d4e878b1fdb7c8d5b84fe05e59f5621948662e3f34479ca6d6f0698e95bd3955f78072d48f1b1aab8ba57ef27afe498a7b3afb47ee9951127d68bb220856a24622f8a35c3dfe84f1fb44ef1f45602a606a0b1b577c36463b9f7664c86629d66a91aa6702f1504501602420e7b793e5242c7cdc9c1f2ab7d9eeb5d79f29c39b78f28425442af2a5fd6dad331b4cac420bbd7f8806cf4e665db82343160921fe5d936bbec336ed2938b9ee029c747396fa4c60a8f019422286226041fd913af8558fec507cf56232fc39b14a5645ec033e74ccfdb3413dc138d4d2ca5ad884fe456ec423549c003255cddd007eb0545b67645a86a8ec7bf9522b01ace7ae25f0241696fad5fc6d4f66c16f00e460614aacbc4c0c98ebf0fbe15d8d513fa1dcf2ad8910c354669a48bdb5e0581261b6e5661f672793e0bb91b5cabbf26d0558ee44e2616ac12cb502df8a9821ab4782fc3d3660a0f8f7549292ebf79c348a36835b852132d376fa941c7a19f411e894d0f83317b65881d694add538421131e51decb60a75b5314a1268afe9996e4f928609b38ae6a69128f3136c8a0f816e8021453887f6175966575fb71ef431cb2886205887584820e65daf8649ec50743bb45ec136c3f9adccc3b4cbf9d848ef75c168c4844cd6e760bd6139d79a82e736f3d39ec6019baf9571cd92134eec354a61bbda79cd045d5b26aebf0398dedfdfcce4c60425e904ebba816ecbdcabe353dde311e85d8af4ce904aab36622b093ae1645757da8168546580d18fcd349e708984fc99c7e468ba3d2df486b0fc57cf6d1683802016fe4c4a31cefa8a51e31c499fc13673621c61c274510ce6de8bf36bcd4e38aa36e99772be8e4533f5853849a4562296dde59015ee6f7d3902cf233cd7c6546167d78926cb17906bae38e1706bcc0febcde39c373a175829881c68b99838509efdfb0c93d188dc02745ad6f158e8c480e32487c153e4715a74f9753cb747bb55ca5f95a23426e992ec0d7c4d08bffd2638b56ad8168c933ce28455aacd7fddf5af1c98a4286cb7a739441ad5a3308d57f6c76aa17e18bf27561e52b6668eda263bc14c91ea68426ca0592bf922020d1a9915c8c3ff2db071f437b97406b4f960ed944270248d799fdcd74093f6b2f4787acecb3b1d57942594cbafe5428fe6b74782af316fb933e51d2a6c10b373db5e96c11b06fcafe56be2b3afc22528885d18b2dc21d3d12f246236343a7c1b6f21ff642b5e885c55f1aa7aca8c0c0b8c4ccb9eecb6e4002dd459d6e891e81abaaab313b397cce43143125a159ca90e258f498a4d2f993dfc7594daaea4686b91360838f88ec135441768981aaf8c4ce73a0996654de9410dfdfc416f7d7dfeb27e85fe971f71686c674e367745864ee6e2313949663ffe99e8f8042d229928ed6b948c267f3db8b1e705a831ee0859cfbe09731519aa2a5176b5b203ffdfa1154cd89091336d4fa36ae33c5779669af91653b0cb4c57bddc93682ceb2b4a0fbbf676341ae7dbe60e0fa109d6eca8c0f30924dbfa98409bf61cfebb5522e3bc5de6936ab7eb5ce47e1a74cc107bced3ae1c898c5fcaef1d81857c5901787ef5f88f1906075938cf1238a935453bb9b935ffba306fa3fa373d2cc705537421f743912c894b07ba556f2148db9046e4b19061e05b469b44b95a50e386c6469ad01015dd1a497a7c0c770aa2f2a35eada40514cac4592500b10730e550b4666b6a27ad9e247562133d2da825a00642a2d503c995c8c70c3a327218530d05a26f070ab7ce9af2caa7194c74c1326b7c3544fe8809fef85be3cf91402ebecd62838cac2a68c687112574ca7e852d39563f81fcfcdb4646f4fd0390e289dad67575ec0cb62f096009b55c3aa0c2f60367693e2f988f02f2af5290970e0d1e4a09a42d7fbaeca594d40860e60c0548f56a997131d76cac9fb96df55a102cf34759e12ed27802dde363060ccdf8b2ceef00aeddc4f9d2563a078d630960bd928ed2a83dcbdc7aafff4751c32a8b4613a3efed7bc37b3c0d66a65b2e988f6486394e682e7f14cbd0c3b137eb314b83b831c1f84f650d3b838db71034e4af61d4dc3c5438d0cb429c3a513ce894abe2bed8e29f12c4d2ddde6216428b37c40cbaf99c071c77de9e98ee4c7041507b51e147cc08ca0154073a4a844c0d1a2b363dbf97084db672e35ca338a6bf64f2c39bd2d60408f1dcb6aef624a697115b6d2d655a1b290743e3678be628bd8a45f8feb4cc62be4ada76af71d075be178dc9a5bc514df34357ce22e5a2c9163a1302356fa2bd211b3975e5be13ae3e34feb0cd3b23c634a81e10fe5aa8b3de4dc96f1c6427691dfacb45e4620ecdf37e071117ec8b553cfebde032f0a7fe41c2137ea72fce647fadd8e639ed10c46d46597a754ea92d134ce02f260f3ac2a0cb1a0dd752ad4a8c122f8f3a581b4aca76674d0e2498f199744b946caa464b6c89624af4722ab479679e40613a56e8a71ac0a8c2f51e2e834ad151700c2fb501622155fad3dc4b0f767808d5d9a848db8b0520646728ae99280f90ccf3054f9fb657c1eaa8ffbc2c7f1ccb7e3338be3a7e0b0710403f2224095ed101e1ca623e39cafb1de7fcf019852406090e373d62b3c22d146fff35737a0dc4aa5aae97061a3c9b75c318ddc0088927c5ecf6ba4991010ec8c8915a47e00b2c781e3ce2565c852893705db4e7877ad9b960589844bf2aadfe8fdd1dff05c4f5c53cd039b55f033dd2b21abd018b634aeb03e1f57fe2fd7ae8baf944bbdf6ec863857862eed0a069990e2a31b584a3cf21f09bd083f8310660f3c22857b7ba6b86753e78c59f27df6870d680179721b18e41c2c9344ffa7a8b492706584fa0d2db276b117d4385a4b2208e8ab18b9eca2921c63e8ea25e07477ef77ad31c2abf2c98410b1961511fbee15477cd28e60e95f799fb3a1e7133fc69ac8f18c04764349058bed699f5262098ac13d6252b4aa317ed71baa87916b344d07c4e2a0aff74cdbffbf319c503642062ea68713765ec6b87c5952ba636d61afcf03d5be6a68bcc92cf1eb0e18b7da034fa54297eba6d3b5a7eecb1753fdd2857aa765fd8a32f010df5a202060c6455e49ef271bf6958e056384ef77d71f1008cf628a24920711b91c330079f50adb71be85aebc69782a2fb61a9af267b2d10813da6ae7dea5fef3f0bf59b76c971e9034e230ead1a0729e5f405ab6d636d75112eb0de165b772d696e85e1550e79123469cc06231737f8ea0fd992799ab44815c859d9cb3ec0ff9f54ff8e3eae8cf99fdceccf70c9fa113fb95fa25bfbe29755c6138f3c4449b311c83c3c1f3c2eb32d22344d3e8c184a3dbad05d12670bf895e55fac7769e522fd2a8a67cd639daacc767dd9cd934f6d37fb071c14be36bdddd971ad2caa871c3a37774dd6c1b94536e3587ae986878946456b03fcb5ded9034003a3ab17dfdfa923fc16e0f5b67a3e6912a50aef130fcbaa000b1a766c6fe7ead05b4c7db599c515bfd4f5bf7c510eef453405ad9edd4c71a97a5cc730f6c0d957ad2ab493e479ef9934ad8858ad6e46e40d4c97c617268dffaeb5083724e3f1861883cf6e3972f1d64060128845e4ef08494f2a05deeae203dc3dde9df3d4f26df0e633e067da611a6a011342d5ff64d09e2a070d07ac7fd14f87a765a4867afc66834b9ec225e70f5d54ee809da23941eed2034d902637567385fcf520711a44d21ecc296a23bfa6af167e00e965318c53c60664b5b63836320db5f8b97d844ade27dc63da4a2e4249e7020f80b4438de23a7e43291dd74285df339b68fa0f37670b0f9b4c5bfc34179a3981eb7b648df8abc930db656da00d1ea9a5bd62223fe7e8331e0a08aaadc66a82dc694da1bf14bf2f11e4344b260bb460d4b26620a5ea16394d6fb12d1327deff252bbe2b15670ad5ad39e31690b1b35ec0b606cb0ce9bd4f36d47a7db6e94a89ae8a856e84c6c968275460f87e109543b1f942c73f0ec0ee77e380ee67bcf6c9ac2678ed4556ef1791ae6b751ec7740091818fdfe523ff5e19d2229f323dbe1fd59b166d6c6564c84d6e00e28ca25b69d10ba229d5b4373708be0027164d17d3974e42a29d9b3009451be4e303fe43cab80ffd56d29c55bc2daa735d1f42a31b2a0cb803f62d77f3fd668484beb8d783c389744e904870c0d9331d8f09a20823661bb903ad8ec79c2e8329e4473c820061a90f7ff3e644833dd7438f7080b5c93930523a14c75ea0a3448f835e2b2f15caab6ef1b197cacecd529addad90a48547517d7a1a0ccf6dbfb45aa0545482e8cf66f1e57ff7f93b8f586281bbe11cb12d61159cf9eaa3d24d060f0c79ad1fe061b1c607300d29e6f629eacb6e933a2f78a5a6ade89348994c699b71a421ec5f76164e62fe1079843fda68554e5ddac5db3a421c559ca4dfae9cdb825062d2a9365533b4915cd46cac46d4ebc844a9779becfe1b45f5210a663aa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="2021/02/19/docker/docker%E5%85%A5%E9%97%A8/"/>
      <url>2021/02/19/docker/docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://docs.docker.com/">docker官网文档</a></p><p><a href="https://docs.docker.com/get-started/">docker快速入手</a></p><h2 id="docker概述"><a href="#docker概述" class="headerlink" title="docker概述"></a><a href="https://docs.docker.com/get-started/overview/">docker概述</a></h2><p>Docker是一个用于开发，发布和运行应用程序的开放平台。Docker将应用程序与基础架构分开，从而可以快速交付软件。借助Docker可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，大大减少编写代码和在生产环境中运行代码之间的延迟。</p><p>docker可以用于快速一致交付程序，响应式部署和拓展，在同一软件上运行多个相同或者不同的服务，使资源得到充分利用。</p><p>docker架构如下</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210219114938.svg" alt="Docker架构图"></p><h3 id="docker概念"><a href="#docker概念" class="headerlink" title="docker概念"></a>docker概念</h3><p><a href="http://dockone.io/article/783">10张图带你深入理解Docker容器和镜像</a></p><p><a href="https://juejin.cn/post/6844903938030845966">Docker的三大核心组件：镜像，容器与仓库</a></p><h2 id="下载docker"><a href="#下载docker" class="headerlink" title="下载docker"></a>下载docker</h2><p><a href="https://docs.docker.com/get-docker/">官网下载地址</a></p><p>mac电脑选择mac版本进行下载</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210219114521.png" alt="image-20210219114521282"></p><p>安装好后进行启动，和安装普通软件一样</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210219114554.png" alt="image-20210219114554407"></p><h2 id="docker可以做的事情"><a href="#docker可以做的事情" class="headerlink" title="docker可以做的事情"></a>docker可以做的事情</h2><p>启动容器运行应用</p><p>持久化数据，防止每次启动不一致</p><p>可以使用docker hub共享镜像</p><p>多容器之间交互</p><blockquote><p>如果两个容器在同一网络上，它们可以相互通信。如果不是，他们就不会</p></blockquote><p>使用docker compose</p><h2 id="Hello-World-我的第一个docker容器"><a href="#Hello-World-我的第一个docker容器" class="headerlink" title="Hello World 我的第一个docker容器"></a>Hello World 我的第一个docker容器</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d -p <span class="token number">80</span>:80 docker/getting-starteddocker run -dp <span class="token number">80</span>:80 docker/getting-started <span class="token comment">#也可以写做这个，简写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>-d</code> -以分离模式运行容器（在后台）</li><li><code>-p 80:80</code> -将主机的端口80映射到容器中的端口80</li><li><code>docker/getting-started</code> -要使用的镜像</li></ul><p>运行后，可以点击docker中的dashboard查看上面起起来的容器，容器名称是随意创建的</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210220153738.png" alt="image-20210220153738649"></p><h3 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h3><p>简单说，容器就是一个你机器上的一个进程，它与其他进程是相互间隔离的。</p><h3 id="什么是容器镜像？"><a href="#什么是容器镜像？" class="headerlink" title="什么是容器镜像？"></a>什么是容器镜像？</h3><p>容器镜像包含了所有的需要起一个应用的要素，包括依赖，配置，脚本，二进制文件等，但是也包含了其他容器的配置，如环境变量，默认启动方法，以及其他元数据</p><h2 id="镜像创建示例"><a href="#镜像创建示例" class="headerlink" title="镜像创建示例"></a>镜像创建示例</h2><p>以下参照 <a href="https://docs.docker.com/get-started">get-started</a> 测试</p><p><a href="https://github.com/docker/getting-started/tree/master/app">下载docker新手app文件</a></p><p>创建Dockerfile，并粘贴下面的内容</p><pre class="line-numbers language-none"><code class="language-none">FROM node:12-alpine WORKDIR /app COPY . . RUN yarn install --production CMD ["node", "src/index.js"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210220160623.png" alt="image-20210220160623347"></p><p>在app目录下执行以下命令，使用<code>docker build</code>命令构建容器映像。（不要忘记了后面那个点，表示当前目录）</p><pre class="line-numbers language-none"><code class="language-none">docker build -t getting-started .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>他使用了Dockerfile去创建一个新的容器镜像，你会发现好多<code>layers</code>被下载下来了，这是因为Dockerfile上以<code>node:12-alpine</code>为基础镜像，但是我们的机器上面没有这些镜像文件。下载完毕后，他们会被复制到我们的应用中，并使用<code>yarn</code>去安装应用的依赖。执行命令行使用的是系统默认的<code>cmd</code>软件。<code>-t</code>后面带的名字即镜像名称，方便我们之后去运行该镜像。</p><p>安装完毕，如下所示</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker build -t getting-started .Sending build context to Docker daemon  4.659MBStep 1/5 : FROM node:12-alpine12-alpine: Pulling from library/node0a6724ff3fcd: Pull completeb68849637432: Pull complete7dda491622fb: Pull completece97b0f80161: Pull completeDigest: sha256:77fe10dbc042121e94db7f43b4b912a52514759b847978588eec4d5d0eb5282cStatus: Downloaded newer image for node:12-alpine ---&gt; e136be20a0bdStep 2/5 : WORKDIR /app ---&gt; Running in d9ec4d68327fRemoving intermediate container d9ec4d68327f ---&gt; a7c9152f5afeStep 3/5 : COPY . . ---&gt; fa7eda5fa1a7Step 4/5 : RUN yarn install --production ---&gt; Running in 629ef52d06b6yarn install v1.22.5[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.9: The platform "linux" is incompatible with this module.info "fsevents@1.2.9" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...[4/4] Building fresh packages...Done in 145.83s.Removing intermediate container 629ef52d06b6 ---&gt; 15136bc6d899Step 5/5 : CMD ["node", "src/index.js"] ---&gt; Running in 62ad87066a4eRemoving intermediate container 62ad87066a4e ---&gt; 945f98aa1995Successfully built 945f98aa1995Successfully tagged getting-started:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，我们在docker中的images中也能看到我们新建的镜像了</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210220165847.png" alt="image-20210220165847096"></p><h2 id="启动容器示例"><a href="#启动容器示例" class="headerlink" title="启动容器示例"></a>启动容器示例</h2><p>现在我们拥有一个镜像了，可以跑一个应用了。执行<code>docker run</code>命令，这时候，用到我们之前创建的镜像文件了</p><pre class="line-numbers language-none"><code class="language-none">docker run -dp 3000:3000 getting-started<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-d</code> detached模式，保持容器后台运行，可以执行后续的<code>exec</code>命令</p><p><code>-p</code> 指定端口</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker run -dp 3000:3000 getting-started6891eba76d5d89b534a2a815d4a77ef5d447ca41b8170b64c537f4fb17a2a88e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在container/app中就能看到已经运行起来的容器</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210220172028.png" alt="image-20210220172028423"></p><p>打开 <a href="http://localhost:3000/">http://localhost:3000</a> ，看看运行起来的服务</p><p>![image-20210220172211298](/Users/cutie/Library/Application Support/typora-user-images/image-20210220172211298.png)</p><h2 id="docker常用命令【后续进行抽离完善】"><a href="#docker常用命令【后续进行抽离完善】" class="headerlink" title="docker常用命令【后续进行抽离完善】"></a>docker常用命令【后续进行抽离完善】</h2><p><code>docker search ubuntu</code> 搜索 Docker Hub 中的镜像</p><p><code>docker inspect redis:3.2</code> 获得镜像更详细的信息，也可以传入可以传入镜像 ID 或容器 ID</p><p><code>docker -version</code> 查看 Docker 版本的命令，显示是社区版的</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:~ cutie$ docker versionClient: Docker Engine - Community Cloud integration: 1.0.9 Version:           20.10.5 API version:       1.41 Go version:        go1.13.15 Git commit:        55c4c88 Built:             Tue Mar  2 20:13:00 2021 OS/Arch:           darwin/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.5  API version:      1.41 (minimum version 1.12)  Go version:       go1.13.15  Git commit:       363e9a8  Built:            Tue Mar  2 20:15:47 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.4.3  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b runc:  Version:          1.0.0-rc92  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff docker-init:  Version:          0.19.0  GitCommit:        de40ad0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>docker ps</code> 查看正在运行的镜像</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker psCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                    NAMES6891eba76d5d   945f98aa1995             "docker-entrypoint.s…"   23 minutes ago   Up 23 minutes   0.0.0.0:3000-&gt;3000/tcp   amazing_babbage6b825ac83cbb   docker/getting-started   "nginx -g 'daemon of…"   2 hours ago      Up 2 hours      0.0.0.0:80-&gt;80/tcp       nifty_colden<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>docker stop &lt;the-container-id&gt;</code> 根据容器id暂停正在运行的容器</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker stop 6891eba76d5d6891eba76d5d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>docker rm &lt;the-container-id&gt;</code> 根据容器id移除不使用的容器</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker rm 6891eba76d5d6891eba76d5d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>docker rm -f &lt;the-container-id&gt;</code> 单行命令终止和删除容器</p><p><code>docker image ls</code> 查看镜像列表</p><p><code>docker logs -f &lt;container-id&gt;</code> 查看日志，看完日志后，请按<code>Ctrtrol</code>+<code>C</code>退出</p><pre class="line-numbers language-none"><code class="language-none">cutiedeMacBook-Pro:app cutie$ docker logs -f 9a5b851f917bUsing sqlite database at /etc/todos/todo.dbListening on port 3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q:</p><p>A:</p><p>Q:</p><p>A:</p><p>Q:</p><p>A:</p><p>Q:</p><p>A:</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week01-02 JVM 核心技术--工具与 GC 策略</title>
      <link href="2021/02/19/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week01-02-JVM-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%B7%A5%E5%85%B7%E4%B8%8E-GC-%E7%AD%96%E7%95%A5/"/>
      <url>2021/02/19/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week01-02-JVM-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%B7%A5%E5%85%B7%E4%B8%8E-GC-%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="第-2-课-JVM-核心技术–工具与-GC-策略"><a href="#第-2-课-JVM-核心技术–工具与-GC-策略" class="headerlink" title="第 2 课 JVM 核心技术–工具与 GC 策略"></a>第 2 课 JVM 核心技术–工具与 GC 策略</h1><p><strong>目录</strong></p><ol><li>JDK 内置命令行工具*</li><li>JDK 内置图形化工具*</li><li>GC 的背景与一般原理</li><li>串行 GC/并行 GC*（Serial GC/Parallel GC）</li><li>CMS GC/G1 GC*</li><li>ZGC/Shenandoah GC</li><li>第 2 节课总结回顾与作业实践</li></ol><h2 id="1-JDK-内置命令行工具"><a href="#1-JDK-内置命令行工具" class="headerlink" title="1.JDK 内置命令行工具"></a>1.JDK 内置命令行工具</h2><h3 id="JVM-命令行工具"><a href="#JVM-命令行工具" class="headerlink" title="JVM 命令行工具"></a><strong>JVM 命令行工具</strong></h3><p>![image-20210221220254377](/Users/cutie/Library/Application Support/typora-user-images/image-20210221220254377.png)</p><h3 id="工具-简介"><a href="#工具-简介" class="headerlink" title="工具 简介"></a><strong>工具 简介</strong></h3><p><strong>java</strong> Java 应用的启动程序</p><p><strong>javac</strong> JDK 内置的编译工具</p><p><strong>javap</strong> 反编译 class 文件的工具</p><p><strong>javadoc</strong> 根据 Java 代码和标准注释,自动生成相关的API说明文档</p><p><strong>javah</strong> JNI 开发时, 根据 java 代码生成需要的 .h文件。</p><p><strong>extcheck</strong> 检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用</p><p><strong>jdb</strong> Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很少使用</p><p><strong>jdeps</strong> 探测 class 或 jar 包需要的依赖</p><p><strong>jar</strong> 打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件,只是后缀不同。使用时按顺序对应好选项和参数即可。</p><p><strong>keytool</strong> 安全证书和密钥的管理工具; （支持生成、导入、导出等操作）</p><p><strong>jarsigner</strong> JAR 文件签名和验证工具</p><p><strong>policytool</strong> 实际上这是一款图形界面工具, 管理本机的 Java 安全策略</p><h3 id="JVM-命令行工具-1"><a href="#JVM-命令行工具-1" class="headerlink" title="JVM 命令行工具"></a><strong>JVM 命令行工具</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220324.png" alt="image-20210221220324097"></p><p><strong>工具 简介</strong></p><p><strong>jps/jinfo</strong> 查看 java 进程</p><p><strong>jstat</strong> 查看 JVM 内部 gc 相关信息</p><p><strong>jmap</strong> 查看 heap 或类占用空间统计</p><p><strong>jstack</strong> 查看线程信息</p><p><strong>jcmd</strong> 执行 JVM 相关分析命令（整合命令）</p><p><strong>jrunscript/jjs</strong> 执行 js 命令</p><h3 id="JVM-命令行工具-jps-jinfo"><a href="#JVM-命令行工具-jps-jinfo" class="headerlink" title="JVM 命令行工具-jps/jinfo"></a><strong>JVM 命令行工具-jps/jinfo</strong></h3><p> D:&gt;jps</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220346.png" alt="image-20210221220346145"></p><p>32432</p><p>1716 Jps</p><p>23784 QuorumPeerMain</p><p>4264 Bootstrap</p><p>2460 Launcher</p><p>D:&gt;jps -help</p><p>usage: jps [-help]</p><p>jps [-q] [-mlvV] [<hostid>]</hostid></p><p>Definitions:</p><p><hostid>: <hostname>[:<port>]</port></hostname></hostid></p><h3 id="JVM-命令行工具-jstat"><a href="#JVM-命令行工具-jstat" class="headerlink" title="*JVM 命令行工具-jstat**"></a>*<em>JVM 命令行工具-jstat**</em></h3><blockquote><p>jstat -options</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220358.png" alt="image-20210221220358285"></p><p>class 类加载(Class loader)信息统计.</p><p>compiler JIT 即时编译器相关的统计信息。</p><p>gc GC 相关的堆内存信息. 用法: jstat -gc -h 10 -t 864 1s 20</p><p>gccapacity 各个内存池分代空间的容量。</p><p>gccause 看上次 GC, 本次 GC（如果正在 GC中）的原因, 其他输出和 -gcutil 选项一致。</p><p>gcnew 年轻代的统计信息. （New = Young = Eden + S0 + S1）</p><p>gcnewcapacity 年轻代空间大小统计.</p><p>gcold 老年代和元数据区的行为统计。</p><p>gcoldcapacity old 空间大小统计.</p><p>gcmetacapacity meta 区大小统计.</p><p>gcutil GC 相关区域的使用率（utilization）统计。</p><p>printcompilation 打印 JVM 编译统计信息。</p><h3 id="JVM-命令行工具-jstat-1"><a href="#JVM-命令行工具-jstat-1" class="headerlink" title="JVM 命令行工具-jstat"></a><strong>JVM 命令行工具-jstat</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220417.png" alt="image-20210221220417325"></p><p>演示：</p><p>jstat -gcutil pid 1000 1000</p><p><strong>JVM 命令行工具-jstat</strong> 演示</p><p>![image-20210221220441062](/Users/cutie/Library/Application Support/typora-user-images/image-20210221220441062.png)</p><p>jstat -gc pid 1000 1000</p><h3 id="JVM-命令行工具-jmap"><a href="#JVM-命令行工具-jmap" class="headerlink" title="JVM 命令行工具-jmap"></a><strong>JVM 命令行工具-jmap</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220503.png" alt="image-20210221220503764"></p><p>常用选项就 3 个：</p><p>heap 打印堆内存（/内存池）的配置和</p><p>使用信息。</p><p>histo 看哪些类占用的空间最多, 直方图</p><p>dump:format=b,file=xxxx.hprof</p><p>Dump 堆内存。</p><p>演示:</p><p>jmap -heap pid</p><p>jmap -histo pid</p><p>jmap -dump:format=b,file=3826.hprof</p><p>3826</p><h3 id="JVM-命令行工具-jstack"><a href="#JVM-命令行工具-jstack" class="headerlink" title="JVM 命令行工具-jstack"></a><strong>JVM 命令行工具-jstack</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220514.png" alt="image-20210221220514919"></p><p>F 强制执行 thread dump. 可在 Java 进程卡死</p><p>（hung 住）时使用, 此选项可能需要系统权限。</p><p>m 混合模式(mixed mode),将 Java 帧和 native</p><p>帧一起输出, 此选项可能需要系统权限。</p><p>l 长列表模式. 将线程相关的 locks 信息一起输出，</p><p>比如持有的锁，等待的锁。</p><p>演示：</p><p>jstack pid -l</p><h3 id="JVM-命令行工具-jcmd"><a href="#JVM-命令行工具-jcmd" class="headerlink" title="*JVM 命令行工具-jcmd**"></a>*<em>JVM 命令行工具-jcmd**</em></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220529.png"></p><p>Jcmd 综合了前面的几个命令</p><p>示例：</p><p>jcmd pid VM.version</p><p>jcmd pid VM.flags</p><p>jcmd pid VM.command_line</p><p>jcmd pid VM.system_properties</p><p>jcmd pid Thread.print</p><p>jcmd pid GC.class_histogram</p><p>jcmd pid GC.heap_info</p><h3 id="JVM-命令行工具-jrunscript-jjs"><a href="#JVM-命令行工具-jrunscript-jjs" class="headerlink" title="JVM 命令行工具-jrunscript/jjs"></a><strong>JVM 命令行工具-jrunscript/jjs</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220548.png" alt="image-20210221220548729"></p><p>当curl命令用：</p><p>jrunscript -e “cat(‘<a href="http://www.baidu.com&amp;/#39;)&quot;">http://www.baidu.com')"</a></p><p>执行js脚本片段</p><p>jrunscript -e “print(‘hello,kk.jvm’+1)”</p><p>执行js文件</p><p>jrunscript -l js -f /XXX/XXX/test.js</p><h2 id="2-JDK-内置图形化工具"><a href="#2-JDK-内置图形化工具" class="headerlink" title="2.JDK 内置图形化工具"></a>2.JDK 内置图形化工具</h2><h3 id="JVM-图形化工具-jconsole"><a href="#JVM-图形化工具-jconsole" class="headerlink" title="JVM 图形化工具-jconsole"></a><strong>JVM 图形化工具-jconsole</strong></h3><p>![image-20210221220611310](/Users/cutie/Library/Application Support/typora-user-images/image-20210221220611310.png)</p><p>在命令行输入 jconsole 即可打开</p><p>本地 JVM 可以直接选择</p><p>远程 JVM 可以通过 JMX 方式连接</p><h3 id="JVM-图形化工具-jconsole-1"><a href="#JVM-图形化工具-jconsole-1" class="headerlink" title="JVM 图形化工具-jconsole"></a><strong>JVM 图形化工具-jconsole</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220625.png" alt="image-20210221220625562"></p><p>共有 6 个面板</p><p>第一个为概览，四项指标具体为：</p><p>堆内存使用量：此处展示的就是前面 Java 内存模型课程中提到的堆内存使用情况，从图上可以看到，堆内存使用了 94MB 左右，并且一直在增长。</p><p>线程：展示了 JVM 中活动线程的数量，当前时刻共有 17 个活动线程。</p><p>类：JVM 一共加载了 5563 个类，没有卸载类。</p><p>CPU 占用率：目前 CPU 使用率为 0.2%，这个数值非常低，且最高的时候也不到 3%，初步判断系统当前并没有什么负载和压力。</p><p>有如下几个时间维度可供选择：</p><p>1分钟、5分钟、10分钟、30分钟、1小时、2小时、3小时、6小时、</p><p>12小时、1天、7天、1个月、3个月、6个月、1年、全部，一共是16 档。</p><p>当我们想关注最近1小时或者1分钟的数据，就可以选择对应的档。旁</p><p>边的3个标签页(内存、线程、类)，也都支持选择时间范围。</p><h3 id="JVM-图形化工具-jconsole-2"><a href="#JVM-图形化工具-jconsole-2" class="headerlink" title="JVM 图形化工具-jconsole"></a><strong>JVM 图形化工具-jconsole</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220639.png" alt="image-20210221220639192"></p><p>内存图表包括：</p><p>堆内存使用量，主要包括老年代（内存池 “PS Old</p><p>Gen”）、新生代（“PS Eden Space”）、存活区</p><p>（“PS Survivor Space”）；</p><p>非堆内存使用量，主要包括内存池“Metaspace”、</p><p>“Code Cache”、“Compressed Class Space”等；</p><p>可以分别选择对应的 6 个内存池。</p><p>通过内存面板，我们可以看到各个区域的内存使用和</p><p>变化情况，并且可以：</p><p>1.手动执行 gc，见图上的标号1，点击按钮即可执行JDK 中的 System.gc()</p><p>2.通过图中右下角标号 2 的界面，可以看到各个内存池的百分比使用率，以及堆/非堆空间的汇总使用情况</p><p>3.从左下角标号 3 的界面，可以看到 JVM 使用的垃圾收集器，以及执行垃圾收集的次数，以及相应的时间消耗。</p><h3 id="JVM-图形化工具-jconsole-3"><a href="#JVM-图形化工具-jconsole-3" class="headerlink" title="JVM 图形化工具-jconsole"></a><strong>JVM 图形化工具-jconsole</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220653.png" alt="image-20210221220653140"></p><p>线程面板展示了线程数变化信息，以及监测到</p><p>的线程列表。</p><p>我们可以常根据名称直接查看线程的状态（运</p><p>行还是等待中）和调用栈（正在执行什么操</p><p>作）。</p><p>特别地，我们还可以直接点击“检测死锁”按钮</p><p>来检测死锁，如果没有死锁则会提示“未检测</p><p>到死锁”。</p><h3 id="JVM-图形化工具-jconsole-4"><a href="#JVM-图形化工具-jconsole-4" class="headerlink" title="JVM 图形化工具-jconsole"></a><strong>JVM 图形化工具-jconsole</strong></h3><p>![image-20210221220706391](/Users/cutie/Library/Application Support/typora-user-images/image-20210221220706391.png)</p><p>类监控面板，可以直接看到 JVM 加载和卸载的</p><p>类数量汇总信息，以及随着时间的动态变化。</p><h3 id="JVM-图形化工具-jconsole-5"><a href="#JVM-图形化工具-jconsole-5" class="headerlink" title="JVM 图形化工具-jconsole"></a><strong>JVM 图形化工具-jconsole</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220723.png" alt="image-20210221220723902"></p><p>VM 概要的数据有五个部分：</p><p>第一部分是虚拟机的信息；</p><p>第二部分是线程数量，以及类加载的</p><p>汇总信息；</p><p>第三部分是堆内存和 GC 统计。</p><p>第四部分是操作系统和宿主机的设备</p><p>信息，比如 CPU 数量、物理内存、虚</p><p>拟内存等等。</p><p>第五部分是 JVM 启动参数和几个关键</p><p>路径，这些信息其实跟 jinfo 命令看到</p><p>的差不多。</p><h3 id="JVM-图形化工具-jvisualvm"><a href="#JVM-图形化工具-jvisualvm" class="headerlink" title="JVM 图形化工具-jvisualvm"></a><strong>JVM 图形化工具-jvisualvm</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220854.png" alt="image-20210221220854205"></p><h3 id="JVM-图形化工具-jvisualvm-1"><a href="#JVM-图形化工具-jvisualvm-1" class="headerlink" title="JVM 图形化工具-jvisualvm"></a><strong>JVM 图形化工具-jvisualvm</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220905.png" alt="image-20210221220905018"></p><h3 id="JVM-图形化工具-jvisualvm-2"><a href="#JVM-图形化工具-jvisualvm-2" class="headerlink" title="JVM 图形化工具-jvisualvm"></a><strong>JVM 图形化工具-jvisualvm</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220919.png" alt="image-20210221220919070"></p><h3 id="JVM-图形化工具-jvisualvm-3"><a href="#JVM-图形化工具-jvisualvm-3" class="headerlink" title="JVM 图形化工具-jvisualvm"></a><strong>JVM 图形化工具-jvisualvm</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221220930.png" alt="image-20210221220930575"></p><h3 id="JVM-图形化工具-VisualGCJVM"><a href="#JVM-图形化工具-VisualGCJVM" class="headerlink" title="JVM 图形化工具-VisualGCJVM"></a><strong>JVM 图形化工具-VisualGCJVM</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221221250.png" alt="image-20210221221250412"></p><h3 id="图形化工具-jmc"><a href="#图形化工具-jmc" class="headerlink" title="图形化工具-jmc"></a><strong>图形化工具-jmc</strong></h3><p>![image-20210221221318177](/Users/cutie/Library/Application Support/typora-user-images/image-20210221221318177.png)</p><h3 id="JVM-图形化工具-jmc"><a href="#JVM-图形化工具-jmc" class="headerlink" title="JVM 图形化工具-jmc"></a><strong>JVM 图形化工具-jmc</strong></h3><p>![image-20210221221336485](/Users/cutie/Library/Application Support/typora-user-images/image-20210221221336485.png)</p><h3 id="JVM-图形化工具-jmc-1"><a href="#JVM-图形化工具-jmc-1" class="headerlink" title="JVM 图形化工具-jmc"></a><strong>JVM 图形化工具-jmc</strong></h3><p>![image-20210221221351996](/Users/cutie/Library/Application Support/typora-user-images/image-20210221221351996.png)</p><h3 id="JVM-图形化工具-jmc-2"><a href="#JVM-图形化工具-jmc-2" class="headerlink" title="JVM 图形化工具-jmc"></a><strong>JVM 图形化工具-jmc</strong></h3><p>![image-20210221221404197](/Users/cutie/Library/Application Support/typora-user-images/image-20210221221404197.png)</p><h3 id="JVM-图形化工具-jmc-3"><a href="#JVM-图形化工具-jmc-3" class="headerlink" title="JVM 图形化工具-jmc"></a><strong>JVM 图形化工具-jmc</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221221419.png" alt="image-20210221221419506"></p><h3 id="JVM-图形化工具-jmc-4"><a href="#JVM-图形化工具-jmc-4" class="headerlink" title="JVM 图形化工具-jmc"></a><strong>JVM 图形化工具-jmc</strong></h3><p>![image-20210221221517013](/Users/cutie/Library/Application Support/typora-user-images/image-20210221221517013.png)</p><h3 id="JVM-图形化工具-jmc-5"><a href="#JVM-图形化工具-jmc-5" class="headerlink" title="JVM 图形化工具-jmc"></a><strong>JVM 图形化工具-jmc</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221221536.png" alt="image-20210221221535991"></p><h3 id="JVM-工具总结"><a href="#JVM-工具总结" class="headerlink" title="JVM 工具总结"></a><strong>JVM 工具总结</strong></h3><p>jsonsole</p><p>jvisualvm</p><p>visualGC</p><p>jmc</p><p>jps/jinfo</p><p>jstat</p><p>jmap</p><p>jstack</p><p>jcmd</p><p>jrunscript/jjs</p><h2 id="3-GC-的背景与一般原理"><a href="#3-GC-的背景与一般原理" class="headerlink" title="3.GC 的背景与一般原理"></a>3.GC 的背景与一般原理</h2><h3 id="GC-的背景与一般原理"><a href="#GC-的背景与一般原理" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p>为什么会有 GC</p><p>本质上是内存资源的有限性</p><p>因此需要大家共享使用，手工申请，手动释放。</p><p>下面我们举个例子</p><h3 id="GC-的背景与一般原理-1"><a href="#GC-的背景与一般原理-1" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p>![image-20210221222138290](/Users/cutie/Library/Application Support/typora-user-images/image-20210221222138290.png)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221222153.png" alt="image-20210221222153440"></p><p>仓库与引用计数：计数为 0</p><p>简单粗暴，一般有效</p><p>实际情况复杂一点</p><p>仓库与仓库之间也有关系</p><p>导致形成一个环，大家的计数永远不为 0（跟线程、事务死锁一个原理）</p><p>这些仓库都没法再用：内存泄漏-&gt;内存溢出</p><p>怎么改进呢？引用计数-&gt;引用跟踪</p><h3 id="GC-的背景与一般原理-2"><a href="#GC-的背景与一般原理-2" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221222210.png" alt="image-20210221222210636"></p><p>标记清除算法（Mark and Sweep）</p><p>Marking（标记）: 遍历所有的可达对象，并在本地内存(native)中分门别类记下。</p><p>Sweeping（清除）: 这一步保证了，不可达对象所占用的内存，在之后进行内存分配时可以重用。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221222224.png" alt="image-20210221222224887"></p><p>并行 GC 和 CMS 的基本原理。</p><p>优势：可以处理循环依赖，只扫描部分对象</p><p>除了清除，还要做压缩。</p><p>怎么才能标记和清除清楚上百万对象呢？</p><p>答案就是 STW，让全世界停止下来。</p><h3 id="GC-的背景与一般原理-3"><a href="#GC-的背景与一般原理-3" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221223219.png" alt="image-20210221223219675"></p><p>分代假设：大部分新生对象很快无用；</p><p>存活较长时间的对象，可能存活更长时间。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221223239.png" alt="image-20210221223239475"></p><p>内存池划分</p><p>不同类型对象不同区域，不同策略处理。</p><h3 id="GC-的背景与一般原理-4"><a href="#GC-的背景与一般原理-4" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221223307.png" alt="image-20210221223307061"></p><p>对象分配在新生代的 Eden 区，标记阶段 Eden 区存活的对象就会复制到存活区；</p><p>注意：为什么是复制，不是移动？？？大家想想</p><p>两个存活区 from 和 to，互换角色。对象存活到一定周期会提升到老年代。</p><p>由如下参数控制提升阈值</p><p>XX：+MaxTenuringThreshold=15</p><p>老年代默认都是存活对象，采用移动方式：</p><ol><li>标记所有通过 GC roots 可达的对象；</li><li>删除所有不可达对象；</li><li>整理老年代空间中的内容，方法是将所有的存活对象复制，从老年代空间开始的地方依次存放。</li></ol><p>持久代/元数据区</p><p>1.8 之前 -XX:MaxPermSize=256m</p><p>1.8 之后 -XX:MaxMetaspaceSize=256m</p><h3 id="GC-的背景与一般原理-5"><a href="#GC-的背景与一般原理-5" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221223341.png" alt="image-20210221223340955"></p><p>可以作为 GC Roots 的对象</p><ol><li>当前正在执行的方法里的局部变量和输入参数</li><li>活动线程（Active threads）</li><li>所有类的静态字段（static field）</li><li>JNI 引用</li></ol><p>此阶段暂停的时间，与堆内存大小,对象</p><p>的总数没有直接关系，而是由存活对象</p><p>（alive objects）的数量来决定。所以增</p><p>加堆内存的大小并不会直接影响标记阶段</p><p>占用的时间。</p><h3 id="GC-的背景与一般原理-6"><a href="#GC-的背景与一般原理-6" class="headerlink" title="GC 的背景与一般原理"></a><strong>GC 的背景与一般原理</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221223412.png" alt="image-20210221223412335"></p><p><strong>标记复制算法(Mark-Copy)</strong></p><p><strong>标记清除(Mark-Sweep)</strong></p><p><strong>标记清除整理算法(Mark-Sweep-Compact)</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/659cc6c9-9244-4bce-ad2b-c448ab9fa33b/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/659cc6c9-9244-4bce-ad2b-c448ab9fa33b/Untitled.png"></p><p><strong>总结一下，三者有什么优缺点</strong></p><h2 id="4-串行-GC-并行-GC（Serial-GC-Parallel-GC）"><a href="#4-串行-GC-并行-GC（Serial-GC-Parallel-GC）" class="headerlink" title="4.串行 GC/并行 GC（Serial GC/Parallel GC）"></a>4.串行 GC/并行 GC（Serial GC/Parallel GC）</h2><h3 id="串行-GC（Serial-GC）-ParNewGC"><a href="#串行-GC（Serial-GC）-ParNewGC" class="headerlink" title="串行 GC（Serial GC）/ParNewGC"></a><strong>串行 GC（Serial GC）/ParNewGC</strong></h3><p>XX：+UseSerialGC 配置串行 GC</p><p>串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除-整理）算法。</p><p>两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。</p><p>因此这种 GC 算法不能充分利用多核 CPU。不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心。</p><p>CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死。该选项只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用。</p><p>想想 why？</p><p>XX：+USeParNewGC 改进版本的 Serial GC，可以配合 CMS 使用。</p><h3 id="并行-GC（Parallel-GC）"><a href="#并行-GC（Parallel-GC）" class="headerlink" title="并行 GC（Parallel GC）"></a><strong>并行 GC（Parallel GC）</strong></h3><p>XX：+UseParallelGC</p><p>XX：+UseParallelOldGC</p><p>XX：+UseParallelGC -XX:+UseParallelOldGC</p><p>年轻代和老年代的垃圾回收都会触发 STW 事件。</p><p>在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweepcompact）算法。</p><p>XX：ParallelGCThreads=N 来指定 GC 线程数， 其默认值为 CPU 核心数。并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:</p><p>在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；</p><p>在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。</p><h3 id="演示：并行-GC，常用参数以及其内存分配"><a href="#演示：并行-GC，常用参数以及其内存分配" class="headerlink" title="演示：并行 GC，常用参数以及其内存分配"></a><strong>演示：并行 GC，常用参数以及其内存分配</strong></h3><h2 id="5-CMS-GC-G1-GC"><a href="#5-CMS-GC-G1-GC" class="headerlink" title="5.CMS GC/G1 GC"></a>5.CMS GC/G1 GC</h2><h3 id="CMS-GC（Mostly-Concurrent-Mark-and-Sweep-Garbage-Collector）"><a href="#CMS-GC（Mostly-Concurrent-Mark-and-Sweep-Garbage-Collector）" class="headerlink" title="CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）"></a><strong>CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）</strong></h3><p>XX：+UseConcMarkSweepGC</p><p>其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 marksweep (标记-清除)算法。</p><p>CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此</p><p>目标：</p><ol><li>不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。</li><li>在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。思考：并行 Parallel 与并发 Concurrent 的区别？</li></ol><h3 id="CMS-GC–六个阶段-1（STW）"><a href="#CMS-GC–六个阶段-1（STW）" class="headerlink" title="CMS GC–六个阶段 1（STW）"></a><strong>CMS GC–六个阶段 1（STW）</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221224228.png" alt="image-20210221224228081"></p><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Concurrent Mark（并发标记）</p><p>阶段 3: Concurrent Preclean（并发预清理）</p><p>阶段 4: Final Remark（最终标记）</p><p>阶段 5: Concurrent Sweep（并发清除）</p><p>阶段 6: Concurrent Reset（并发重置）</p><p><strong>这个阶段伴随着 STW 暂停。初始标记的目标是标记所有</strong></p><p><strong>的根对象，包括根对象直接引用的对象，以及被年轻代中</strong></p><p><strong>所有存活对象所引用的对象（老年代单独回收）。</strong></p><h3 id="CMS-GC–六个阶段-2"><a href="#CMS-GC–六个阶段-2" class="headerlink" title="CMS GC–六个阶段 2"></a><strong>CMS GC–六个阶段 2</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221224247.png" alt="image-20210221224247086"></p><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Concurrent Mark（并发标记）</p><p>阶段 3: Concurrent Preclean（并发预清理）</p><p>阶段 4: Final Remark（最终标记）</p><p>阶段 5: Concurrent Sweep（并发清除）</p><p>阶段 6: Concurrent Reset（并发重置）</p><p><strong>在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。</strong></p><h3 id="CMS-GC–六个阶段-3"><a href="#CMS-GC–六个阶段-3" class="headerlink" title="CMS GC–六个阶段 3"></a><strong>CMS GC–六个阶段 3</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221224305.png" alt="image-20210221224305487"></p><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Concurrent Mark（并发标记）</p><p>阶段 3: Concurrent Preclean（并发预清理）</p><p>阶段 4: Final Remark（最终标记）</p><p>阶段 5: Concurrent Sweep（并发清除）</p><p>阶段 6: Concurrent Reset（并发重置）</p><p><strong>此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片标记（Card Marking）。</strong></p><h3 id="CMS-GC–六个阶段-4（STW）"><a href="#CMS-GC–六个阶段-4（STW）" class="headerlink" title="CMS GC–六个阶段 4（STW）"></a><strong>CMS GC–六个阶段 4（STW）</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221224359.png" alt="image-20210221224359868"></p><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Concurrent Mark（并发标记）</p><p>阶段 3: Concurrent Preclean（并发预清理）</p><p>阶段 4: Final Remark（最终标记）</p><p>阶段 5: Concurrent Sweep（并发清除）</p><p>阶段 6: Concurrent Reset（并发重置）</p><p><strong>最终标记阶段是此次 GC 事件中的第二次（也是最后一次）STW 停顿。本阶段的目标是完成老年代中所有存活对象的标记. 因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度。所以需要一次STW 暂停来处理各种复杂的情况。通常 CMS 会尝试在年轻代尽可能空的情况下执行 FinalRemark 阶段，以免连续触发多次 STW 事件。</strong>最终标记</p><h3 id="CMS-GC–六个阶段-5"><a href="#CMS-GC–六个阶段-5" class="headerlink" title="CMS GC–六个阶段 5"></a><strong>CMS GC–六个阶段 5</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221224416.png" alt="image-20210221224416548"></p><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Concurrent Mark（并发标记）</p><p>阶段 3: Concurrent Preclean（并发预清理）</p><p>阶段 4: Final Remark（最终标记）</p><p>阶段 5: Concurrent Sweep（并发清除）</p><p>阶段 6: Concurrent Reset（并发重置）</p><p><strong>此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收他们占用的内存空间。</strong></p><h3 id="CMS-GC–六个阶段-6"><a href="#CMS-GC–六个阶段-6" class="headerlink" title="CMS GC–六个阶段 6"></a><strong>CMS GC–六个阶段 6</strong></h3><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Concurrent Mark（并发标记）</p><p>阶段 3: Concurrent Preclean（并发预清理）</p><p>阶段 4: Final Remark（最终标记）</p><p>阶段 5: Concurrent Sweep（并发清除）</p><p>阶段 6: Concurrent Reset（并发重置）</p><p><strong>此阶段与应用程序并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备。</strong></p><p><strong>CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。 当然，CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下 GC 会造成不可预测的暂停时间，特别是堆</strong></p><p><strong>内存较大的情况下。</strong></p><p><strong>演示：CMS GC，常用参数以及其内存分配（注意跟 ParallelGC 有什么差异）</strong></p><h3 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a><strong>G1 GC</strong></h3><p>![image-20210221224900621](/Users/cutie/Library/Application Support/typora-user-images/image-20210221224900621.png)</p><p>G1 的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。</p><p>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。</p><p>事实上，G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。为了达成可预期停顿时间的指标，G1 GC 有一些独特的实现。首先，堆不再分成年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的 小块堆区域(smaller heap regions)。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代</p><p>XX：+UseG1GC -XX:MaxGCPauseMillis=50</p><h3 id="G1-GC-1"><a href="#G1-GC-1" class="headerlink" title="G1 GC"></a><strong>G1 GC</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221224930.png" alt="image-20210221224929948"></p><p>这样划分之后，使得 G1 不必每次都去收集整</p><p>个堆空间，而是以增量的方式来进行处理: 每</p><p>次只处理一部分内存块，称为此次 GC 的回收</p><p>集(collection set)。每次 GC 暂停都会收集所</p><p>有年轻代的内存块，但一般只包含部分老年代</p><p>的内存块。</p><p>G1 的另一项创新是，在并发阶段估算每个小</p><p>堆块存活对象的总数。构建回收集的原则是：</p><p>垃圾最多的小块会被优先收集。这也是 G1 名</p><p>称的由来。</p><h3 id="G1-GC–配置参数"><a href="#G1-GC–配置参数" class="headerlink" title="G1 GC–配置参数"></a><strong>G1 GC–配置参数</strong></h3><p>XX：+UseG1GC：启用 G1 GC；</p><p>XX：G1NewSizePercent：初始年轻代占整个 Java Heap 的大小，默认值为 5%；</p><p>XX：G1MaxNewSizePercent：最大年轻代占整个 Java Heap 的大小，默认值为 60%；</p><p>XX：G1HeapRegionSize：设置每个 Region 的大小，单位 MB，需要为 1，2，4，8，16，32 中的某个值，默认是堆内存的 1/2000。如果这个值设置比较大，那么大对象就可以进入 Region 了。</p><p>XX：ConcGCThreads：与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1/4，减少这个参数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长。</p><p>XX：+InitiatingHeapOccupancyPercent（简称 IHOP）：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%。这个可以理解为老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收。这个值非常重要，它决定了在什么时间启动老年代的并行回收。</p><p>XX：G1HeapWastePercent：G1停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中的对象，但是如果下降到了 5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间。</p><p>XX：G1MixedGCCountTarget：设置并行循环之后需要有多少个混合 GC 启动，默认值是 8 个。老年代 Regions 的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许 G1 延长老年代的收集时间。</p><h3 id="G1-GC–配置参数-1"><a href="#G1-GC–配置参数-1" class="headerlink" title="G1 GC–配置参数"></a><strong>G1 GC–配置参数</strong></h3><p>XX：+G1PrintRegionLivenessInfo：这个参数需要和 -XX:+UnlockDiagnosticVMOptions 配合启动，打印 JVM 的调试信息，每个 Region 里的对象存活信息。</p><p>XX：G1ReservePercent：G1 为了保留一些空间用于年代之间的提升，默认值是堆空间的 10%。因为大量执行回收的地方在年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存。</p><p>XX：+G1SummarizeRSetStats：这也是一个 VM 的调试信息。如果启用，会在 VM 退出的时候打印出 Rsets 的详细总结信息。如果启用 -XX:G1SummaryRSetStatsPeriod 参数，就会阶段性地打印 Rsets 信息。</p><p>XX：+G1TraceConcRefinement：这个也是一个 VM 的调试信息，如果启用，并行回收阶段的日志就会被详细打印出来。</p><p>XX：+GCTimeRatio：这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9，跟新生代内存的分配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100/（1+GCTimeRatio）。这样如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面。Parallel GC 的默认值是 99，表示 1% 的时间被用在 GC 上面，这是因为 Parallel GC 贯穿整个 GC，而 G1 则根据 Region 来进行划分，不需要全局性扫描整个内存堆。</p><p>XX：+UseStringDeduplication：手动开启 Java String 对象的去重工作，这个是 JDK8u20 版本之后新增的参数，主要用于相同 String 避免重复申请内存，节约 Region 的使用。</p><p>XX：MaxGCPauseMills：预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在这个范围内。</p><h3 id="G1-GC-的处理步骤-1"><a href="#G1-GC-的处理步骤-1" class="headerlink" title="G1 GC 的处理步骤 1"></a><strong>G1 GC 的处理步骤 1</strong></h3><p>1、年轻代模式转移暂停（Evacuation Pause）</p><p>G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fullyyoung 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。拷贝的过程称为转移（Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。</p><h3 id="G1-GC-的处理步骤-2"><a href="#G1-GC-的处理步骤-2" class="headerlink" title="G1 GC 的处理步骤 2"></a><strong>G1 GC 的处理步骤 2</strong></h3><p>2、并发标记（Concurrent Marking）</p><p>同时我们也可以看到，G1 GC 的很多概念建立在 CMS 的基础上，所以下面的内容需要对 CMS 有一定的</p><p>理解。</p><p>G1 并发标记的过程与 CMS 基本上是一样的。G1 的并发标记通过 Snapshot-At-The-Beginning（起始快照）的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。</p><p>有两种情况是可以完全并发执行的：</p><p>一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾；</p><p>二、在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。</p><p>当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%，但也可以通过 JVM参数 InitiatingHeapOccupancyPercent 来设置。和 CMS 一样，G1 的并发标记也是由多个阶段组成，其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。</p><h3 id="G1-GC-的处理步骤-2-1"><a href="#G1-GC-的处理步骤-2-1" class="headerlink" title="G1 GC 的处理步骤 2"></a><strong>G1 GC 的处理步骤 2</strong></h3><p><strong>阶段 1: Initial Mark（初始标记）</strong></p><p>此阶段标记所有从 GC 根对象直接可达的对象。</p><p><strong>阶段 2: Root Region Scan（Root区扫描）</strong></p><p>此阶段标记所有从 “根区域” 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。</p><p><strong>阶段 3: Concurrent Mark（并发标记）</strong></p><p>此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。</p><p><strong>阶段 4: Remark（再次标记）</strong></p><p>和 CMS 类似，这是一次 STW 停顿(因为不是并发的阶段)，以完成标记过程。 G1 收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。</p><p><strong>阶段 5: Cleanup（清理）</strong></p><p>最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC 的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停。</p><h3 id="G1-GC-的处理步骤-3"><a href="#G1-GC-的处理步骤-3" class="headerlink" title="G1 GC 的处理步骤 3"></a><strong>G1 GC 的处理步骤 3</strong></h3><p>3、转移暂停: 混合模式（Evacuation Pause (mixed)）</p><p>并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。</p><p>因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。混合收集的过程，很大程度上和前面的 fully-young gc 是一样的。</p><h3 id="G1-GC-的注意事项"><a href="#G1-GC-的注意事项" class="headerlink" title="G1 GC 的注意事项"></a><strong>G1 GC 的注意事项</strong></h3><p>特别需要注意的是，某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的。</p><p>1.并发模式失败</p><p>G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小，或者调整周期（例如增加线程数-XX：ConcGCThreads 等）。</p><p>2.晋升失败</p><p>没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC(to-space exhausted/to-space overflow）。</p><p><strong>解决办法：</strong></p><p>a) 增加 –XX：G1ReservePercent 选项的值（并相应增加总的堆大小）增加预留内存量。</p><p>b) 通过减少 –XX：InitiatingHeapOccupancyPercent 提前启动标记周期。</p><p>c) 也可以通过增加 –XX：ConcGCThreads 选项的值来增加并行标记线程的数目。</p><p>3.巨型对象分配失败</p><p>当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间。</p><p>解决办法：增加内存或者增大 -XX：G1HeapRegionSize</p><h3 id="演示：G1-GC，常用参数以及其内存分配（注意跟-CMS-ParallelGC-有什么差异）"><a href="#演示：G1-GC，常用参数以及其内存分配（注意跟-CMS-ParallelGC-有什么差异）" class="headerlink" title="演示：G1 GC，常用参数以及其内存分配（注意跟 CMS/ParallelGC 有什么差异）"></a><strong>演示：G1 GC，常用参数以及其内存分配（注意跟 CMS/ParallelGC 有什么差异）</strong></h3><h3 id="各个-GC-对比"><a href="#各个-GC-对比" class="headerlink" title="各个 GC 对比"></a><strong>各个 GC 对比</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221225324.png" alt="image-20210221225324280"></p><h3 id="常用的-GC-组合（重点）"><a href="#常用的-GC-组合（重点）" class="headerlink" title="常用的 GC 组合（重点）"></a><strong>常用的 GC 组合（重点）</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221225336.png" alt="image-20210221225336005"></p><p>常用的组合为：</p><p>（1）Serial+Serial Old 实现单线程的低延迟</p><p>垃圾回收机制；</p><p>（2）ParNew+CMS，实现多线程的低延迟垃</p><p>圾回收机制；</p><p>（3）Parallel Scavenge和Parallel</p><p>Scavenge Old，实现多线程的高吞吐量垃圾</p><p>回收机制；</p><h3 id="GC-如何选择"><a href="#GC-如何选择" class="headerlink" title="GC 如何选择"></a><strong>GC 如何选择</strong></h3><p>选择正确的 GC 算法，唯一可行的方式就是去尝试，一般性的指导原则：</p><ol><li>如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；</li><li>如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；</li><li>如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。</li></ol><p>对于内存大小的考量：</p><ol><li>一般 4G 以上，算是比较大，用 G1 的性价比较高。</li><li>一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。</li></ol><p>最后讨论一个很多开发者经常忽视的问题，也是面试大厂常问的问题：JDK8 的默认 GC 是什么？</p><p>JDK9，JDK10，JDK11…等等默认的是 GC 是什么？</p><h2 id="6-ZGC-Shenandoah-GC"><a href="#6-ZGC-Shenandoah-GC" class="headerlink" title="6. ZGC/Shenandoah GC"></a>6. ZGC/Shenandoah GC</h2><h3 id="ZGC-介绍"><a href="#ZGC-介绍" class="headerlink" title="ZGC 介绍"></a><strong>ZGC 介绍</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221225402.png" alt="image-20210221225402246"></p><p>XX：+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g</p><p>ZGC 最主要的特点包括:</p><ol><li>GC 最大停顿时间不超过 10ms</li><li>堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆</li></ol><p>内存（JDK13 升至 16TB）</p><ol><li>与 G1 相比，应用吞吐量下降不超过 15%</li><li>当前只支持 Linux/x64 位平台，JDK15 后支持 MacOS 和</li></ol><p>Windows 系统</p><h3 id="ShennandoahGC-介绍"><a href="#ShennandoahGC-介绍" class="headerlink" title="ShennandoahGC 介绍"></a><strong>ShennandoahGC 介绍</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221225434.png" alt="image-20210221225434426"></p><p>XX：+UnlockExperimentalVMOptions -</p><p>XX:+UseShenandoahGC -Xmx16g</p><p>Shenandoah GC 立项比 ZGC 更早，设计为GC 线程与应用线程并发执行的方式，通过实现垃圾回收过程的并发处理，改善停顿时间，使得 GC 执行线程能够在业务处理线程运行过程中进行堆压缩、标记和整理，从而消除了绝大部分的暂停时间。</p><p>Shenandoah 团队对外宣称 ShenandoahGC 的暂停时间与堆大小无关，无论是 200MB 还是 200 GB的堆内存，都可以保障具有很低的暂停时间（注意:并不像 ZGC 那样保证暂停时间在 10ms 以内）。</p><h3 id="ShennandoahGC-与其他-GC-的-STW-比较GC-总结"><a href="#ShennandoahGC-与其他-GC-的-STW-比较GC-总结" class="headerlink" title="ShennandoahGC 与其他 GC 的 STW 比较GC 总结"></a><strong>ShennandoahGC 与其他 GC 的 STW 比较GC 总结</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210221225454.png" alt="image-20210221225454704"></p><p>到目前为止，我们一共了解了 Java 目前支持的所有 GC 算法，一共有 7 类:</p><ol><li>串行 GC（Serial GC）: 单线程执行，应用需要暂停；</li><li>并行 GC（ParNew、Parallel Scavenge、Parallel Old）: 多线程并行地执行垃圾回收，</li></ol><p>关注与高吞吐；</p><ol><li>CMS（Concurrent Mark-Sweep）: 多线程并发标记和清除，关注与降低延迟；</li><li>G1（G First）: 通过划分多个内存区域做增量整理和回收，进一步降低延迟；</li><li>ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几毫</li></ol><p>秒级别的延迟，线性可扩展；</p><ol><li>Epsilon: 实验性的 GC，供性能分析使用；</li><li>Shenandoah: G1 的改进版本，跟 ZGC 类似。</li></ol><h3 id="GC-总结"><a href="#GC-总结" class="headerlink" title="GC 总结"></a><strong>GC 总结</strong></h3><p>可以看出 GC 算法和实现的演进路线:</p><ol><li>串行 -&gt; 并行: 重复利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量。</li><li>并行 -&gt; 并发： 不只开多个 GC 线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线程一起并发执行，减少了单次 GC 暂停持续的时间，这能有效降低业务系统的延迟。</li><li>CMS -&gt; G1： G1 可以说是在 CMS 基础上进行迭代和优化开发出来的，划分为多个小堆块进行增量回收，这样就更进一步地降低了单次 GC 暂停的时间</li><li>G1 -&gt; ZGC:：ZGC 号称无停顿垃圾收集器，这又是一次极大的改进。ZGC 和 G1 有一些相似的地方，但是底层的算法和思想又有了全新的突破。</li></ol><p>脱离场景谈性能都是耍流氓”。</p><p>目前绝大部分 Java 应用系统，堆内存并不大比如 2G-4G 以内，而且对 10ms 这种低延迟的 GC 暂停不敏感，也就是说处理一个业务步骤，大概几百毫秒都是可以接受的，GC 暂停 100ms 还是 10ms 没多大区别。另一方面，系统的吞吐量反而往往是我们追求的重点，这时候就需要考虑采用并行 GC。如果堆内存再大一些，可以考虑 G1 GC。如果内存非常大（比如超过 16G，甚至是 64G、128G），或者是对延迟非常敏感（比如高频量化交易系统），就需要考虑使用本节提到的新 GC（ZGC/Shenandoah）。</p><h2 id="7-总结回顾与作业实践"><a href="#7-总结回顾与作业实践" class="headerlink" title="7.总结回顾与作业实践"></a>7.总结回顾与作业实践</h2><h2 id="第-2-课总结回顾"><a href="#第-2-课总结回顾" class="headerlink" title="第 2 课总结回顾"></a><strong>第 2 课总结回顾</strong></h2><p>工具有哪些？</p><p>GC 有哪些？</p><p>都有什么特点？</p><h2 id="第-2-节课作业实践"><a href="#第-2-节课作业实践" class="headerlink" title="第 2 节课作业实践"></a><strong>第 2 节课作业实践</strong></h2><p>1、本机使用 G1 GC 启动一个程序，仿照课上案例分析一下 JVM 情况</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week02-01 JVM 核心技术（三）：调优分析与面试经验</title>
      <link href="2021/02/19/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week02-01-JVM-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B0%83%E4%BC%98%E5%88%86%E6%9E%90%E4%B8%8E%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
      <url>2021/02/19/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week02-01-JVM-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B0%83%E4%BC%98%E5%88%86%E6%9E%90%E4%B8%8E%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>极客大学 Java 进阶训练营</p><h1 id="第-3-课-JVM-核心技术（三）：调优分析与面试经验"><a href="#第-3-课-JVM-核心技术（三）：调优分析与面试经验" class="headerlink" title="第 3 课 JVM 核心技术（三）：调优分析与面试经验"></a>第 3 课 JVM 核心技术（三）：调优分析与面试经验</h1><p><strong>目录</strong></p><ol><li>GC 日志解读与分析*</li><li>JVM 线程堆栈数据分析</li><li>内存分析与相关工具*</li><li>JVM 问题分析调优经验*</li><li>GC 疑难情况问题分析</li><li>JVM 常见面试问题汇总*</li><li>第 3 课总结回顾与作业实践</li></ol><p>第 3 课 JVM 核心技术</p><p>调优分析与面试经验</p><ol><li>GC 日志解读与分析</li></ol><p><strong>GC 日志解读与分析</strong></p><p>java -XX:+PrintGCDetails GCLogAnalysis</p><p>java -Xloggc:gc.demo.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps</p><p>GCLogAnalysis</p><p>1）模拟一下 OOM，java -Xmx128m -XX:+PrintGCDetails GCLogAnalysis</p><p>2）分别使用 512m,1024m,2048m,4086m,观察 GC 信息的不同</p><p><strong>GC 日志解读与分析</strong></p><p>究竟是</p><p>Young GC</p><p>Full GC</p><p>还是</p><p>Minor GC（小型 GC）</p><p>Major GC（大型 GC）</p><p>？</p><p><strong>GC 日志解读与分析</strong></p><p>串行 GC</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411133852.png" alt="image-20210411133852736"></p><p>java -XX:+UseSerialGC</p><p>Xms512m -Xmx512m</p><p>Xloggc:gc.demo.log</p><p>XX:+PrintGCDetails</p><p>XX:+PrintGCDateStamps</p><p>GCLogAnalysis</p><p>观察 Young GC 与 Full GC</p><p><strong>GC 日志解读与分析</strong></p><p>并行 GC</p><p>![image-20210411133908819](/Users/cutie/Library/Application Support/typora-user-images/image-20210411133908819.png)</p><p>java -XX:+UseParallelGC</p><p>Xms512m -Xmx512m</p><p>Xloggc:gc.demo.log</p><p>XX:+PrintGCDetails</p><p>XX:+PrintGCDateStamps</p><p>GCLogAnalysis</p><p>观察 Young GC 与 Full GC</p><p>思考：如果不配置 Xms 会怎么样？</p><p><strong>GC 日志解读与分析</strong></p><p>CMS GC</p><p>![image-20210411133933041](/Users/cutie/Library/Application Support/typora-user-images/image-20210411133933041.png)</p><p>java -XX:+UseConcMarkSweepGC</p><p>Xms512m -Xmx512m</p><p>Xloggc:gc.demo.log</p><p>XX:+PrintGCDetails</p><p>XX:+PrintGCDateStamps</p><p>GCLogAnalysis</p><p>观察 Young GC 与 Full GC</p><p>思考：假如 Xmx/Xms 设置 4g 会怎么样？</p><p>4g 内存下跟并行 gc 相比呢？</p><p><strong>GC 日志解读与分析</strong></p><p>![image-20210411133951974](/Users/cutie/Library/Application Support/typora-user-images/image-20210411133951974.png)</p><p>阶段 1：Initial Mark（初始标记）</p><p>阶段 2：Concurrent Mark（并发标记）</p><p>阶段 3：Concurrent Preclean（并发预清理）</p><p>阶段 4： Final Remark（最终标记）</p><p>阶段 5： Concurrent Sweep（并发清除）</p><p>阶段 6： Concurrent Reset（并发重置）</p><p><strong>GC 日志解读与分析</strong></p><p>G1 GC</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134017.png" alt="image-20210411134017503"></p><p>java -XX:+UseG1GC</p><p>Xms512m -Xmx512m</p><p>Xloggc:gc.demo.log</p><p>XX:+PrintGCDetails</p><p>XX:+PrintGCDateStamps</p><p>GCLogAnalysis</p><p>观察 Young GC 与 Full GC</p><p>思考：假如Xmx/Xms 设置 4g 会怎么样？</p><p>4g 内存下跟 cms gc 相比呢？</p><p><strong>GC 日志解读与分析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134037.png" alt="image-20210411134037045"></p><p>Evacuation Pause: young（纯年轻代模式转移暂停）</p><p>Concurrent Marking（并发标记）</p><p>阶段 1: Initial Mark（初始标记）</p><p>阶段 2: Root Region Scan（Root区扫描）</p><p>阶段 3: Concurrent Mark（并发标记）</p><p>阶段 4: Remark（再次标记）</p><p>阶段 5: Cleanup（清理）</p><p>Evacuation Pause (mixed)（转移暂停: 混合模式）</p><p>Full GC (Allocation Failure)</p><p>思考：假模拟一下 full gc</p><p><strong>GC 日志解读与分析</strong></p><p>一个退化时的例子</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134104.png" alt="image-20210411134104100"></p><p><strong>GC 日志解读与分析</strong></p><p>4G 内存时的 G1，完全不一样</p><p>![image-20210411134119847](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134119847.png)</p><p><strong>GC 日志解读与分析</strong></p><p>GCEasy</p><p>![image-20210411134140707](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134140707.png)</p><p><strong>GC 日志解读与分析</strong></p><p>GCViewer</p><p>![image-20210411134155704](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134155704.png)</p><p>![image-20210411134212310](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134212310.png)</p><p>![image-20210411134228721](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134228721.png)</p><p><strong>GC 日志解读与分析</strong></p><p>总结：</p><p>如何查看/分析不同 GC 配置下的日志信息？</p><p>各种 GC 有什么特点和使用场景？</p><ol><li>JVM 线程堆栈数据分析</li></ol><p><strong>JVM 线程堆栈数据分析</strong></p><p>![image-20210411134249912](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134249912.png)</p><p><strong>JVM 线程堆栈数据分析</strong></p><p>JVM 内部线程主要分为以下几种：</p><p>VM 线程：单例的 VMThread 对象，负责执行 VM 操作，</p><p>下文将对此进行讨论;</p><p>定时任务线程：单例的 WatcherThread 对象， 模拟在</p><p>VM 中执行定时操作的计时器中断；</p><p>GC 线程：垃圾收集器中，用于支持并行和并发垃圾回收</p><p>的线程;</p><p>编译器线程： 将字节码编译为本地机器代码;</p><p>信号分发线程：等待进程指示的信号，并将其分配给Java</p><p>级别的信号处理方法。</p><p>安全点：</p><ol><li>方法代码中被植入的安全点检测入口；</li><li>线程处于安全点状态：线程暂停执行，这个时候线</li></ol><p>程栈不再发生改变；</p><ol><li>JVM 的安全点状态：所有线程都处于安全点状态。</li></ol><p>JVM 支持多种方式来进行线程转储：</p><ol><li>JDK 工具, 包括: jstack 工具, jcmd 工具, jconsole,</li></ol><p>jvisualvm, Java Mission Control 等；</p><ol><li>Shell 命令或者系统控制台, 比如 Linux 的 kill -3,</li></ol><p>Windows 的 Ctrl + Break 等；</p><ol><li>JMX 技术， 主要是使用 ThreadMxBean。</li></ol><p><strong>JVM 线程堆栈数据分析</strong></p><p>![image-20210411134307336](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134307336.png)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134331.png" alt="image-20210411134331572"></p><p><strong>JVM 线程堆栈数据分析</strong></p><p>fastthread 线程分析</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134349.png" alt="image-20210411134349309"></p><ol><li>内存分析与相关工具</li></ol><p><strong>内存分析与相关工具</strong></p><p><strong>请思考一个问题：</strong></p><p>一个对象具有100个属性，与100个对象每个具有1个属性，</p><p>哪个占用的内存空间更大？</p><p><strong>内存分析与相关工具</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134404.png" alt="image-20210411134404592"></p><p>一个 Java 对象占用多少内存？</p><p>可以使用 Instrumentation.getObjectSize()</p><p>方法来估算一个对象占用的内存空间。</p><p>JOL (Java Object Layout) 可以用来查看对象</p><p>内存布局。</p><p>对比结构体与Data Object？</p><p><strong>内存分析与相关工具</strong></p><p><strong>对象头和对象引用</strong></p><p>在64位 JVM 中，对象头占据的空间是 12-</p><p>byte(=96bit=64+32)，但是以8字节对齐，所以一</p><p>个空类的实例至少占用16字节。</p><p>在32位 JVM 中，对象头占8个字节，以4的倍数对</p><p>齐(32=4*8)。</p><p>所以 new 出来很多简单对象，甚至是 new</p><p>Object()，都会占用不少内容哈。</p><p>通常在32位 JVM，以及内存小于 -Xmx32G 的64位</p><p>JVM 上(默认开启指针压缩)，一个引用占的内存默</p><p>认是4个字节。</p><p>因此，64位 JVM 一般需要多消耗堆内存。</p><p><strong>包装类型</strong></p><p>比原生数据类型消耗的内存要多，详情可以参考</p><p>JavaWorld ：</p><p>Integer：占用16字节(8+4=12+补齐)，因为 int 部分</p><p>占4个字节。 所以使用 Integer 比原生类型 int 要多消</p><p>耗 300% 的内存。</p><p>Long：一般占用16个字节(8+8=16)，当然，对象的实</p><p>际大小由底层平台的内存对齐确定，具体由特定 CPU</p><p>平台的 JVM 实现决定。 看起来一个 Long 类型的对</p><p>象，比起原生类型 long 多占用了8个字节（也多消耗</p><p>了100%）。</p><p><strong>内存分析与相关工具</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134428.png" alt="image-20210411134428139"></p><p>多维数组：在二维数组 int[dim1][dim2] 中，每个</p><p>嵌套的数组 int[dim2] 都是一个单独的 Object，会</p><p>额外占用16字节的空间。当数组维度更大时，这种</p><p>开销特别明显。</p><p>int[128][2] 实例占用3600字节。 而 int[256] 实例</p><p>则只占用1040字节。里面的有效存储空间是一样</p><p>的，3600 比起1040多了246%的额外开销。在极</p><p>端情况下，byte[256][1]，额外开销的比例是19倍!</p><p>String: String 对象的空间随着内部字符数组的增</p><p>长而增长。当然，String 类的对象有24个字节的额</p><p>外开销。</p><p>对于10字符以内的非空 String，增加的开销比起有</p><p>效载荷（每个字符2字节 + 4 个字节的 length），</p><p>多占用了100% 到 400% 的内存。</p><p>对齐是绕不过去的问题</p><p>我们可能会认为，一个 X 类的实例占用17字节的空间。</p><p>但是由于需要对齐(padding)，JVM 分配的内存是8字节</p><p>的整数倍，所以占用的空间不是17字节,而是24字节。</p><p><strong>内存分析与相关工具</strong></p><p>内存泄漏的例子：</p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134446.png" alt="image-20210411134446646" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134501.png" alt="image-20210411134500884" style="zoom:50%;"><p><strong>内存分析与相关工具</strong></p><p>OutOfMemoryError: Java heap space</p><p>创建新的对象时，堆内存中的空间不足以存放新创建的对象</p><p>产生的原因，很多时候就类似于将 XXL 号的对象，往 S 号的 Java heap space 里面塞。其实清楚了</p><p>原因，问题就很容易解决了：只要增加堆内存的大小，程序就能正常运行。</p><p>另外还有一些情况是由代码问题导致的：</p><p>超出预期的访问量/数据量：应用系统设计时，一般是有 “容量” 定义的，部署这么多机器，用来</p><p>处理一定流量的数据/业务。 如果访问量突然飙升，超过预期的阈值，类似于时间坐标系中针尖形</p><p>状的图谱。那么在峰值所在的时间段，程序很可能就会卡死、并触发</p><p>java.lang.OutOfMemoryError: Java heap space错误。</p><p>内存泄露(Memory leak)：这也是一种经常出现的情形。由于代码中的某些隐蔽错误，导致系统占</p><p>用的内存越来越多。如果某个方法/某段代码存在内存泄漏，每执行一次，就会（有更多的垃圾对</p><p>象）占用更多的内存。随着运行时间的推移，泄漏的对象耗光了堆中的所有内存，那么</p><p>java.lang.OutOfMemoryError: Java heap space 错误就爆发了。</p><p><strong>内存分析与相关工具</strong></p><p>OutOfMemoryError: PermGen space/OutOfMemoryError: Metaspace</p><p>java.lang.OutOfMemoryError: PermGen space 的主要原因，是加载到内存中的</p><p>class 数量太多或体积太大，超过了 PermGen 区的大小。</p><p>解决办法：增大 PermGen/Metaspace</p><p>XX:MaxPermSize=512m</p><p>XX:MaxMetaspaceSize=512m</p><p>高版本 JVM 也可以：</p><p>XX:+CMSClassUnloadingEnabled</p><p><strong>内存分析与相关工具</strong></p><p>OutOfMemoryError: Unable to create new native thread</p><p>java.lang.OutOfMemoryError: Unable to create new native thread 错误是程序创</p><p>建的线程数量已达到上限值的异常信息。</p><p>解决思路：</p><ol><li>调整系统参数 ulimit -a，echo 120000 &gt; /proc/sys/kernel/threads-max</li><li>降低 xss 等参数</li><li>调整代码，改变线程创建和使用方式</li></ol><p><strong>内存分析与相关工具</strong></p><p>内存 Dump 分析工具</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134530.png" alt="image-20210411134530063"></p><p>Eclipse MAT</p><p>jhat</p><p>留给大家自己研究4. JVM 问题分析调优经验</p><p><strong>JVM 问题分析调优经验</strong></p><p>1、高分配速率(High Allocation Rate)</p><p>分配速率(Allocation rate)表示单位时间内分配的内存量。通常</p><p>使用 MB/sec 作为单位。上一次垃圾收集之后，与下一次 GC 开</p><p>始之前的年轻代使用量，两者的差值除以时间,就是分配速率。</p><p>分配速率过高就会严重影响程序的性能，在 JVM 中可能会导致巨</p><p>大的 GC 开销。</p><p>正常系统：分配速率较低 ~ 回收速率 -&gt; 健康</p><p>内存泄漏：分配速率 持续大于 回收速率 -&gt; OOM</p><p>性能劣化：分配速率较高 ~ 回收速率 -&gt; 压健康</p><p><strong>JVM 问题分析调优经验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134547.png" alt="image-20210411134547303"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134604.png" alt="image-20210411134604177"></p><p>JVM 启动之后 291ms，共创建了 33,280 KB 的对</p><p>象。第一次 Minor GC（小型GC) 完成后，年轻代</p><p>中还有 5,088 KB 的对象存活。</p><p>在启动之后 446 ms，年轻代的使用量增加到</p><p>38,368 KB，触发第二次 GC，完成后年轻代的使</p><p>用量减少到 5,120 KB。</p><p>在启动之后 829 ms，年轻代的使用量为 71,680</p><p>KB，GC 后变为 5,120 KB。</p><p><strong>JVM 问题分析调优经验</strong></p><p>思考一个问题，</p><p>分配速率，到底影响什么？</p><p>想一想，new 出来的对象，在什么地方。</p><p>答案就是，Eden。</p><p>假如我们增加 Eden，会怎么样。</p><p>考虑蓄水池效应。</p><p>最终的效果是，影响 Minor GC的次数和时间，进而影响吞吐量。</p><p>在某些情况下，只要增加年轻代的大小，即可降低分配速率过高所造成的影响。</p><p>增加年轻代空间并不会降低分配速率，但是会减少 GC 的频率。如果每次 GC 后</p><p>只有少量对象存活，minor GC 的暂停时间就不会明显增加。</p><p><strong>JVM 问题分析调优经验</strong></p><p>2、过早提升(Premature Promotion)</p><p>提升速率（promotion rate）用于衡量单位时间内从年轻代提</p><p>升到老年代的数据量。一般使用 MB/sec 作为单位, 和分配速率</p><p>类似。</p><p>JVM 会将长时间存活的对象从年轻代提升到老年代。根据分代假</p><p>设，可能存在一种情况，老年代中不仅有存活时间长的对象,，</p><p>也可能有存活时间短的对象。这就是过早提升：对象存活时间还</p><p>不够长的时候就被提升到了老年代。</p><p>major GC 不是为频繁回收而设计的，但 major GC 现在也要清</p><p>理这些生命短暂的对象，就会导致 GC 暂停时间过长。这会严重</p><p>影响系统的吞吐量。</p><p><strong>JVM 问题分析调优经验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134627.png" alt="image-20210411134627592"></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134641.png" alt="image-20210411134641320"></p><p>GC 之前和之后的年轻代使用量以及堆内存使用量。</p><p>这样就可以通过差值算出老年代的使用量。</p><p>和分配速率一样，提升速率也会影响 GC 暂停的频</p><p>率。但分配速率主要影响 minor GC，而提升速率</p><p>则影响 major GC 的频率。</p><p>有大量的对象提升，自然很快将老年代填满。老年</p><p>代填充的越快，则 major GC 事件的频率就会越高。</p><p><strong>JVM 问题分析调优经验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134659.png" alt="image-20210411134659790"></p><p>一般来说过早提升的症状表现为以下形式：</p><ol><li>短时间内频繁地执行 full GC</li><li>每次 full GC 后老年代的使用率都很低，在10-</li></ol><p>20%或以下</p><ol><li>提升速率接近于分配速率</li></ol><p>要演示这种情况稍微有点麻烦，所以我们使用特殊</p><p>手段，让对象提升到老年代的年龄比默认情况小很</p><p>多。指定 GC 参数 -Xmx24m -XX:NewSize=16m</p><p>XX:MaxTenuringThreshold=1，运行程序之后，</p><p>可以看到下面的 GC 日志。</p><p><strong>JVM 问题分析调优经验</strong></p><p>解决这类问题，需要让年轻代存放得下暂存的数据，有两种简单</p><p>的方法：</p><p>一是增加年轻代的大小，设置 JVM 启动参数，类似这样：-</p><p>Xmx64m -XX:NewSize=32m，程序在执行时，Full GC 的次数</p><p>自然会减少很多，只会对 minor GC 的持续时间产生影响。</p><p>二是减少每次批处理的数量，也能得到类似的结果。</p><p>至于选用哪个方案，要根据业务需求决定。 在某些情况下，业务</p><p>逻辑不允许减少批处理的数量，那就只能增加堆内存，或者重新</p><p>指定年轻代的大小。 如果都不可行，就只能优化数据结构，减少</p><p>内存消耗。</p><p>但总体目标依然是一致的：让临时数据能够在年轻代存放得下。</p><ol><li>GC 疑难情况问题分析</li></ol><p><strong>GC 疑难情况问题分析</strong></p><p>Arthas 诊断分析工具</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134720.png" alt="image-20210411134720861"></p><p>![image-20210411134741837](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134741837.png)</p><p><strong>GC 疑难情况问题分析</strong></p><p>1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等， 基础服务、外部 API 依赖 。</p><p>2、查看系统资源和监控信息：</p><p>硬件信息、操作系统平台、系统架构；</p><p>排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发竞</p><p>争等情况；</p><p>排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调整、</p><p>超时、连接数。</p><p>3、查看性能指标，包括实时监控、历史数据。可以发现 假死，卡顿、响应变慢等现象；</p><p>排查数据库， 并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询</p><p>数据量、redo日志、undo、 binlog 日志、代理、工具 BUG。可以考虑的优化包括： 集群、主备、只读</p><p>实例、分片、分区；</p><p>大数据，中间件，JVM 参数。</p><p>4、排查系统日志， 比如重启、崩溃、Kill 。</p><p>5、APM，比如发现有些链路请求变慢等等。</p><p>6、排查应用系统</p><p>排查配置文件: 启动参数配置、Spring 配置、JVM 监控参数、数据库参数、Log 参数、APM 配置、</p><p>内存问题，比如是否存在内存泄漏，内存溢出、批处理导致的内存放大、GC 问题等等；</p><p>GC 问题， 确定 GC 算法、确定 GC 的 KPI，GC 总耗时、GC 最大暂停时间、分析 GC 日志和监控指标： 内存</p><p>分配速度，分代提升速度，内存使用率等数据。适当时修改内存配置；</p><p>排查线程, 理解线程状态、并发线程数，线程 Dump，锁资源、锁等待，死锁；</p><p>排查代码， 比如安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三方</p><p>库、XSS、CORS、正则；</p><p>单元测试： 覆盖率、边界值、Mock 测试、集成测试。</p><p>7、 排除资源竞争、坏邻居效应</p><p>8、疑难问题排查分析手段</p><p>DUMP 线程\内存；</p><p>抽样分析\调整代码、异步化、削峰填谷。</p><p><strong>GC 疑难情况问题分析</strong></p><p>一个真实的案例分析</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134811.png" alt="image-20210411134811864"></p><p>并行 GC 暂停太高</p><p>G1 GC 暂停还是太高</p><p>找到问题，最终优化</p><ol><li>JVM 常见面试问题汇总</li></ol><p>![image-20210411134843826](/Users/cutie/Library/Application Support/typora-user-images/image-20210411134843826.png)</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210411134911.png" alt="image-20210411134911320"></p><p><strong>VM 常见面试问题汇总</strong></p><ol><li>总结回顾与作业实践</li></ol><p><strong>第 3 课总结回顾</strong></p><ol><li>GC 日志解读与分析*</li><li>JVM 线程堆栈数据分析</li><li>内存分析与相关工具*</li><li>JVM 问题分析调优经验*</li><li>GC 疑难情况问题分析</li><li>JVM 常见面试问题汇总*</li></ol><p><strong>第 3 课作业实践</strong></p><p>1、使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例。</p><p>2、使用压测工具（wrk或sb），演练gateway-server-0.0.1-SNAPSHOT.jar 示例。</p><p>3、(选做)如果自己本地有可以运行的项目，可以按照2的方式进行演练。</p><p>根据上述自己对于1和2的演示，写一段对于不同 GC 的总结，提交到 Github。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《把时间当做朋友》读后感</title>
      <link href="2021/02/19/%E8%AF%BB%E5%90%8E%E6%84%9F/%E3%80%8A%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>2021/02/19/%E8%AF%BB%E5%90%8E%E6%84%9F/%E3%80%8A%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="契机"><a href="#契机" class="headerlink" title="契机"></a>契机</h2><p>前段时间，朋友推荐我李笑来老师的定投践行群，传说中那个割韭菜的男人创建的群。对李笑来这个人，不反感，也没有好感，这个群很像是传销群，但是又不像传销群。里面添加了授课的内容以及一帮践行定投的人陪着你一起践行定投box。朋友说你进来就会有收获，凭借对朋友的信任以及好奇心，我加入了这个群，截止今天我才投了1000，而盈利金额已达到了50%。为什么那么少？因为我把钱投到了其他地方，矿机，因为我觉得矿机更能够提现时间的价值，每天一直挖矿获得利润的感觉是否是另一种把时间当做朋友的体验？只是没想到box，或者说btc的价值上涨得那么快（捶胸顿足）。</p><h2 id="我们要管理的不是时间，而是我们自己"><a href="#我们要管理的不是时间，而是我们自己" class="headerlink" title="我们要管理的不是时间，而是我们自己"></a>我们要管理的不是时间，而是我们自己</h2><p>很多人想着不劳而获，我承认我不想做那种人，但是却经常做这种梦。偶尔内心还是时不时期望着自己的老子家财万贯，只是没有告诉我：”我们家其实很有钱，只是没告诉你而已。”但是这个想法自从体验到没钱是多么无奈之后就完全打消了。钱，都说这个东西有了没太大作用，但是没有钱是万万不能的。</p><p>小时候因为家里没有钱感觉自己很自卑，为什么其他同学都穿着耐克阿迪？为什么我家里还是水泥墙？小学的时候记得有个女同学说：xx，我知道你家在哪里了。当时我的反应是面红耳赤，无地自容。小孩子的自尊总是那么的敏感，或许是我这个人敏感，敏感自己的家徒四壁，想着人家是知道了我的家是如何无法落脚。小学的时候同桌一个女生邀请我去参加她的生日，是去kfc。当时的我哪里去过kfc，我自卑的心里又开始作祟，心里想着送人家什么东西比较好，一方面又因为觉得自己家里穷，整个人完全没自信，再加上没去过kfc，不敢去。最后的最后，当然我还是没去成，后来在教室的时候，人家问我为什么没去？我说了句：只有我一个男生，不好意思去。</p><p>以至于到现在，我都害怕穷，怕自己没钱会被人家看不起。但是，这仅仅是我自己的想法，因为这个想法，不开心了那么多年。害怕自己以为的人家对自己的看法。</p><p>秦老师之前说，我们每个人都像是一件产品，用心打磨，总有一天会成为一件好的产品。时间，虚无，缥缈，空洞，无法把握，但是我们在这个有限的时间里，做一些什么事情才能算是在我们这短暂的一生留下印记？毕竟人死一捧灰，活着的时候，我们给别人带来的快乐是实在的，做事达成了成就是实在的，写下的每一个字是实在的。但是如果我埋头辛辛苦苦地赚钱，虽然就目前来说，我低着头在地上埋头苦找我的6便士是必要的，谁都需要生存。但是达到生存这一目标其实成本越来越低。不管你做什么，总能果腹。而因为买了房子，30年所需要还的贷款是贷款金额的2倍，我何时能够抬头看看我的月亮？</p><p>很多时候，发现自己的出发点都是为了赚钱，而没有打磨赚钱的技能。钱这个东西，本来就没自己想象中那么喜欢，今年1月涨了一点工资，过年的时候发了，结果我完全没有注意到工资的变动，反而是同事发现了涨工资之后好像多扣了几十块钱。赚钱带给我的喜悦已渐渐远去，但是我还是会记得第一次实习的时候，从老师手中接过那800元人民币，第一次用自己的双手赚钱的感觉。</p><p>为什么说到时间我说了一大堆钱的事情？因为我对它看的太重，以至于我的生活好像都不是那么快乐。</p><h2 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h2><h3 id="完美永不存在"><a href="#完美永不存在" class="headerlink" title="完美永不存在"></a>完美永不存在</h3><p>不要把我不能做完美的事情我不做当做借口，世上没有能做的完美的事情，也没有事事都完美的人，人之所以是人，就是因为不完美，千万不要因为自己的装逼，导致很多事情本来是能做的，却没有去做。</p><p>换句话说，去做了，这件事就是完美的。</p><h3 id="未知永远存在"><a href="#未知永远存在" class="headerlink" title="未知永远存在"></a>未知永远存在</h3><p>为了进步，我们必须忍受一部分未知。不然，我们的注意力会一直被那一部分未知所吸引，乃至消磨掉所有的耐心，最后，还是停留在未知，却没往后看看未知的后面隐藏着一些能够解释未知的知识。</p><p>人的线总是一步一步拓宽的，抄新华字典是一件枯燥的事情，如果那么枯燥的事情你都能坚持下来，以后还有什么枯燥的事情是你坚持不下来的呢？</p><p>当问题没有解决的时候，最好可以先记录下来，让这个未知的问题得到一个被审视的机会。</p><h3 id="5-现状无法马上摆脱"><a href="#5-现状无法马上摆脱" class="headerlink" title="5.现状无法马上摆脱"></a>5.现状无法马上摆脱</h3><blockquote><p>其实，世界上80%以上的职业并不过分依赖天分，更可能甚至几乎只依赖积累。天长日久，这个人在当前的职业中将逐渐落后于那些认真做事的人。但此时他不会因为自己的落后而奋起直追，反过来，更可能的是把“反正我的梦想不是这个”当作借口。</p></blockquote><hr><p><strong>重新开始写，读一点写一点记录一下</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李笑来 </tag>
            
            <tag> 个人提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java1期第一课【Week01-01 JVM 核心技术--基础知识】补充笔记</title>
      <link href="2021/02/19/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Java1%E6%9C%9F%E7%AC%AC%E4%B8%80%E8%AF%BE%E3%80%90Week01-01%20JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF--%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91%E8%A1%A5%E5%85%85%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/19/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Java1%E6%9C%9F%E7%AC%AC%E4%B8%80%E8%AF%BE%E3%80%90Week01-01%20JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF--%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91%E8%A1%A5%E5%85%85%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>学习理论说，仅仅听讲只能获得知识的5-10%，只有经过实践和思考，才能变成你的经验。</p><p>1）一定要看预习材料，那是我和铁锚老师的jvm书稿的一部分，很详细。</p><p>2）课上的两个小时是帮大家组织起技术体系，带大家操作演示。</p><p>3）课后动手实践，按课上的演练自己是实验，最后完成必做作业。</p><h2 id="1、字节码"><a href="#1、字节码" class="headerlink" title="1、字节码"></a>1、字节码</h2><p>字节码的本质是java代码编译后的，给jvm虚拟机运行的操作指令。</p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>字节码不需要全部掌握，大家明白原理就好，面试一般问的也不会太多。</p><p>比如 0: new #2</p><p>表示的是本块代码的第一个指令是new 一个常量池里的第二个常量代表的类型的实例。</p><p>其中new的操作码二进制是bb，操作数是2，那么用二进制表示这条指令就是3个字节：bb 00 02，补上一个00是因为new后面跟两个操作数。（大家想想为什么需要2个操作数？ ）</p><h3 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h3><p>了解字节码有两个用途：</p><p>1）能够了解底层jvm执行的是什么，可以用来分析不同代码是否是等价的，如果不等价哪个方式更好。</p><p>比如for循环里用i++还是for(i:数组) 。通过课上的演示，我们知道他们是等价的。（大家想想，如果for : 里不是数组，而是list，字节码会怎么样？）</p><p>比如String a = “a” + “b”; String c = a + “c”; 通过字节码分析，我们知道：</p><p>编译后”a” + “b”直接变成了“ab”，相当于 a =“ab”；</p><p>字符串String作为一个类，是不能做+操作的，所以在字节码层面，都转换成了StringBuilder的append操作，上面的代码相当于String c = new StringBuilder().append(“ab”).append(“c”).toString(); </p><p>2）后面学习AOP的时候，有一大块是字节码操作和增强，这里的内容是那一部分的基础。</p><h2 id="2、类加载器（☆重点）"><a href="#2、类加载器（☆重点）" class="headerlink" title="2、类加载器（☆重点）"></a>2、类加载器（☆重点）</h2><p>类加载器负责把字节码文件或字节码的byte[]转换成为jvm中的类。</p><h3 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h3><p>理解类加载器的原理和作用，加载时机，三类类加载器。</p><p>三个特性：双亲委托，加载依赖，类型缓存。</p><p>知道如何给项目程序添加依赖的jar或路径。</p><p>了解URLClassLoader的作用和跟扩展类加载器、应用类加载器的关系。</p><p>学会自定义简单的classloader。</p><h3 id="学以致用-1"><a href="#学以致用-1" class="headerlink" title="学以致用"></a>学以致用</h3><p>注意：JDK9里扩展类加载器和应用类加载器，不再继承URLClassLoader。</p><p>但是可以这些主动加载： Class.forName(“xxx”, new URLClassloader(“dddd”));</p><p>了解类加载器有几个用途：</p><p>1）能够清楚知道字节码是如何加载的；</p><p>2）能够分析程序加载了那些jar或路径，从而排查找不到类的错误问题；如果遇到了找不到方法或方法参数不匹配的错误问题，说明加载了错误版本的jar，也可以用相同方法排查；</p><p>3）可以实现自定义classloader，做加密、混淆等，保护我们的jar包不被反编译和破解；实际上通过自定义classloader，我们在类加载到jvm的时候可以做一些额外的处理（想想是不是跟AOP有点像？）；</p><p>4）早期实现动态加载，模块化都是基于自定义classloader的，如果我们实现两个自定义classloader，比如A和B，他们没有关系，且各自加载了一个叫Hello的类，这两个Hello的类型是不同的，这样就可以实现不同版本的类隔离（如果代码写的不恰当，也可能会出现所谓A的一个Hello类的实例，运行时做类型转换无法转换成B的Hello类型的错误）；</p><p>5）作业必做题与此相关。</p><p>需要注意的是：jdk代码里写死了，不允许自定义classloader加载以java.开头包名的类。</p><h2 id="3、Java内存模型（☆重点）"><a href="#3、Java内存模型（☆重点）" class="headerlink" title="3、Java内存模型（☆重点）"></a>3、Java内存模型（☆重点）</h2><p>类被加载到JVM中，代码运行时都需要使用内存，所以Java内存模型就是用来规定JVM内部的内存结构。</p><h3 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h3><p>了解栈、堆、非堆、堆外等内存，以及它们的关系和区别。</p><p>了解栈的结构，可以跟前面字节码执行对应起来。</p><p>了解堆的结构，新生代young gen，老年代old gen，新生代又包括eden和s0、s1</p><p>了解非堆和堆外是用来做什么的。</p><h3 id="学以致用-2"><a href="#学以致用-2" class="headerlink" title="学以致用"></a>学以致用</h3><p>了解内存模型有几个用途：</p><p>1）这一块是下一节课讲的GC的基础，也是第三个模块讲并发编程的基础，这一块熟悉了有利于学习GC和并发；</p><p>2）面试经常会被问到这个问题；</p><p>3）作业必做题与这一块有直接关系，多动手画一画，有助于面试时能比较好的讲清楚。</p><h2 id="4、命令行参数"><a href="#4、命令行参数" class="headerlink" title="4、命令行参数"></a>4、命令行参数</h2><p>JVM作为一个通用的虚拟计算机，是通过java命令来启动的，为了让JVM能够适应不同的需求环境，所以需要配置不同的参数使JVM更好的工作，这就是java命令执行的命令行参数。</p><h3 id="学习目标-3"><a href="#学习目标-3" class="headerlink" title="学习目标"></a>学习目标</h3><p>常用的命令行参数有哪些？</p><p>标准参数 -server</p><p>非标准参数 -Xmx，-XX：xxxx=yyyy</p><p>系统属性-Dxxx=yyy</p><h3 id="学以致用-3"><a href="#学以致用-3" class="headerlink" title="学以致用"></a>学以致用</h3><p>jvm内存配置经验：xmx ~ 不要超过系统可用内存的60-80%</p><p>例如 系统有4g可用内存 -&gt; 4g*0.6<del>0.8 -&gt; 可以设置xmx为2.4</del>3.2g</p><p>java参数目前有1000多个，其中GC相关的占一大半。具体参数相关的一些问题，我们下节课继续讲。</p><h2 id="5、课堂答疑"><a href="#5、课堂答疑" class="headerlink" title="5、课堂答疑"></a>5、课堂答疑</h2><p>其他的问题整理与回答：</p><p><a href="https://shimo.im/docs/rcxYt6PtQgkkyd8h">https://shimo.im/docs/rcxYt6PtQgkkyd8h</a></p><h2 id="6、其他资料"><a href="#6、其他资料" class="headerlink" title="6、其他资料"></a>6、其他资料</h2><p>官方对JDK/JRE、classloader和一些工具的说明：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210219092358.png!thumbnail" alt="img"></p><p>上图来源于：<a href="https://docs.oracle.com/javase/8/docs/">https://docs.oracle.com/javase/8/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week01-01 JVM 核心技术--基础知识</title>
      <link href="2021/02/18/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week01-01-JVM-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/02/18/java%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/Week01-01-JVM-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第1课-JVM-核心技术–基础知识"><a href="#第1课-JVM-核心技术–基础知识" class="headerlink" title="第1课  JVM 核心技术–基础知识"></a>第1课  JVM 核心技术–基础知识</h1><p><strong>目录</strong></p><ol><li>JVM 基础知识：不积跬步，无以至千里</li><li>Java 字节码技术：不积细流，无以成江河</li><li>JVM 类加载器*：山不辞土，故能成其高</li><li>JVM 内存模型*：海不辞水，故能成其深</li><li>JVM 启动参数：博观而约取、厚积而薄发</li><li>第1课总结回顾与作业实践</li></ol><h2 id="1-JVM-核心技术–基础知识"><a href="#1-JVM-核心技术–基础知识" class="headerlink" title="1. JVM 核心技术–基础知识"></a>1. JVM 核心技术–基础知识</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a><strong>编程语言</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218232956.png" alt="image-20210218232956278"></p><p>面向过程、面向对象、面向函数</p><p>静态类型、动态类型</p><p>编译执行、解释执行</p><p>有虚拟机、无虚拟机</p><p>有 GC、无 GC</p><p>Java 是一种面向对象、静态类型、编译执行，</p><p>有 VM/GC 和运行时、跨平台的高级语言。</p><h3 id="编程语言跨平台"><a href="#编程语言跨平台" class="headerlink" title="编程语言跨平台"></a><strong>编程语言跨平台</strong></h3><p><strong>源代码跨平台</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218233210.png" alt="image-20210218233210633"></p><p><strong>二进制跨平台</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218233411.png" alt="image-20210218233411294"></p><p><strong>Java、C++、Rust 的区别</strong></p><p><strong>C/C++</strong> 完全相信而且惯着程序员，让大家自行管理内存，可以编写很自由的代码，但一不小心就会造成内存泄漏等问题，导致程序崩溃。</p><p><strong>Java/Golang</strong> 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。 内存使用有问题的时候，我们可以通过 JVM 来进行信息相关的分析诊断和调整。 这也是本课程的目标。</p><p><strong>Rust</strong> 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。</p><h3 id="字节码、类加载器、虚拟机"><a href="#字节码、类加载器、虚拟机" class="headerlink" title="字节码、类加载器、虚拟机"></a><strong>字节码、类加载器、虚拟机</strong></h3><p>![image-20210218233626837](/Users/cutie/Library/Application Support/typora-user-images/image-20210218233626837.png)</p><h2 id="2-Java-字节码技术"><a href="#2-Java-字节码技术" class="headerlink" title="2. Java 字节码技术"></a>2. Java 字节码技术</h2><h3 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a><strong>什么是字节码？</strong></h3><p>Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。</p><p>实际上 Java 只使用了200左右的操作码， 还有一些操作码则保留给调试操作。</p><p>根据指令的性质，主要分为四个大类：</p><ol><li>栈操作指令，包括与局部变量交互的指令</li><li>程序流程控制指令</li><li>对象操作指令，包括方法调用指令</li><li>算术运算以及类型转换指令</li></ol><p>1，java的所有的操作都发生在栈上；是用来真正做计算的</p><p>2，3，4都跟java语法相关的</p><h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a><strong>生成字节码</strong></h3><p>假如有一个最简单的类，源代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234107.png" alt="image-20210218234107349"></p><p>编译：javac demo/jvm0104/HelloByteCode.java</p><p>查看字节码：javap -c demo.jvm0104.HelloByteCode</p><h3 id="最简单的字节码"><a href="#最简单的字节码" class="headerlink" title="最简单的字节码"></a><strong>最简单的字节码</strong></h3><p>结果如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234121.png" alt="image-20210218234120981"></p><p>上图使用助记符的方式展示出来的</p><p>aload_0 是助记符，是字节码里面的操作码。栈，本地变量表。</p><p>运行时候，变量挪到栈上，运行结束后，放回本地变量表。</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234217.png" alt="image-20210218234217321"></p><h3 id="复杂点的例子"><a href="#复杂点的例子" class="headerlink" title="复杂点的例子"></a><strong>复杂点的例子</strong></h3><p>进一步：javap -c -verbose demo.jvm0104.HelloByteCode</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234244.png" alt="image-20210218234244088"></p><p>52.0默认表示java8的版本，每上一个大版本，都会加1</p><p>flags表示类是public还是非public</p><p>Constant pool，常量池</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234303.png" alt="image-20210218234303117"></p><h3 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a><strong>字节码的运行时结构</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234343.png" alt="image-20210218234343475"></p><p>JVM 是一台基于栈的计算机器。</p><p>每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储栈帧（Frame）。</p><p>每一次方法调用，JVM 都会自动创建一个栈帧。</p><p>栈帧由操作数栈， 局部变量数组以及一个 Class 引用组成。</p><p>Class 引用 指向当前方法在运行时常量池中对应的 Class。</p><h3 id="从助记符到二进制"><a href="#从助记符到二进制" class="headerlink" title="从助记符到二进制"></a><strong>从助记符到二进制</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234358.png" alt="image-20210218234358007"></p><h3 id="四则运行的例子"><a href="#四则运行的例子" class="headerlink" title="四则运行的例子"></a><strong>四则运行的例子</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234411.png" alt="image-20210218234411785"></p><h3 id="数值处理与本地变量表"><a href="#数值处理与本地变量表" class="headerlink" title="数值处理与本地变量表"></a><strong>数值处理与本地变量表</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234433.png" alt="image-20210218234433598"></p><p>i int， load 加载到栈，store 放回，const常量， dstore double类型的存储</p><p>i2d integer转换为double</p><h3 id="算数操作与类型转换"><a href="#算数操作与类型转换" class="headerlink" title="算数操作与类型转换"></a><strong>算数操作与类型转换</strong></h3><p>算数操作与类型转换</p><p>![image-20210218234443510](/Users/cutie/Library/Application Support/typora-user-images/image-20210218234443510.png)</p><p>byte，boolean 用int，是最小单位，32位</p><p>int（32位）和long（64位）是否是原子性的？32位机器处理long需要处理2次，64位只要处理一次，主流的都是原子操作</p><h3 id="一个完整的循环控制"><a href="#一个完整的循环控制" class="headerlink" title="一个完整的循环控制"></a><strong>一个完整的循环控制</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234507.png" alt="image-20210218234507284"></p><p>if_icmpge 比较大小，如果不符合的话跳转到43，iinc int类型的自增加1，goto 跑到第18个标号，</p><h3 id="方法调用的指令"><a href="#方法调用的指令" class="headerlink" title="方法调用的指令"></a><strong>方法调用的指令</strong></h3><p>方法调用的指令：</p><p>invokestatic，顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个。</p><p>invokespecial, 用来调用构造函数，但也可以用于调用同一个类中的 private 方法, 以及可见的超类方法。</p><p>invokevirtual，如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和package 级的私有方法。</p><p>invokeinterface，当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。</p><p>invokedynamic，JDK7 新增加的指令，是实现“动态类型语言”（Dynamically TypedLanguage）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基础。</p><p><strong>一个动态例子</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234718.png" alt="image-20210218234718062"></p><h2 id="3-JVM-类加载器"><a href="#3-JVM-类加载器" class="headerlink" title="3. JVM 类加载器"></a>3. JVM 类加载器</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a><strong>类的生命周期</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234745.png" alt="image-20210218234745547"></p><ol><li>加载（Loading）：找 Class 文件</li><li>验证（Verification）：验证格式、依赖</li><li>准备（Preparation）：静态字段、方法表</li><li>解析（Resolution）：符号解析为引用</li><li>初始化（Initialization）：构造器、静态变量赋值、静态代码块</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><h3 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a><strong>类的加载时机</strong></h3><ol><li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new一个类的时候要初始化；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><p>1主类，2new，3，4静态调用，5父类，6default，7，8反射 </p><h3 id="不会初始化（可能会加载）"><a href="#不会初始化（可能会加载）" class="headerlink" title="不会初始化（可能会加载）"></a><strong>不会初始化（可能会加载）</strong></h3><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化。</li><li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName（“jvm.Hello”）默认会加载 Hello 类。</li><li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）。</li></ol><h3 id="三类加载器"><a href="#三类加载器" class="headerlink" title="三类加载器"></a><strong>三类加载器</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234847.png" alt="image-20210218234847003"></p><p>三类加载器：</p><ol><li>启动类加载器（BootstrapClassLoader）</li><li>扩展类加载器（ExtClassLoader）</li><li>应用类加载器（AppClassLoader）</li></ol><p>加载器特点：</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234857.png" alt="image-20210218234857042"></p><p>避免类被重复加载</p><ol><li>双亲委托：业务类加载器，需要用一个类的时候，父类加载器里面是否该类已经被加载了，如果没有，从祖父加载器中找是否已经加载了，如果找到了就给应用加载器使用</li><li>负责依赖：</li><li>缓存加载：类加载了就缓存起来，对每个类加载器来说，同一个类型的类只会被加载一次</li></ol><p>jdk9之前ExtClassLoader和AppClassLoader的父类都是URLClassLoader</p><h3 id="显示当前ClassLoader-加载了哪些-Jar？"><a href="#显示当前ClassLoader-加载了哪些-Jar？" class="headerlink" title="显示当前ClassLoader 加载了哪些 Jar？"></a><strong>显示当前ClassLoader 加载了哪些 Jar？</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218234951.png" alt="image-20210218234951527"></p><h3 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a><strong>自定义 ClassLoader</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235043.png" alt="image-20210218235043536"></p><h3 id="添加引用类的几种方式"><a href="#添加引用类的几种方式" class="headerlink" title="添加引用类的几种方式"></a><strong>添加引用类的几种方式</strong></h3><p>1、放到 JDK 的 lib/ext 下，或者-Djava.ext.dirs</p><p>2、 java –cp/classpath 或者 class 文件放到当前路径</p><p>3、自定义 ClassLoader 加载</p><p>4、拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径(JDK9 无效)。（JDK9之后只要一行）</p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235342.png" alt="image-20210218235342159"></p><h2 id="4-JVM-内存模型"><a href="#4-JVM-内存模型" class="headerlink" title="4.JVM 内存模型"></a>4.JVM 内存模型</h2><h3 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a><strong>JVM 内存结构</strong></h3><p>![image-20210218235435915](/Users/cutie/Library/Application Support/typora-user-images/image-20210218235435915.png)</p><p>每个线程都只能访问自己的线程栈。</p><p>每个线程都不能访问（看不见）其他线程的局部变量。</p><p>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。</p><p>线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。</p><p>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。 其中也涵盖了包装类型（例如 Byte，Integer，Long 等）。</p><p>不管是创建一个对象并将其赋值给局部变量， 还是赋值给另一个对象的成员变量， 创建的对象都会被保存到堆内存中。</p><p><strong>JVM 内存结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235503.png" alt="image-20210218235503518"></p><p>如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。</p><p>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。</p><p>对象的成员变量与对象本身一起存储在堆上, 不管成员变量的类型是原生数值，还是对象引用。类的静态变量则和类定义一样都保存在堆中。</p><p><strong>JVM 内存结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235528.png" alt="image-20210218235528760"></p><p>总结一下：方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。</p><p>堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问, 只要他们能拿到对象的引用地址。如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。</p><p>如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。</p><h3 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a><strong>JVM 内存整体结构</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235541.png" alt="image-20210218235541105"></p><p>每启动一个线程，JVM 就会在栈空间栈分配对应的 线程栈, 比如 1MB 的空间（-Xss1m）。</p><p>线程栈也叫做 Java 方法栈。 如果使用了JNI 方法，则会分配一个单独的本地方法栈(Native Stack)。</p><p>线程执行过程中，一般会有多个方法组成调用栈（Stack Trace）, 比如 A 调用 B，B调用 C。。。每执行到一个方法，就会创建对应的 栈帧（Frame）。</p><h3 id="JVM-栈内存结构"><a href="#JVM-栈内存结构" class="headerlink" title="JVM 栈内存结构"></a><strong>JVM 栈内存结构</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235553.png" alt="image-20210218235553092"></p><p>栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。</p><p>比如返回值 需要有一个空间存放吧，每个局部变量都需要对应的地址空间，此外还有给指令使用的 操作数栈，以及 class 指针（标识这个栈帧对应的是哪个类的方法,指向非堆里面的 Class 对象）。</p><h3 id="JVM-堆内存结构"><a href="#JVM-堆内存结构" class="headerlink" title="JVM 堆内存结构"></a><strong>JVM 堆内存结构</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235608.png" alt="image-20210218235608903"></p><p>堆内存是所有线程共用的内存空间，JVM 将Heap 内存分为年轻代（Young generation）和老年代（Old generation, 也叫 Tenured）两部分。</p><p>年轻代还划分为 3 个内存池，新生代（Edenspace）和存活区（Survivor space）, 在大部分GC 算法中有 2 个存活区（S0, S1），在我们可以观察到的任何时刻，S0 和 S1 总有一个是空的,但一般较小，也不浪费多少空间。</p><p>Non-Heap 本质上还是 Heap，只是一般不归 GC管理，里面划分为 3 个内存池。Metaspace, 以前叫持久代（永久代, Permanentgeneration）, Java8 换了个名字叫 Metaspace.</p><p>CCS, Compressed Class Space, 存放 class 信息的，和 Metaspace 有交叉。</p><p>Code Cache, 存放 JIT 编译器编译后的本地机器代码。</p><h3 id="CPU-与内存行为"><a href="#CPU-与内存行为" class="headerlink" title="CPU 与内存行为"></a><strong>CPU 与内存行为</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235702.png" alt="image-20210218235620082"></p><p>CPU 乱序执行</p><p>volatile 关键字</p><p>原子性操作</p><p>内存屏障</p><h3 id="小结：什么是-JMM"><a href="#小结：什么是-JMM" class="headerlink" title="小结：什么是 JMM?"></a><strong>小结：什么是 JMM?</strong></h3><p>所有的对象(包括内部的实例成员变量)，static 变量，以及数组，都必须存放到堆内存中。</p><p>局部变量，方法的形参/入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响。</p><p>多个线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象就称之为“冲突”。</p><p>可以被其他线程影响或感知的操作，称为线程间的交互行为， 可分为： 读取、写入、同步操作、外部操作等等。 其中同步操作包括：对 volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等等。 外部操作则是指对线程执行环境之外的操作，比如停止其他线程等等。</p><p>JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作。</p><p>JMM 规范对应的是“[JSR-133. JavaMemory Model and ThreadSpecification]”，《Java 语言规范》的 [$17.4. Memory Model章节]</p><p>JMM 规范明确定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了 Java 并发程序真正的跨平台。</p><h2 id="5-JVM-启动参数"><a href="#5-JVM-启动参数" class="headerlink" title="5.JVM 启动参数"></a>5.JVM 启动参数</h2><h3 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a><strong>JVM 启动参数</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235702.png" alt="image-20210218235702045"></p><p><strong>JVM 启动参数</strong></p><p>![image-20210218235740388](/Users/cutie/Library/Application Support/typora-user-images/image-20210218235740388.png)</p><p>-server</p><p>-Dfile.encoding=UTF-8</p><p>-Xmx8g</p><p>-XX:+UseG1GC</p><p>-XX:MaxPermSize=256m</p><p>以-开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容。</p><p>-D 设置系统属性。</p><p>以 -X 开头为非标准参数， 基本都是传给 JVM 的，默认 JVM 实现这些参数的功能，但是并不保证所有 JVM 实现都满足，且不保证向后兼容。 可以使用 java -X 命令来查看当前 JVM 支持的非标准参数。</p><p>以 –XX：开头为非稳定参数, 专门用于控制 JVM的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消。</p><p>XX：+-Flags 形式, +- 是对布尔值进行开关。</p><p>XX：key=value 形式, 指定某个选项的值。</p><p><strong>JVM 启动参数</strong></p><ol><li>系统属性参数</li><li>运行模式参数</li><li>堆内存设置参数</li><li>GC 设置参数</li><li>分析诊断参数</li><li>JavaAgent 参数</li></ol><h3 id="JVM-启动参数-系统属性"><a href="#JVM-启动参数-系统属性" class="headerlink" title="JVM 启动参数-系统属性"></a><strong>JVM 启动参数-系统属性</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/cutieagain/images@main/20210218235809.png" alt="image-20210218235809898"></p><p>-Dfile.encoding=UTF-8</p><p>-Duser.timezone=GMT+08</p><p>-Dmaven.test.skip=true</p><p>-Dio.netty.eventLoopThreads=8</p><p>System.setProperty(“a”,”A100”);</p><p>String a=System.getProperty(“a”);</p><p><strong>Linux上还可以通过: a=A100 java XXXJVM</strong></p><h3 id="启动参数-运行模式"><a href="#启动参数-运行模式" class="headerlink" title="启动参数-运行模式"></a><strong>启动参数-运行模式</strong></h3><ol><li>-server：设置 JVM 使用 server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有 64 位能力的 JDK 环境下将默认启用该模式，而忽略 -client 参数。</li><li>-client ：JDK1.7 之前在32位的 x86 机器上的默认值是 -client 选项。设置 JVM 使用 client 模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者 PC 应用开发和调试。此外，我们知道 JVM 加载字节码后，可以解释执行，也可以编译成本地代码再执行，所以可以配置 JVM 对字节码的处理模式：</li><li>-Xint：在解释模式（interpreted mode）下运行，-Xint 标记会强制 JVM 解释执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</li><li>-Xcomp：-Xcomp 参数与-Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。【注意预热】</li><li>-Xmixed：-Xmixed 是混合模式，将解释模式和编译模式进行混合使用，有 JVM 自己决定，这是 JVM 的默认模式，也是推荐模式。 我们使用 java -version 可以看到 mixed mode 等信息。</li></ol><p><strong>JVM 启动参数-堆内存</strong></p><p>![image-20210218235833782](/Users/cutie/Library/Application Support/typora-user-images/image-20210218235833782.png)</p><p>-Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为4g。这个内存不包括栈内存，也不包括堆外使用的内存。</p><p>-Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小，并不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。 专用服务器上需要保持 –Xms 和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时，堆内存扩容可能会导致性能抖动。</p><p>-Xmn, 等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.</p><p>-XX：MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的Meta空间无限大，此参数无效。</p><p>-XX：MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选项。</p><p>-XX：MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟 -Dsun.nio.MaxDirectMemorySize 效果相同。</p><p>-Xss, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB，与-XX:ThreadStackSize=1m 等价</p><p>堆内（Xms-Xmx）</p><p>非堆+堆外</p><ol><li>如果什么都不配置会如何？</li><li>Xmx 是否与 Xms 设置相等？</li><li>Xmx 设置为机器内存的什么比例合适？</li><li>作业：画一下 Xmx、Xms、Xmn、Meta、</li></ol><p>DirectMemory、Xss 这些内存参数的关系</p><h3 id="JVM-启动参数-GC-相关"><a href="#JVM-启动参数-GC-相关" class="headerlink" title="JVM 启动参数 - GC 相关"></a><strong>JVM 启动参数 - GC 相关</strong></h3><p>![image-20210218235908235](/Users/cutie/Library/Application Support/typora-user-images/image-20210218235908235.png)</p><p>-XX：+UseG1GC：使用 G1 垃圾回收器</p><p>-XX：+UseConcMarkSweepGC：使用 CMS 垃圾回收器</p><p>-XX：+UseSerialGC：使用串行垃圾回收器</p><p>-XX：+UseParallelGC：使用并行垃圾回收器</p><p>// Java 11+</p><p>-XX：+UnlockExperimentalVMOptions -XX:+UseZGC</p><p>// Java 12+</p><ol><li>各个 JVM 版本的默认 GC 是什么？ -XX：+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</li></ol><h3 id="JVM-启动参数-分析诊断"><a href="#JVM-启动参数-分析诊断" class="headerlink" title="JVM 启动参数-分析诊断"></a><strong>JVM 启动参数-分析诊断</strong></h3><p>-XX：+-HeapDumpOnOutOfMemoryError 选项, 当 OutOfMemoryError 产生，即内存溢出(堆内或持久代)时，自动 Dump 堆内存。</p><p>示例用法： java -XX:+HeapDumpOnOutOfMemoryError -Xmx256m ConsumeHeap</p><p>-XX：HeapDumpPath 选项, 与 HeapDumpOnOutOfMemoryError 搭配使用, 指定内存溢出时 Dump文件的目录。</p><p>如果没有指定则默认为启动 Java 程序的工作目录。</p><p>示例用法： java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ConsumeHeap</p><p>自动 Dump 的 hprof 文件会存储到 /usr/local/ 目录下。</p><p>-XX：OnError 选项, 发生致命错误时（fatal error）执行的脚本。</p><p>例如, 写一个脚本来记录出错时间, 执行一些命令, 或者 curl 一下某个在线报警的 url.</p><p>示例用法：java -XX:OnError=”gdb - %p” MyApp</p><p>可以发现有一个 %p 的格式化字符串，表示进程 PID。</p><p>-XX：OnOutOfMemoryError 选项, 抛出 OutOfMemoryError 错误时执行的脚本。</p><p>-XX：ErrorFile=filename 选项, 致命错误的日志文件名,绝对路径或者相对路径。</p><p>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试</p><h3 id="JVM-启动参数-JavaAgent"><a href="#JVM-启动参数-JavaAgent" class="headerlink" title="JVM 启动参数 -JavaAgent"></a><strong>JVM 启动参数 -JavaAgent</strong></h3><p>Agent 是 JVM 中的一项黑科技, 可以通过无侵入方式来做很多事情，比如注入 AOP 代码，执行统计等等，权限非常大。这里简单介绍一下配置选项，详细功能需要专门来讲。</p><p>设置 agent 的语法如下:</p><p>agentlib:libname[=options] 启用 native 方式的 agent, 参考 LD_LIBRARY_PATH 路径。</p><p>agentpath:pathname[=options] 启用 native 方式的 agent。</p><p>javaagent:jarpath[=options] 启用外部的 agent 库, 比如 pinpoint.jar 等等。</p><p>Xnoagent 则是禁用所有 agent。</p><p>以下示例开启 CPU 使用时间抽样分析:</p><p>JAVA_OPTS=”-agentlib:hprof=cpu=samples,file=cpu.samples.log”</p><h2 id="6-总结回顾与作业实践"><a href="#6-总结回顾与作业实践" class="headerlink" title="6.总结回顾与作业实践"></a>6.总结回顾与作业实践</h2><h3 id="第1课总结回顾"><a href="#第1课总结回顾" class="headerlink" title="第1课总结回顾"></a><strong>第1课总结回顾</strong></h3><p>字节码技术</p><p>类加载器</p><p>内存模型</p><p>启动参数</p><h3 id="第1课作业实践"><a href="#第1课作业实践" class="headerlink" title="第1课作业实践"></a><strong>第1课作业实践</strong></h3><p>1、（可选）自己写一个简单的 Hello.java，里面需要涉及基本类型，四则运行，if 和 for，然后自己分析一下对应的字节码，有问题群里讨论。</p><p>2、（必做）自定义一个 Classloader，加载一个 Hello.xlass 文件，执行 hello 方法，此文件内容是一个 Hello.class 文件所有字节（x=255-x）处理后的文件。文件群里提供。</p><p>3、（必做）画一张图，展示 Xmx、Xms、Xmn、Meta、DirectMemory、Xss 这些内存参数的关系。</p><p>4、（可选）检查一下自己维护的业务系统的 JVM 参数配置，用 jstat 和 jstack、jmap 查看一下详情，并且自己独立分析一下大概情况，思考有没有不合理的地方，如何改进。</p><p>注意：如果没有线上系统，可以自己 run 一个 web/java 项目。</p><h2 id="7-其他笔记"><a href="#7-其他笔记" class="headerlink" title="7.其他笔记"></a>7.其他笔记</h2><p>java特性</p><p>GC - 垃圾回收，jvm内存管理器；golang和rust在编译时候就进行垃圾回收处理，不需要虚拟机。java是二进制跨平台，c&amp;c++是源代码跨平台的。</p><p>java跨平台，一直向前兼容，生态完整（任何东西java实现都可以找到）。</p><p><strong>总结下学了什么，有哪些点没懂？</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客大学 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 秦金卫 </tag>
            
            <tag> Java 进阶训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/02/18/hello-world/"/>
      <url>2021/02/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
